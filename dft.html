<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Modeling materials using density functional theory</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="title" content="Modeling materials using density functional theory"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-07-11 Wed"/>
<meta name="author" content="John Kitchin"/>
<meta name="description" content="A book on using density functional theory to model materials."/>
<meta name="keywords" content="Density functional theory, materials, VASP"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="dft.css"/>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Modeling materials using density functional theory</h1>


<p>
<img src="./images/cover-page.png" width="500px" alt="./images/cover-page.png" />
</p>
<p>
    Copyright \copyright 2012&ndash;\the\year\ John Kitchin</p ><p >
    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
</p>





<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Introduction to this book</a></li>
<li><a href="#sec-2">2 Introduction to DFT</a>
<ul>
<li><a href="#sec-2-1">2.1 Background</a></li>
<li><a href="#sec-2-2">2.2 Exchange correlation functionals</a></li>
<li><a href="#sec-2-3">2.3 Basis sets</a></li>
<li><a href="#sec-2-4">2.4 Pseudopotentials</a></li>
<li><a href="#sec-2-5">2.5 Fermi Temperature and band occupation numbers</a></li>
<li><a href="#sec-2-6">2.6 Spin polarization and magnetism</a></li>
<li><a href="#sec-2-7">2.7 Recommended reading</a></li>
</ul>
</li>
<li><a href="#sec-3">3 Molecules</a>
<ul>
<li><a href="#sec-3-1">3.1 Defining and visualizing molecules</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1 From scratch</a></li>
<li><a href="#sec-3-1-2">3.1.2 Reading other data formats into a calculation</a></li>
<li><a href="#sec-3-1-3">3.1.3 Predefined molecules</a></li>
<li><a href="#sec-3-1-4">3.1.4 Combining Atoms objects</a></li>
</ul>
</li>
<li><a href="#sec-3-2">3.2 Simple properties</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1 Getting cartesian positions</a></li>
<li><a href="#sec-3-2-2">3.2.2 Molecular weight and molecular formula</a></li>
<li><a href="#sec-3-2-3">3.2.3 Center of mass</a></li>
<li><a href="#sec-3-2-4">3.2.4 Moments of inertia</a></li>
<li><a href="#sec-3-2-5">3.2.5 Computing bond lengths and angles</a>
<ul>
<li><a href="#sec-3-2-5-1">3.2.5.1 Dihedral angles</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3 Simple properties that require single computations</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1 Energy and forces</a>
<ul>
<li><a href="#sec-3-3-1-1">3.3.1.1 Convergence with unit cell size</a></li>
<li><a href="#sec-3-3-1-2">3.3.1.2 Convergence of ENCUT</a></li>
</ul>
</li>
<li><a href="#sec-3-3-2">3.3.2 Visualizing electron density</a></li>
<li><a href="#sec-3-3-3">3.3.3 Dipole moments</a></li>
<li><a href="#sec-3-3-4">3.3.4 The density of states (DOS)</a></li>
<li><a href="#sec-3-3-5">3.3.5 Atom-projected density of states on molecules</a></li>
<li><a href="#sec-3-3-6">3.3.6 Electrostatic potential</a></li>
<li><a href="#sec-3-3-7">3.3.7 Bader analysis</a></li>
</ul>
</li>
<li><a href="#sec-3-4">3.4 Geometry optimization</a>
<ul>
<li><a href="#sec-3-4-1">3.4.1 Manual determination of a bond length</a></li>
<li><a href="#sec-3-4-2">3.4.2 Automatic geometry optimization with VASP</a></li>
<li><a href="#sec-3-4-3">3.4.3 Relaxation of a water molecule</a></li>
</ul>
</li>
<li><a href="#sec-3-5">3.5 Vibrational frequencies</a>
<ul>
<li><a href="#sec-3-5-1">3.5.1 Manual calculation of vibrational frequency</a></li>
<li><a href="#sec-3-5-2">3.5.2 Automated vibrational calculations</a>
<ul>
<li><a href="#sec-3-5-2-1">3.5.2.1 Zero-point energy for multiple modes</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3-6">3.6 Simulated infrared spectra</a></li>
<li><a href="#sec-3-7">3.7 Thermochemical properties of molecules</a></li>
<li><a href="#sec-3-8">3.8 Molecular reaction energies</a>
<ul>
<li><a href="#sec-3-8-1">3.8.1 O<sub>2</sub> dissociation</a>
<ul>
<li><a href="#sec-3-8-1-1">3.8.1.1 Simple estimate of O<sub>2</sub> dissociation energy</a></li>
<li><a href="#sec-3-8-1-2">3.8.1.2 Estimating O<sub>2</sub> dissociation energy with spin polarization in triplet ground states</a></li>
<li><a href="#sec-3-8-1-3">3.8.1.3 Convergence study of the O<sub>2</sub> dissociation energy</a></li>
<li><a href="#sec-3-8-1-4">3.8.1.4 Illustration of the effect of SIGMA</a></li>
<li><a href="#sec-3-8-1-5">3.8.1.5 Estimating triplet oxygen dissociation energy with low symmetry</a></li>
<li><a href="#sec-3-8-1-6">3.8.1.6 Estimating singlet oxygen dissociation energy</a></li>
<li><a href="#sec-3-8-1-7">3.8.1.7 Verifying the magnetic moments on each atom</a></li>
<li><a href="#sec-3-8-1-8">3.8.1.8 Using a different potential</a></li>
</ul>
</li>
<li><a href="#sec-3-8-2">3.8.2 Water gas shift example</a>
<ul>
<li><a href="#sec-3-8-2-1">3.8.2.1 Calculation summaries</a></li>
</ul>
</li>
<li><a href="#sec-3-8-3">3.8.3 Temperature dependent water gas shift equilibrium constant</a>
<ul>
<li><a href="#sec-3-8-3-1">3.8.3.1 CO vibrations</a></li>
<li><a href="#sec-3-8-3-2">3.8.3.2 CO<sub>2</sub> vibrations</a></li>
<li><a href="#sec-3-8-3-3">3.8.3.3 H<sub>2</sub> vibrations</a></li>
<li><a href="#sec-3-8-3-4">3.8.3.4 H<sub>2</sub>O vibrations</a></li>
<li><a href="#sec-3-8-3-5">3.8.3.5 Thermochemistry</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-3-9">3.9 Molecular reaction barriers</a>
<ul>
<li><a href="#sec-3-9-1">3.9.1 Get initial and final states</a></li>
<li><a href="#sec-3-9-2">3.9.2 Run band calculation</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-4">4 Bulk systems</a>
<ul>
<li><a href="#sec-4-1">4.1 Defining and visualizing bulk systems</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1 Built-in functions in ase</a>
<ul>
<li><a href="#sec-4-1-1-1">4.1.1.1 mod:ase.spacegroup</a></li>
</ul>
</li>
<li><a href="#sec-4-1-2">4.1.2 Using http://materialsproject.org</a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2 Computational parameters that are important for bulk structures</a>
<ul>
<li><a href="#sec-4-2-1">4.2.1 k-point convergence</a></li>
<li><a href="#sec-4-2-2">4.2.2 Effect of SIGMA</a></li>
<li><a href="#sec-4-2-3">4.2.3 The number of bands</a></li>
</ul>
</li>
<li><a href="#sec-4-3">4.3 Determining bulk structures</a>
<ul>
<li><a href="#sec-4-3-1">4.3.1 fcc/bcc crystal structures</a></li>
<li><a href="#sec-4-3-2">4.3.2 Optimizing the hcp lattice constant</a></li>
<li><a href="#sec-4-3-3">4.3.3 Complex structures with internal degrees of freedom</a></li>
<li><a href="#sec-4-3-4">4.3.4 Effect of XC on bulk properties</a></li>
</ul>
</li>
<li><a href="#sec-4-4">4.4 Cohesive energy</a></li>
<li><a href="#sec-4-5">4.5 Elastic properties</a></li>
<li><a href="#sec-4-6">4.6 Bulk thermodynamics</a></li>
<li><a href="#sec-4-7">4.7 Effect of pressure on phase stability</a></li>
<li><a href="#sec-4-8">4.8 Bulk reaction energies</a>
<ul>
<li><a href="#sec-4-8-1">4.8.1 Alloy formation energies</a>
<ul>
<li><a href="#sec-4-8-1-1">4.8.1.1 Basic alloy formation energy</a></li>
</ul>
</li>
<li><a href="#sec-4-8-2">4.8.2 Metal oxide oxidation energies</a>
<ul>
<li><a href="#sec-4-8-2-1">4.8.2.1 Cu<sub>2</sub>O calculation</a></li>
<li><a href="#sec-4-8-2-2">4.8.2.2 CuO calculation</a></li>
<li><a href="#sec-4-8-2-3">4.8.2.3 Reaction energy calculation</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-4-9">4.9 Bulk density of states</a></li>
<li><a href="#sec-4-10">4.10 Atom projected density of states</a>
<ul>
<li><a href="#sec-4-10-1">4.10.1 Effect of RWIGS on ADOS</a></li>
</ul>
</li>
<li><a href="#sec-4-11">4.11 Band structures</a>
<ul>
<li><a href="#sec-4-11-1">4.11.1 create example showing band dispersion with lattice constant</a></li>
</ul>
</li>
<li><a href="#sec-4-12">4.12 Magnetism</a>
<ul>
<li><a href="#sec-4-12-1">4.12.1 Determining if a magnetic solution is energetically favorable</a></li>
<li><a href="#sec-4-12-2">4.12.2 Antiferromagnetic spin states</a></li>
<li><a href="#sec-4-12-3">4.12.3 NiO-FeO formation energies with magnetism</a></li>
</ul>
</li>
<li><a href="#sec-4-13">4.13 phonons</a></li>
<li><a href="#sec-4-14">4.14 solid state NEB</a></li>
</ul>
</li>
<li><a href="#sec-5">5 Surfaces</a>
<ul>
<li><a href="#sec-5-1">5.1 Surface structures</a>
<ul>
<li><a href="#sec-5-1-1">5.1.1 Simple surfaces</a></li>
<li><a href="#sec-5-1-2">5.1.2 Vicinal surfaces</a></li>
</ul>
</li>
<li><a href="#sec-5-2">5.2 Surface calculation parameters</a></li>
<li><a href="#sec-5-3">5.3 Surface relaxation</a></li>
<li><a href="#sec-5-4">5.4 Surface reconstruction</a>
<ul>
<li><a href="#sec-5-4-1">5.4.1 Au(110) missing row reconstruction</a>
<ul>
<li><a href="#sec-5-4-1-1">5.4.1.1 Clean Au(110) slab</a></li>
<li><a href="#sec-5-4-1-2">5.4.1.2 Missing row in Au(110)</a></li>
<li><a href="#sec-5-4-1-3">5.4.1.3 Bulk Au</a></li>
<li><a href="#sec-5-4-1-4">5.4.1.4 Analysis of energies</a></li>
</ul>
</li>
<li><a href="#sec-5-4-2">5.4.2 Ag(110) missing row reconstruction</a>
<ul>
<li><a href="#sec-5-4-2-1">5.4.2.1 Clean Ag(110) slab</a></li>
<li><a href="#sec-5-4-2-2">5.4.2.2 Missing row in Ag(110)</a></li>
<li><a href="#sec-5-4-2-3">5.4.2.3 Bulk Ag</a></li>
<li><a href="#sec-5-4-2-4">5.4.2.4 Analysis of energies</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-5-5">5.5 Work function</a></li>
<li><a href="#sec-5-6">5.6 Surface energy</a>
<ul>
<li><a href="#sec-5-6-1">5.6.1 Advanced topics in surface energy</a></li>
</ul>
</li>
<li><a href="#sec-5-7">5.7 Dipole correction</a>
<ul>
<li><a href="#sec-5-7-1">5.7.1 Slab with no dipole correction</a></li>
<li><a href="#sec-5-7-2">5.7.2 Slab with a dipole correction</a></li>
<li><a href="#sec-5-7-3">5.7.3 Comparing no dipole correction with a dipole correction</a></li>
</ul>
</li>
<li><a href="#sec-5-8">5.8 Adsorption energies</a>
<ul>
<li><a href="#sec-5-8-1">5.8.1 Simple estimate of the adsorption energy</a>
<ul>
<li><a href="#sec-5-8-1-1">5.8.1.1 Calculations</a></li>
<li><a href="#sec-5-8-1-2">5.8.1.2 Analysis of adsorption energies</a></li>
<li><a href="#sec-5-8-1-3">5.8.1.3 Adsorption on bridge site with constraints</a></li>
</ul>
</li>
<li><a href="#sec-5-8-2">5.8.2 Coverage dependence</a>
<ul>
<li><a href="#sec-5-8-2-1">5.8.2.1 clean slab calculation</a></li>
<li><a href="#sec-5-8-2-2">5.8.2.2 fcc site at 1 ML coverage</a></li>
<li><a href="#sec-5-8-2-3">5.8.2.3 Adsorption energy at 1ML</a></li>
</ul>
</li>
<li><a href="#sec-5-8-3">5.8.3 Effect of adsorption on the surface energy</a></li>
</ul>
</li>
<li><a href="#sec-5-9">5.9 Adsorbate vibrations</a>
<ul>
<li><a href="#sec-5-9-1">5.9.1 Vibrations of the bridge site</a></li>
</ul>
</li>
<li><a href="#sec-5-10">5.10 Surface Diffusion barrier</a>
<ul>
<li><a href="#sec-5-10-1">5.10.1 Standard nudged elastic band method</a></li>
<li><a href="#sec-5-10-2">5.10.2 Climbing image NEB</a></li>
<li><a href="#sec-5-10-3">5.10.3 Using vibrations to confirm a transition state</a></li>
</ul>
</li>
<li><a href="#sec-5-11">5.11 Diffusion rates with transition state theory</a></li>
<li><a href="#sec-5-12">5.12 Effects of electric fields on adsorbates</a></li>
<li><a href="#sec-5-13">5.13 Simulating STM images</a></li>
</ul>
</li>
<li><a href="#sec-6">6 Atomistic thermodynamics</a>
<ul>
<li><a href="#sec-6-1">6.1 Bulk phase stability of oxides</a></li>
<li><a href="#sec-6-2">6.2 Effect on adsorption</a></li>
<li><a href="#sec-6-3">6.3 Atomistic therodynamics and multiple reactions</a></li>
</ul>
</li>
<li><a href="#sec-7">7 Advanced electronic structure methods</a>
<ul>
<li><a href="#sec-7-1">7.1 DFT+U</a>
<ul>
<li><a href="#sec-7-1-1">7.1.1 Metal oxide oxidation energies with DFT+U</a>
<ul>
<li><a href="#sec-7-1-1-1">7.1.1.1 Cu<sub>2</sub>O calculation with U=4.0</a></li>
<li><a href="#sec-7-1-1-2">7.1.1.2 CuO calculation with U=4.0</a></li>
<li><a href="#sec-7-1-1-3">7.1.1.3 Reaction energy calculation with DFT+U</a></li>
<li><a href="#sec-7-1-1-4">7.1.1.4 How much does U affect the reaction energy?</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-7-2">7.2 Hybrid functionals</a>
<ul>
<li><a href="#sec-7-2-1">7.2.1 FCC Ni DOS</a></li>
</ul>
</li>
<li><a href="#sec-7-3">7.3 DFT+D</a>
<ul>
<li><a href="#sec-7-3-1">7.3.1 PBE</a>
<ul>
<li><a href="#sec-7-3-1-1">7.3.1.1 gas-phase benzene</a></li>
<li><a href="#sec-7-3-1-2">7.3.1.2 clean slab</a></li>
<li><a href="#sec-7-3-1-3">7.3.1.3 benzene on Au(111)</a></li>
</ul>
</li>
<li><a href="#sec-7-3-2">7.3.2 DFT-D2</a>
<ul>
<li><a href="#sec-7-3-2-1">7.3.2.1 gas-phase benzene</a></li>
<li><a href="#sec-7-3-2-2">7.3.2.2 clean slab</a></li>
<li><a href="#sec-7-3-2-3">7.3.2.3 benzene on Au(111)</a></li>
</ul>
</li>
<li><a href="#sec-7-3-3">7.3.3 Advanced vdW-DF functionals</a></li>
</ul>
</li>
<li><a href="#sec-7-4">7.4 ELF</a></li>
<li><a href="#sec-7-5">7.5 Charge partitioning schemes</a></li>
<li><a href="#sec-7-6">7.6 Modeling Core level shifts</a></li>
</ul>
</li>
<li><a href="#sec-8">8 Acknowledgments</a></li>
<li><a href="#sec-9">9 Appendices</a>
<ul>
<li><a href="#sec-9-1">9.1 Recipes</a>
<ul>
<li><a href="#sec-9-1-1">9.1.1 Modifying Atoms by deleting atoms</a></li>
<li><a href="#sec-9-1-2">9.1.2 Advanced tagging</a></li>
<li><a href="#sec-9-1-3">9.1.3 Using units in ase</a></li>
<li><a href="#sec-9-1-4">9.1.4 Extracting parts of an array</a></li>
<li><a href="#sec-9-1-5">9.1.5 Statistics</a>
<ul>
<li><a href="#sec-9-1-5-1">9.1.5.1 Confidence intervals</a></li>
</ul>
</li>
<li><a href="#sec-9-1-6">9.1.6 Curve fitting</a>
<ul>
<li><a href="#sec-9-1-6-1">9.1.6.1 Linear fitting</a></li>
</ul>
</li>
<li><a href="#sec-9-1-7">9.1.7 Nonlinear curve fitting</a></li>
<li><a href="#sec-9-1-8">9.1.8 Nonlinear curve fitting by direct least squares minimization</a></li>
<li><a href="#sec-9-1-9">9.1.9 Nonlinear curve fitting with confidence intervals</a></li>
<li><a href="#sec-9-1-10">9.1.10 Interpolation with splines</a></li>
<li><a href="#sec-9-1-11">9.1.11 Interpolation in 3D</a></li>
<li><a href="#sec-9-1-12">9.1.12 Reading and writing data</a>
<ul>
<li><a href="#sec-9-1-12-1">9.1.12.1 Built-in io modules</a></li>
<li><a href="#sec-9-1-12-2">9.1.12.2 From scratch</a></li>
</ul>
</li>
<li><a href="#sec-9-1-13">9.1.13 Integration</a></li>
<li><a href="#sec-9-1-14">9.1.14 Numerical differentiation</a>
<ul>
<li><a href="#sec-9-1-14-1">9.1.14.1 Simple loops to define finite difference derivatives</a></li>
<li><a href="#sec-9-1-14-2">9.1.14.2 FFT derivatives</a></li>
</ul>
</li>
<li><a href="#sec-9-1-15">9.1.15 NetCDF files</a></li>
<li><a href="#sec-9-1-16">9.1.16 Python modules</a></li>
<li><a href="#sec-9-1-17">9.1.17 Writing and reading Excel files</a>
<ul>
<li><a href="#sec-9-1-17-1">9.1.17.1 Writing Excel files</a></li>
<li><a href="#sec-9-1-17-2">9.1.17.2 Reading Excel files</a></li>
</ul>
</li>
<li><a href="#sec-9-1-18">9.1.18 making movies</a></li>
</ul>
</li>
<li><a href="#sec-9-2">9.2 Computational geometry</a>
<ul>
<li><a href="#sec-9-2-1">9.2.1 Changing coordinate systems</a></li>
<li><a href="#sec-9-2-2">9.2.2 Simple distances, angles</a></li>
<li><a href="#sec-9-2-3">9.2.3 Unit cell properties</a></li>
<li><a href="#sec-9-2-4">9.2.4 d-spacing</a></li>
</ul>
</li>
<li><a href="#sec-9-3">9.3 Equations of State</a>
<ul>
<li><a href="#sec-9-3-1">9.3.1 Birch-Murnaghan</a></li>
<li><a href="#sec-9-3-2">9.3.2 Murnaghan</a></li>
<li><a href="#sec-9-3-3">9.3.3 Birch</a></li>
<li><a href="#sec-9-3-4">9.3.4 The Anton-Schmidt Equation of state cite:Mayer200323</a></li>
<li><a href="#sec-9-3-5">9.3.5 Fitting data to these equations of state</a></li>
</ul>
</li>
<li><a href="#sec-9-4">9.4 Miscellaneous \texttt{jasp}/VASP tips</a>
<ul>
<li><a href="#sec-9-4-1">9.4.1 Installing jasp</a></li>
<li><a href="#sec-9-4-2">9.4.2 Using a special setup</a></li>
<li><a href="#sec-9-4-3">9.4.3 Running jasp in parallel</a></li>
<li><a href="#sec-9-4-4">9.4.4 Running multiple instances of jasp in parallel</a></li>
<li><a href="#sec-9-4-5">9.4.5 Exporting data json, xml, python, sqlite</a>
<ul>
<li><a href="#sec-9-4-5-1">9.4.5.1 python</a></li>
<li><a href="#sec-9-4-5-2">9.4.5.2 json</a></li>
<li><a href="#sec-9-4-5-3">9.4.5.3 xml</a></li>
</ul>
</li>
<li><a href="#sec-9-4-6">9.4.6 Recommended values for ENCUT and valence electrons for different POTCAR files</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-10">10 Python</a>
<ul>
<li><a href="#sec-10-1">10.1 easy_install as a user</a></li>
<li><a href="#sec-10-2">10.2 Integer division math gotchas</a></li>
</ul>
</li>
<li><a href="#sec-11">11 References</a></li>
<li><a href="#sec-12">12 GNU Free Documentation License</a></li>
<li><a href="#sec-13">13 Index</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction to this book</h2>
<div class="outline-text-2" id="text-1">

<p>This book serves two purposes: 1) to provide worked examples of using DFT to model materials properties, and 2) to provide references to more advanced treatments of these topics in the literature. It is not a definitive reference on density functional theory. Along the way to learning how to perform the calculations, you will learn how to analyze the data, make plots, and how to interpret the results. This book is very much "recipe" oriented, with the intention of giving you enough information and knowledge to start your research. In that sense, many of the computations are not publication quality with respect to convergence of calculation parameters.
</p>
<p>
You will read a lot of python code in this book, as the comprehension of code is an integral part of its design. I believe that computational work should always be scripted. As a result, a written record of everything you have done will be available, allowing you to reproduce your code or report the method of its execution exactly at a later time.
</p>
<p>
This book makes heavy use of many computational tools including:
</p>
<ul>
<li><a href="http://python.org/">Python</a>
<ul>
<li><a href="http://docs.python.org/modindex.html">Module index</a>
</li>
</ul>

</li>
<li><a href="https://wiki.fysik.dtu.dk/ase/">Atomic Simulation Environment (ase)</a>
</li>
<li><a href="http://numpy.scipy.org/">numpy</a>
</li>
<li><a href="http://www.scipy.org/">scipy</a>
</li>
<li><a href="http://matplotlib.sourceforge.net/">matplotlib</a>
</li>
<li><a href="http://www.gnu.org/software/emacs/">emacs</a>
<ul>
<li><a href="http://orgmode.org">org-mode</a> This book is written in org-mode, and is best read in
    emacs in org-mode. This format provides clickable links, easy
    navigation, syntax highlighting, as well as the ability to
    interact with the tables and code. The book is also available in
    PDF.
</li>
</ul>

</li>
<li><a href="http://github.org">git</a>
  This book is available at <a href="https://github.com/jkitchin/dft-book">https://github.com/jkitchin/dft-book</a>

</li>
<li><a href="https://github.com/jkitchin/jasp">jasp</a>
</li>
</ul>


<p>
<TT>jasp</TT> is a sophisticated wrapper to the <TT>ase.calculators.vasp</TT> python interface to the VASP calculator. It was written by me to facilitate writing this book and to develop the best possible way to run DFT calculations. The best way to learn to use jasp is from this book. It probably requires the latest svn version of ase to work since I have been adding new functionality to <TT>ase.calculators.vasp</TT> as <TT>jasp</TT> is developed. <TT>jasp</TT> is available at <a href="https://github.com/jkitchin/jasp">https://github.com/jkitchin/jasp</a>.
</p>
<p>
The goal in writing <TT>jasp</TT> was to create a computational environment where you write one script to create, run and analyze your calculations. The code is smart, and submits jobs to a queue system when required, does not submit jobs more than once, allows many jobs to run in parallel, and gives you answers when available. <TT>jasp</TT> takes care of changing into VASP calculation directories, and then changing back to where you started from. <TT>jasp</TT> has an interface to sqlite, and to version control (git) software. <TT>jasp</TT> has some features that
<TT>ase.calculators.vasp</TT> does not have yet. They may get incorporated into ase one day.
</p>
<p>
<code>jaspsum</code> is a utility program provided in jasp which prints a pretty representation of the state of a calculation, plots the relaxation trajectory, or prints a code representation of a VASP directory.
</p>
<p>
It is not critical that you use <TT>jasp</TT>. You should be able to copy the actual VASP input files (which were generated by jasp) from a directory and simply run vasp. <TT>jasp</TT> is mostly compatible with <TT>ase.calculators.vasp</TT>, so you can replace this kind of code:
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'directory'</span>, lotsofkeywords, atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">do stuff</span>
</pre>


<p>
with code similar to this:
</p>


<pre class="src src-python">CWD = os.getcwd()
os.chdir(<span style="color: #00cd00;">'directory'</span>)
calc=Vasp(lotsofkeywords)
atoms.set_calculator(calc)

<span style="color: #cd0000; font-weight: bold;">try:</span>
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">do stuff</span>
<span style="color: #cd0000; font-weight: bold;">finally:</span>
    os.chdir(CWD)
</pre>


<p>
The DFT code used primarily in this book is <a href="http://cms.mpi.univie.ac.at/vasp/guide/vasp.html">VASP</a>.
</p><ul>
<li><a href="http://cms.mpi.univie.ac.at/wiki/index.php/Main_Page">VASP wiki</a>
</li>
<li><a href="http://cms.mpi.univie.ac.at/wiki/index.php/The_VASP_Manual">VASP Manual</a>
</li>
</ul>


<p>
Similar code would be used for other calculators, e.g. GPAW, Jacapo, etc&hellip; you would just have to import the python modules for those codes, and replace the code that defines the calculator.
</p>

<div class="exercise">
<p>Review all the hyperlinks in this chapter.
</p>
</div>

</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Introduction to DFT</h2>
<div class="outline-text-2" id="text-2">


<p>
A comprehensive overview of DFT is beyond the scope of this book, as
excellent reviews on these subjects are readily found in the
literature, and are suggested reading in the following paragraph.
Instead, this chapter is intended to provide a useful starting point
for a non-expert to begin learning about and using DFT in the manner
used in this book. Much of the information presented here is standard
knowledge among experts, but a consequence of this is that it is
rarely discussed in current papers in the literature. A secondary goal
of this chapter is to provide new users with a path through the
extensive literature available and to point out potential difficulties
and pitfalls in these calculations.
</p>
<p>
A fairly standard textbook on DFT is the one written by Parr and Yang
(<cite>parr-yang</cite>).  The Chemist's Guide to DFT (<cite>koch2001</cite>) is more
readable and contains more practical information for running
calculations, but both of these books focus on molecular systems.
 The standard texts in this solid state physics are by Kittel (<cite>kittel</cite>)
and Ashcroft and Mermin (<cite>ashcroft-mermin</cite>). Both have their fine
points, the former being more mathematically rigorous and the latter
more readable.  However, neither of these books is particularly easy
to relate to chemistry.  For this, one should consult the
exceptionally clear writings of Roald Hoffman
(<cite>hoffmann1987,RevModPhys.60.601</cite>), and follow these with the work of
N\o rskov and coworkers
(<cite>hammer2000:adv-cat,greeley2002:elect</cite>).
</p>
<p>
In this chapter, only the elements of DFT that are relevant to this
work will be discussed.  An excellent review on other implementations
of DFT can be found in Reference (<cite>freeman1995:densit</cite>),  and
details on the various algorithms used in DFT codes can be found in
Refs.  (<cite>payne1992:iterat,Kresse199615</cite>).
</p>
<p>
One of the most useful sources of information has been the
dissertations of other students, perhaps because the difficulties they
faced in learning the material are still fresh in their minds. Thomas
Bligaard, a coauthor of Dacapo, wrote a particularly relevant thesis
on exchange/correlation functionals
(<cite>bligaard2000:exchan-correl-funct</cite>) and a dissertation
illustrating the use of DFT to design new alloys with desirable
thermal and mechanical properties
(<cite>bligaard2003:under-mater-proper-basis-densit</cite>).  The Ph.D.
thesis of Ari Seitsonen contains several useful appendices on k-point
setups, and convergence tests of calculations, in addition to a
thorough description of DFT and analysis of calculation output
(<cite>seitsonen2000:phd</cite>). Finally, another excellent overview of DFT
and its applications to bimetallic alloy phase diagrams and surface
reactivity is presented in the PhD thesis of Robin Hirschl
(<cite>hirschl2002:binar-trans-metal-alloy-their-surfac</cite>).
</p>

</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Background</h3>
<div class="outline-text-3" id="text-2-1">

<p>In 1926, Erwin Schr\"odinger published the first accounts of his now
famous wave equation (<cite>pauling1963</cite>). He later shared the Nobel
prize with Paul A. M. Dirac in 1933 for this discovery. Schr\"odinger's
wave function seemed extremely promising, as it contains all of the
information available about a system. Unfortunately, most practical
systems of interest consist of many interacting electrons, and the
effort required to find solutions to Schr\"odinger's equation increases
exponentially with the number of electrons, limiting this approach to
systems with a small number of relevant electrons, <img src="ltxpng/dft_64f9637496c2aa41c01ee9c7d31546590b62881e.png" alt="$N \lesssim O(10)$"/>
(<cite>RevModPhys.71.1253</cite>). Even if this rough estimate is off by an order of
magnitude, a system with 100 electrons is still very small, for
example, two Ru atoms if all the electrons are counted, or perhaps ten
Pt atoms if only the valence electrons are counted. Thus, the wave
function method, which has been extremely successful in studying the
properties of small molecules, is unsuitable for studies of large,
extended solids. Interestingly, this difficulty was recognized by
Dirac as early as 1929, when he wrote "The underlying physical laws
necessary for the mathematical theory of a large part of physics and
the whole of chemistry are thus completely known, and the difficulty
is only that the application of these laws leads to equations much too
complicated to be soluble."
(<cite>dirac1929:quant-mechan-many-elect-system</cite>).
</p>
<p>
In 1964, Hohenberg and Kohn showed that the ground state total energy
of a system of interacting electrons is a unique functional of the
electron density (<cite>PhysRev.136.B864</cite>). By definition,
a function returns a number when given a number. For example, in
<img src="ltxpng/dft_3c6f4b44ac959cb44461bd1b3c70b796bcefc7d0.png" alt="$f(x)=x^2$"/>, <img src="ltxpng/dft_d9ab25d57c8996af22396857c3b91accc54ba716.png" alt="$f(x)$"/> is the function, and it equals four when <img src="ltxpng/dft_68ad7d8f41b23e4e3d3c5b613467e87bd95c5599.png" alt="$x=2$"/>. A
functional returns a number when given a function. Thus, in
<img src="ltxpng/dft_f53564be48061c91c0037286e0cd0862e2d6ab11.png" alt="$g(f(x))=\int_0^\pi f(x) dx$"/>, <img src="ltxpng/dft_f9da11e178160039ab381d7cd0393143e0521ecc.png" alt="$g(f(x))$"/> is the functional, and it is
equal to two when <img src="ltxpng/dft_2ac6d0dd03f73b76893bad0afc09e1843c81bb9c.png" alt="$f(x)=\sin(x)$"/>. Hohenberg and Kohn further
identified a variational principle that appeared to reduce the problem
of finding the ground state energy of an electron gas in an external
potential (i.e., in the presence of ion cores) to that of the
minimization of a functional of the three-dimensional density
function.  Unfortunately, the definition of the functional involved a
set of 3N-dimensional trial wave functions.
</p>
<p>
In 1965, Kohn and Sham made a significant breakthrough when they
showed that the problem of many interacting electrons in an external
potential can be mapped exactly to a set of noninteracting electrons
in an effective external potential
(<cite>PhysRev.140.A1133</cite>).  This led to a set of
self-consistent, single particle equations known as the Kohn-Sham (KS)
equations:
</p>

<p>
<img src="ltxpng/dft_ccb527e2407323fab3cb43b798c33c7fa989e470.png" alt="\begin{equation}\label{eq:KS}
\biggl(-\frac{1}{2}\nabla^2 + v_{eff}(\mathbf{r}) -\epsilon_j\biggr)\varphi_j(\mathbf{r})=0,
\end{equation}"/>
</p>


<p>
with
</p>


<p>
<img src="ltxpng/dft_0dbfaf026016765fb3088166471a65ea73203105.png" alt="\begin{equation}\label{eq:veff}
v_{eff}(\mathbf{r})=v(\mathbf{r})+\int \frac{n(\mathbf{r'})}{|\mathbf{r-r'}|}d\mathbf{r'} + v_{xc}(\mathbf{r}),
\end{equation}"/>
</p>

<p>
where <img src="ltxpng/dft_96c256bf63a27d4f7f73718cfa5f79ad41ea5b7a.png" alt="$v(\mathbf{r})$"/> is the external potential and <img src="ltxpng/dft_28db103db6c6f43fc900ebab8983e0c54f8218e8.png" alt="$v_{xc}(\mathbf{r})$"/> is the
exchange-correlation potential, which depends on the entire density
function. Thus, the density needs to be known in order to define the
effective potential so that Eq. \eqref{eq:KS} can be solved.
<img src="ltxpng/dft_119475097aa0dfc84832913e68262e970b0ba2dc.png" alt="$\varphi_j(\mathbf{r})$"/> corresponds to the <img src="ltxpng/dft_e0f45c41d4f693ed839f356dc853352fb31b0ee8.png" alt="$j^{th}$"/> KS orbital of energy
<img src="ltxpng/dft_2ee51ca3280eff482c73bdcfbbf71bda482ac7e3.png" alt="$\epsilon_j$"/>.
</p>
<p>
The ground state density is given by:
</p>

<p>
<img src="ltxpng/dft_fc425d900c910210a184847333eb6107c5a47fac.png" alt="\begin{equation}\label{eq:density}
\displaystyle
n(\mathbf{r})=\sum_{j=1}^{N}|\varphi_j(\mathbf{r})|^2
\end{equation}"/>
</p>

<p>
To solve Eq. \eqref{eq:KS} then, an initial guess is used for
<img src="ltxpng/dft_8da5749616919d07ea664459d7a523fc83178fec.png" alt="$\varphi_j(r)$"/> which is used to generate Eq. \eqref{eq:density}, which
is subsequently used in Eq. \eqref{eq:veff}. This equation is then
solved for <img src="ltxpng/dft_119475097aa0dfc84832913e68262e970b0ba2dc.png" alt="$\varphi_j(\mathbf{r})$"/> iteratively until the <img src="ltxpng/dft_119475097aa0dfc84832913e68262e970b0ba2dc.png" alt="$\varphi_j(\mathbf{r})$"/> that
result from the solution are the same as the <img src="ltxpng/dft_119475097aa0dfc84832913e68262e970b0ba2dc.png" alt="$\varphi_j(\mathbf{r})$"/> that are
used to define the equations, that is, the solutions are
self-consistent.  Finally, the ground state energy is given by:
</p>


<p>
<img src="ltxpng/dft_a07c6405e77c84fd370f51adb41307b97b429625.png" alt="\begin{equation}\label{eq:dftEnergy} 
\displaystyle
E=\sum_j\epsilon_j + E_{xc}[n(\mathbf{r})]-\int v_{xc}(\mathbf{r}) n(\mathbf{r}) d\mathbf{r}
  -\frac{1}{2}\int{\frac{n(\mathbf{r})n(\mathbf{r'})}{|\mathbf{r-r'}|}d\mathbf{r'}\mathbf{r}},
\end{equation}"/>
</p>

<p>
where <img src="ltxpng/dft_658b24ba25cb92ce83484a230f3e3d647fe37091.png" alt="$E_{xc}[n(\mathbf{r})]$"/> is the exchange-correlation energy
functional.  Walter Kohn shared the Nobel prize in Chemistry in 1998
for this work (<cite>RevModPhys.71.1253</cite>). The other half of the prize went to
John Pople for his efforts in wave function based quantum mechanical
methods (<cite>RevModPhys.71.1267</cite>).  Provided the
exchange-correlation energy functional is known, Eq.
(ref:ref:eq:dftEnergy) is exact.  However, the exact form of the
exchange-correlation energy functional is not known, thus
approximations for this functional must be used.
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Exchange correlation functionals</h3>
<div class="outline-text-3" id="text-2-2">


<p>
The two main types of exchange/correlation functionals used in DFT are
the local density approximation (LDA) and the generalized gradient
approximation (GGA). In the LDA, the exchange-correlation functional
is defined for an electron in a uniform electron gas of density <img src="ltxpng/dft_4a95e7a167dd37c165400bfaa98d5a68f3bd79b4.png" alt="$n$"/>
(<cite>PhysRev.140.A1133</cite>). It is obviously exact for a uniform
electron gas, and is anticipated to be valid for slowly varying
densities. In molecules and solids, however, the density tends to vary
substantially in space. Despite this, the LDA has been very
successfully used in many systems. It tends to predict overbonding in
both molecular and solid systems (<cite>fuchs1998:pseud</cite>), and it tends
to make semiconductor systems too metallic (the band gap problem)
(<cite>perdew1982:elect-kohn-sham</cite>).
</p>
<p>
The generalized gradient approximation includes corrections for
gradients in the electron density, and is often implemented as a
corrective function of the LDA.  The form of this corrective function,
or "exchange enhancement" function determines which functional it
is, e.g. PBE, RPBE, revPBE, etc. (<cite>hammer1999:improv-pbe</cite>). In this
book the PBE GGA functional is used the most. N{\o}rskov and coworkers
have found that the RPBE functional gives superior chemisorption
energies for atomic and molecular bonding to surfaces, but that it
gives worse bulk properties, such as lattice constants compared to
experimental data (<cite>hammer1999:improv-pbe</cite>).
</p>
<p>
 Finally, there are increasingly new types of functionals
in the literature. The so-called hybrid functionals, such as B3LYP,
are more popular with gaussian basis sets (e.g. in Gaussian), but they
are presently inefficient with planewave basis sets. None of these
other types of functionals were used in this work. For more details
see Chapter 6 in Ref. (<cite>koch2001</cite>) and Thomas Bligaard's thesis on
exchange and correlation functionals
(<cite>bligaard2000:exchan-correl-funct</cite>).
</p>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Basis sets</h3>
<div class="outline-text-3" id="text-2-3">

<p>Briefly, VASP utilizes planewaves as the basis set to expand the
Kohn-Sham orbitals.  In a periodic solid, one can use Bloch's theorem
to show that the wave function for an electron can be expressed as the
product of a planewave and a function with the periodicity of the
lattice (<cite>ashcroft-mermin</cite>):
</p>

<p>
<img src="ltxpng/dft_0494ba79c9a3f891c746b30e3bc7038028c4b9ee.png" alt="\begin{equation}
\psi_{n\mathbf{k}}(\mathbf{r})=\exp({i\mathbf{k}\cdot\mathbf{r}})u_{n\mathbf{k}}(\mathbf{r})
\end{equation}"/>
</p>

<p>
where <img src="ltxpng/dft_2d61c25ed80bc482d02bc4c9a52daabcb3dc2a20.png" alt="$\mathbf{r}$"/> is a position vector, and <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> is a
so-called wave vector that will only have certain allowed values
defined by the size of the unit cell. Bloch's theorem sets the stage
for using planewaves as a basis set, because it suggests a planewave
character of the wave function. If the periodic function
<img src="ltxpng/dft_25fa86fd09dc94a56bd44312bfa84d24ea75b756.png" alt="$u_{n\mathbf{k}}(\mathbf{r})$"/> is also expanded in terms of planewaves
determined by wave vectors of the reciprocal lattice vectors,
<img src="ltxpng/dft_282e47ec9e84248c7d9776c5bdec191b7900c9b4.png" alt="$\mathbf{G}$"/>, then the wave function can be expressed completely in
terms of a sum of planewaves (<cite>payne1992:iterat</cite>):
</p>

<p>
<img src="ltxpng/dft_b8fa11c9e4c0a7ac9cfa2d9b90151062cc0f52c2.png" alt="\begin{equation}
\psi_i(\mathbf{r})=\sum_\mathbf{G} c_{i,\mathbf{k+G}} \exp(i\mathbf{(k+G)\cdot r}).
\end{equation}"/>
</p>

<p>
where <img src="ltxpng/dft_a94ded7cc767e0b1f18fe9e21fecca05824d6ede.png" alt="$c_{i,\mathbf{k+G}}$"/> are now coefficients that can be varied to
determine the lowest energy solution. This also converts Eq.
\eqref{eq:KS} from an integral equation to a set of algebraic
equations that can readily be solved using matrix algebra.
</p>
<p>
In aperiodic systems, such as systems with even one defect, or
randomly ordered alloys, there is no periodic unit cell. Instead one
must represent the portion of the system of interest in a supercell,
which is then subjected to the periodic boundary conditions so that a
planewave basis set can be used. It then becomes necessary to ensure
the supercell is large enough to avoid interactions between the
defects in neighboring supercells. The case of the randomly ordered
alloy is virtually hopeless as the energy of different configurations
will fluctuate statistically about an average value.  These systems
were not considered in this work, and for more detailed discussions
the reader is referred to Ref. (<cite>makov1995:period-bound-condit</cite>).
Once a supercell is chosen, however, Bloch's theorem can be applied to
the new artificially periodic system.
</p>
<p>
To get a perfect expansion, one needs an infinite number of
planewaves.  Luckily, the coefficients of the planewaves must go to
zero for high energy planewaves, otherwise the energy of the wave
function would go to infinity. This provides justification for
truncating the planewave basis set above a cutoff energy. Careful
testing of the effect of the cutoff energy on the total energy can be
done to determine a suitable cutoff energy. The cutoff energy required
to obtain a particular convergence precision is also element
dependent, shown in Table ref:ref:tab:pwcut. It can also vary with the
"softness" of the pseudopotential.  Thus, careful testing should be
done to ensure the desired level of convergence of properties in
different systems. Table ref:ref:tab:pwcut refers to convergence of
total energies. These energies are rarely considered directly, it is
usually differences in energy that are important. These tend to
converge with the planewave cutoff energy much more quickly than total
energies, due to cancellations of convergence errors.  In this work,
350 eV was found to be suitable for the H adsorption calculations, but a cutoff
energy of 450 eV was required for O adsorption calculations.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>Planewave cutoff energies (in eV) required for different convergence precisions for different elements. \label{tab:pwcut}</caption>
<colgroup><col class="left" /><col class="right" /><col class="right" />
</colgroup>
<tbody>
<tr><td class="left">Precision</td><td class="right">Low</td><td class="right">High</td></tr>
<tr><td class="left">Mo</td><td class="right">168</td><td class="right">293</td></tr>
<tr><td class="left">O</td><td class="right">300</td><td class="right">520</td></tr>
<tr><td class="left">O_sv</td><td class="right">1066</td><td class="right">1847</td></tr>
</tbody>
</table>


<p>
Bloch's theorem eliminates the need to calculate an infinite number of
wave functions, because there are only a finite number of electrons in
the unit (super) cell. However, there are still an infinite number of discrete
<img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> points that must be considered, and the energy of the
unit cell is calculated as an integral over these points.  It turns
out that wave functions at <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> points that are close together
are similar, thus an interpolation scheme can be used with a finite
number of <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> points. This also converts the integral used to
determine the energy into a sum over the <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> points, which
are suitably weighted to account for the finite number of them.  There
will be errors in the total energy associated with the finite number
of <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/>, but these can be reduced and tested for convergence
by using higher <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/>-point densities. An excellent discussion
of this for aperiodic systems can be found in Ref.
(<cite>makov1995:period-bound-condit</cite>).
</p>
<p>
The most common schemes for generating <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> points are the
Chadi-Cohen scheme (<cite>PhysRevB.8.5747</cite>), and the Monkhorst-Pack scheme
(<cite>PhysRevB.13.5188</cite>). The use of these <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> point setups
amounts to an expansion of the periodic function in reciprocal space,
which allows a straight-forward interpolation of the function between
the points that is more accurate than with other <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> point
generation schemes (<cite>PhysRevB.13.5188</cite>).
</p>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Pseudopotentials</h3>
<div class="outline-text-3" id="text-2-4">

<p>The core electrons of an atom are computationally expensive with
planewave basis sets because they are highly localized. This means
that a very large number of planewaves are required to expand their
wave functions. Furthermore, the contributions of the core electrons to
bonding compared to those of the valence electrons is usually
negligible. In fact, the primary role of the core electron wave
functions is to ensure proper orthogonality between the valence
electrons and core states.  Consequently, it is desirable to replace
the atomic potential due to the core electrons with a pseudopotential
that has the same effect on the valence electrons
(<cite>PhysRevB.43.1993</cite>). There are essentially two kinds of
pseudopotentials, norm-conserving soft pseudopotentials
(<cite>PhysRevB.43.1993</cite>) and Vanderbilt ultrasoft pseudopotentials
(<cite>PhysRevB.41.7892</cite>). In either case, the pseudopotential
function is generated from an all-electron calculation of an atom in
some reference state. In norm-conserving pseudopotentials, the charge
enclosed in the pseudopotential region is the same as that enclosed by
the same space in an all-electron calculation. In ultrasoft
pseudopotentials, this requirement is relaxed and charge augmentation
functions are used to make up the difference. As its name implies,
this allows a "softer" pseudopotential to be generated, which means
fewer planewaves are required to expand it.
</p>
<p>
The pseudopotentials are not unique, and calculated properties depend
on them. However, there are standard methods for ensuring the quality
and transferability (to different chemical environments) of the
pseudopotentials (<cite>PhysRevB.56.15629</cite>).
</p>


<div class="inlinetask"><b><span class="todo TODO">TODO</span> PAW description</b><br /></div>

<p>
VASP provides a database of PAW potentials (<cite>PhysRevB.50.17953,PhysRevB.59.1758</cite>).
</p>
</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> Fermi Temperature and band occupation numbers</h3>
<div class="outline-text-3" id="text-2-5">

<p>At absolute zero, the occupancies of the bands of a system are
well-defined step functions; all bands up to the Fermi level are
occupied, and all bands above the Fermi level are unoccupied.  There
is a particular difficulty in the calculation of the electronic
structures of metals compared to semiconductors and molecules. In
molecules and semiconductors, there is a clear energy gap between the
occupied states and unoccupied states. Thus, the occupancies are
insensitive to changes in the energy that occur during the
self-consistency cycles. In metals, however, the density of states is
continuous at the Fermi level, and there are typically a substantial
number of states that are close in energy to the Fermi level.
Consequently, small changes in the energy can dramatically change the
occupation numbers, resulting in instabilities that make it difficult
to converge to the occupation step function. A related problem is that
the Brillouin zone integral (which in practice is performed as a sum
over a finite number of <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> points) that defines the band
energy converges very slowly with the number of <img src="ltxpng/dft_ca2200966ea52397bb41a11ba51bf0f7e2c38189.png" alt="$\mathbf{k}$"/> points
due to the discontinuity in occupancies in a continuous distribution
of states for metals (<cite>gillan1989:calcul,Kresse199615</cite>).  The
difficulty arises because the temperature in most DFT calculations is
at absolute zero.  At higher temperatures, the DOS is smeared across
the Fermi level, resulting in a continuous occupation function over
the distribution of states. A finite-temperature version of DFT was
developed (<cite>PhysRev.137.A1441</cite>), which is the foundation on which one
solution to this problem is based. In this solution, the step function
is replaced by a smoothly varying function such as the Fermi-Dirac
function at a small, but non-zero temperature
(<cite>Kresse199615</cite>). The total energy is then extrapolated back
to absolute zero.
</p>
</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> Spin polarization and magnetism</h3>
<div class="outline-text-3" id="text-2-6">

<p>There are two final points that need to be discussed about these
calculations, spin polarization and dipole corrections. Spin
polarization is important for systems that contain net spin. For
example, iron, cobalt and nickel are magnetic because they have more
electrons with spin "up" than spin "down" (or vice versa).  Spin
polarization must also be considered in atoms and molecules with
unpaired electrons, such as hydrogen and oxygen atoms, oxygen
molecules and radicals. For example, there are two spin configurations
for an oxygen molecule, the singlet state with no unpaired electrons,
and the triplet state with two unpaired electrons. The oxygen triplet
state is lower in energy than the oxygen singlet state, and thus it
corresponds to the ground state for an oxygen atom. A classically
known problem involving spin polarization is the dissociation of a
hydrogen molecule. In this case, the molecule starts with no net spin,
but it dissociates into two atoms, each of which has an unpaired
electron.  See section 5.3.5 in Reference (<cite>koch2001</cite>) for more
details on this.
</p>

<p>
In VASP, spin polarization is not considered by default; it must be
turned on, and an initial guess for the magnetic moment of each atom
in the unit cell must be provided (typically about one Bohr-magneton
per unpaired electron). For Fe, Co, and Ni, the experimental values
are 2.22, 1.72, and 0.61 Bohr-magnetons, respectively (<cite>kittel</cite>)
and are usually good initial guesses. See Reference
(<cite>PhysRevB.56.15629</cite>) for a very thorough discussion of
the determination of the magnetic properties of these metals with
DFT. For a hydrogen atom, an initial guess of 1.0 Bohr-magnetons
(corresponding to one unpaired electron) is usually good. An oxygen
atom has two unpaired electrons, thus an initial guess of 2.0
Bohr-magnetons should be used.  The spin-polarized solution is
sensitive to the initial guess, and typically converges to the closest
solution. Thus, a magnetic initial guess usually must be provided to
get a magnetic solution.  Finally, unless an adsorbate is on a
magnetic metal surface, spin polarization typically does not need to
be considered, although the gas-phase reference state calculation may
need to be done with spin-polarization.
</p>
<p>
The downside of including spin polarization is that it essentially
doubles the calculation time.
</p>
</div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> <span class="todo TODO">TODO</span> Recommended reading</h3>
<div class="outline-text-3" id="text-2-7">

<p>This section needs cleaning up.
</p>
<p>
Original papers on DFT (<cite>PhysRev.136.B864,PhysRev.140.A1133</cite>)
</p>
<p>
Kohn's Nobel Lecture (<cite>RevModPhys.71.1253</cite>), Pople's Nobel Lecture (<cite>RevModPhys.71.1267</cite>)
</p>
<p>
(<cite>RevModPhys.60.601</cite>) Hoffman
</p>
<p>
PAW in GPAW (<cite>PhysRevB.71.035109</cite>)
</p>
<p>
All calculations were performed using VASP (<cite>Kresse199615,PhysRevB.54.11169,PhysRevB.49.14251,PhysRevB.47.558</cite>) with the projector augmented wave (PAW) potentials provided in VASP.
</p>

<p>
Monkhorst-Pack k-points (<cite>PhysRevB.13.5188</cite>)
</p>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Molecules</h2>
<div class="outline-text-2" id="text-3">

<p>In this chapter we consider how to construct models of molecules, how to manipulate them, and how to calculate many properties of molecules. For a nice comparison of VASP and Gaussian see (<cite>paier:234102</cite>).
</p>
</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> Defining and visualizing molecules</h3>
<div class="outline-text-3" id="text-3-1">

<p>We start by learning how to define a molecule and visualize it. We will begin with defining molecules from scratch, then reading molecules from data files, and finally using some built-in databases in <code>ase</code>.
</p>
</div>

<div id="outline-container-3-1-1" class="outline-4">
<h4 id="sec-3-1-1"><span class="section-number-4">3.1.1</span> From scratch</h4>
<div class="outline-text-4" id="text-3-1-1">

<p>When there is no data file for the molecule you want, or no database to get it from, you have to define your atoms geometry by hand. Here is how that is done for a CO molecule (Figure ref:ref:fig:co-origin). We must define the type and position of each atom, and the unit cell the atoms are in.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">define an Atoms object</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'C'</span>,[0., 0.,0.]),
               Atom(<span style="color: #00cd00;">'O'</span>,[1.1,0.,0.])],
               cell=(10,10,10))

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'V = {0:1.0f} Angstrom^3'</span>.format(atoms.get_volume())

write(<span style="color: #00cd00;">'images/simple-cubic-cell.png'</span>, atoms, show_unit_cell=2)
</pre>


<pre class="example">
V = 1000 Ang^3
</pre>



<div class="figure">
<p><img src="./images/simple-cubic-cell.png"  alt="./images/simple-cubic-cell.png" /></p>
<p>Image of a CO molecule with the C at the origin. \label{fig:co-origin}</p>
</div>

<p>
There are two inconvenient features of the simple cubic cell:
</p>
<ol>
<li>Since the CO molecule is at the corner, its electron density is spread over the 8 corners of the box, which is not convenient for visualization later (see <a href="#sec-3-3-2">Visualizing electron density</a>).

</li>
<li>Due to the geometry of the cube, you need fairly large cubes to make sure the electron density of the molecule does not overlap with that of its images. Electron-electron interactions are repulsive, and the overlap makes the energy increase significantly. Here, the CO molecule has 6 images due to periodic boundary conditions that are 10 &Aring; away. The volume of the unit cell is 1000 &Aring;<img src="ltxpng/dft_8f09efb231ab0e51a259554e765dfb1924bbccd8.png" alt="$^3$"/>.
</li>
</ol>


<p>
The first problem is easily solved by centering the atoms in the unit cell. The second problem can be solved by using a face-centered cubic lattice, which is the lattice with the closest packing. We show the results of the centering in Figure ref:ref:fig:co-fcc, where we have guessed values for <img src="ltxpng/dft_2e65d1067ffe1c51ac32b60e1df54d3d95d89971.png" alt="$b$"/> until the CO molecules are on average 10 &Aring; apart. Note the final volume is only about 715 &Aring;<img src="ltxpng/dft_63edb7509bad302a5a636643519f31a5a7e434b2.png" alt="$^3$"/>, which is smaller than the cube. This will result in less computational time to compute properties.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

b = 7.1
atoms = Atoms([Atom(<span style="color: #00cd00;">'C'</span>,[0., 0.,0.]),
               Atom(<span style="color: #00cd00;">'O'</span>,[1.1,0.,0.])],
               cell=[[b, b, 0.],
                     [b, 0., b],
                     [0., b, b]])
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'V = {0:1.0f} Ang^3'</span>.format(atoms.get_volume())

atoms.center() <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">translate atoms to center of unit cell</span>
write(<span style="color: #00cd00;">'images/fcc-cell.png'</span>, atoms, show_unit_cell=2)
</pre>


<pre class="example">
V = 716 Ang^3
</pre>



<div class="figure">
<p><img src="./images/fcc-cell.png"  alt="./images/fcc-cell.png" /></p>
<p>CO in a face-centered cubic unit cell. \label{fig:co-fcc}</p>
</div>

<p>
At this point you might ask, "How do you know the distance to the neighboring image?" The <code>ag</code> viewer lets you compute this graphically, but we can use code to determine this too. All we have to do is figure out the length of each lattice vector, because these are what separate the atoms in the images. We use the <TT>numpy</TT> module to compute the distance of a vector as the square root of the sum of squared elements.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

b = 7.1
atoms = Atoms([Atom(<span style="color: #00cd00;">'C'</span>,[0., 0.,0.]),
              Atom(<span style="color: #00cd00;">'O'</span>,[1.1,0.,0.])],
              cell=[[b, b, 0.],
                    [b, 0., b],
                    [0., b, b]])

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get unit cell vectors and their lengths</span>
(a1, a2, a3) = atoms.get_cell()
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|a1| = {0:1.2f} Ang'</span>.format(np.sum(a1**2)**0.5)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|a2| = {0:1.2f} Ang'</span>.format(np.linalg.norm(a2))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|a3| = {0:1.2f} Ang'</span>.format(np.sum(a3**2)**0.5)
</pre>


<pre class="example">
|a1| = 10.04 Ang
|a2| = 10.04 Ang
|a3| = 10.04 Ang
</pre>


<p>
<i>&lt;elisp:(progn (setq org-drill-scope '("study-guides/molecules-drill.org")) (org-drill))&gt;</i>
</p>
</div>

</div>

<div id="outline-container-3-1-2" class="outline-4">
<h4 id="sec-3-1-2"><span class="section-number-4">3.1.2</span> Reading other data formats into a calculation</h4>
<div class="outline-text-4" id="text-3-1-2">


<p>
<TT>ase.io.read</TT> supports many different file formats:
</p>


<pre class="example">    Known formats:

    =========================  ===========
    format                     short name
    =========================  ===========
    GPAW restart-file          gpw
    Dacapo netCDF output file  dacapo
    Old ASE netCDF trajectory  nc
    Virtual Nano Lab file      vnl
    ASE pickle trajectory      traj
    ASE bundle trajectory      bundle
    GPAW text output           gpaw-text
    CUBE file                  cube
    XCrySDen Structure File    xsf
    Dacapo text output         dacapo-text
    XYZ-file                   xyz
    VASP POSCAR/CONTCAR file   vasp
    VASP OUTCAR file           vasp_out
    SIESTA STRUCT file         struct_out
    ABINIT input file          abinit
    V_Sim ascii file           v_sim
    Protein Data Bank          pdb
    CIF-file                   cif
    FHI-aims geometry file     aims
    FHI-aims output file       aims_out
    VTK XML Image Data         vti
    VTK XML Structured Grid    vts
    VTK XML Unstructured Grid  vtu
    TURBOMOLE coord file       tmol
    TURBOMOLE gradient file    tmol-gradient
    exciting input             exi
    AtomEye configuration      cfg
    WIEN2k structure file      struct
    DftbPlus input file        dftb
    CASTEP geom file           cell
    CASTEP output file         castep
    CASTEP trajectory file     geom
    ETSF format                etsf.nc
    DFTBPlus GEN format        gen
    CMR db/cmr-file            db
    CMR db/cmr-file            cmr
    LAMMPS dump file           lammps
    Gromacs coordinates        gro
    =========================  ===========
</pre>


<p>
You can read XYZ file format to create <TT>ase.Atoms</TT> objects.  Here is
what an XYZ file format might look like:
</p>



<pre class="example">14

C       0.000000000000000      0.000000000000000      0.376949000000000
H       0.000000000000000      0.000000000000000      1.475269000000000
C       0.000000000000000      1.450290000000000     -0.096234000000000
H       0.000000000000000      1.493997000000000     -1.190847000000000
H      -0.885482000000000      1.984695000000000      0.261297000000000
H       0.885482000000000      1.984695000000000      0.261297000000000
C       1.255988000000000     -0.725145000000000     -0.096234000000000
H       1.293839000000000     -0.746998000000000     -1.190847000000000
H       2.161537000000000     -0.225498000000000      0.261297000000000
H       1.276055000000000     -1.759198000000000      0.261297000000000
C      -1.255988000000000     -0.725145000000000     -0.096234000000000
H      -1.293839000000000     -0.746998000000000     -1.190847000000000
H      -1.276055000000000     -1.759198000000000      0.261297000000000
H      -2.161537000000000     -0.225498000000000      0.261297000000000

</pre>


<p>
The first line is the number of atoms in the file. The second line is
often a comment. What follows is one line per atom with the symbol and
Cartesian coordinates in &Aring;. Note that the XYZ format does not have
unit cell information in it, so you will have to figure out a way to
provide it. In this example, we center the atoms in a box with vacuum
on all sides (Figure ref:ref:fig:isobutane).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> read,write
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

atoms = read(<span style="color: #00cd00;">'molecules/isobutane.xyz'</span>)
atoms.center(vacuum=5)
write(<span style="color: #00cd00;">'images/isobutane-xyz.png'</span>, atoms, show_unit_cell=2)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/isobutane-xyz.png"  alt="./images/isobutane-xyz.png" /></p>
<p>An isobutane molecule read in from an XYZ formatted data file. \label{fig:isobutane}</p>
</div>
</div>

</div>

<div id="outline-container-3-1-3" class="outline-4">
<h4 id="sec-3-1-3"><span class="section-number-4">3.1.3</span> Predefined molecules</h4>
<div class="outline-text-4" id="text-3-1-3">


<p>
<TT>ase</TT> defines a number of molecular geometries in the
<TT>ase.data.molecules</TT> database.  For example, the database includes
the molecules in the G2/97 database (<cite>curtiss:1063</cite>). This database
contains a broad set of atoms and molecules for which good
experimental data exists, making them useful for benchmarking studies.
See <a href="http://www.cse.anl.gov/OldCHMwebsiteContent/compmat/comptherm.htm">this site</a> for the original files.
</p>
<p>
The coordinates for the atoms in the database are <a href="http://en.wikipedia.org/wiki/Mller-Plesset_perturbation_theory">MP2</a>(full)/<a href="http://en.wikipedia.org/wiki/Basis_set_(chemistry)">6-31G(d)</a>
optimized geometries. Here is a list of all the species available in
<TT>ase.data.g2</TT>. You may be interested in reading about some of the other databases in <TT>ase.data</TT> too.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.data <span style="color: #cd0000; font-weight: bold;">import</span> g2
keys = g2.data.keys()
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">print in 3 columns</span>
<span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(len(keys)/3):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:25s}{1:25s}{2:25s}'</span>.format(*<span style="color: #cd0000; font-weight: bold;">tuple</span>(keys[i*3:i*3+3]))
</pre>



<pre class="example">isobutene                CH3CH2OH                 CH3COOH
COF2                     CH3NO2                   CF3CN
CH3OH                    CCH                      CH3CH2NH2
PH3                      Si2H6                    O3
O2                       BCl3                     CH2_s1A1d
Be                       H2CCl2                   C3H9C
C3H9N                    CH3CH2OCH3               BF3
CH3                      CH4                      S2
C2H6CHOH                 SiH2_s1A1d               H3CNH2
CH3O                     H                        BeH
P                        C3H4_C3v                 C2F4
OH                       methylenecyclopropane    F2O
SiCl4                    HCF3                     HCCl3
C3H7                     CH3CH2O                  AlF3
CH2NHCH2                 SiH2_s3B1d               H2CF2
SiF4                     H2CCO                    PH2
OCS                      HF                       NO2
SH2                      C3H4_C2v                 H2O2
CH3CH2Cl                 isobutane                CH3COF
HCOOH                    CH3ONO                   C5H8
2-butyne                 SH                       NF3
HOCl                     CS2                      P2
C                        CH3S                     O
C4H4S                    S                        C3H7Cl
H2CCHCl                  C2H6                     CH3CHO
C2H4                     HCN                      C2H2
C2Cl4                    bicyclobutane            H2
C6H6                     N2H4                     C4H4NH
H2CCHCN                  H2CCHF                   cyclobutane
HCl                      CH3OCH3                  Li2
Na                       CH3SiH3                  NaCl
CH3CH2SH                 OCHCHO                   SiH4
C2H5                     SiH3                     NH
ClO                      AlCl3                    CCl4
NO                       C2H3                     ClF
HCO                      CH3CONH2                 CH2SCH2
CH3COCH3                 C3H4_D2d                 CH
CO                       CN                       F
CH3COCl                  N                        CH3Cl
Si                       C3H8                     CS
N2                       Cl2                      NCCN
F2                       CO2                      Cl
CH2OCH2                  H2O                      CH3CO
SO                       HCOOCH3                  butadiene
ClF3                     Li                       PF3
B                        CH3SH                    CF4
C3H6_Cs                  C2H6NH                   N2O
LiF                      H2COH                    cyclobutene
LiH                      SiO                      Si2
C2H6SO                   C5H5N                    trans-butane
Na2                      C4H4O                    SO2
NH3                      NH2                      CH2_s3B1d
ClNO                     C3H6_D3h                 Al
CH3SCH3                  H2CO                     CH3CN
</pre>


<p>
Some other databases include the <TT>ase.data.s22</TT> for weakly interacting dimers and complexes, and <TT>ase.data.extra_molecules</TT> which has a few extras like biphenyl and C60.
</p>
<p>
Here is an example of getting the geometry of an acetonitrile molecule and writing an image to a file. Note that the default unit cell is a <img src="ltxpng/dft_bdf32bd9fb8e90f77672ecf4c3664a2991c79dec.png" alt="$1 \mathrm{\AA} \times 1 \mathrm{\AA} \times 1 \mathrm{\AA}$"/> cubic cell. That is too small to use if your calculator uses periodic boundary conditions. We center the atoms in the unit cell and add vacuum on each side. We will add 6 &Aring; of vacuum on each side. In the write command we use the option <code>show_unit_cell</code> =2 to draw the unit cell boundaries. See Figure ref:ref:fig:ch3cn.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

atoms = molecule(<span style="color: #00cd00;">'CH3CN'</span>)

atoms.center(vacuum=6)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'unit cell'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'---------'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_cell()

write(<span style="color: #00cd00;">'images/ch3cn.png'</span>, atoms, show_unit_cell=2)
</pre>


<pre class="example">
unit cell
---------
[[ 13.775328   0.         0.      ]
 [  0.        13.537479   0.      ]
 [  0.         0.        15.014576]]
</pre>



<div class="figure">
<p><img src="./images/ch3cn.png"  alt="./images/ch3cn.png" /></p>
<p>A CH<sub>3</sub>CN molecule in a box. \label{fig:ch3cn}</p>
</div>


<p>
It is possible to rotate the atoms with <TT>ase.io.write</TT> if you wanted to see pictures from another angle. In the next example we rotate 45 degrees about the <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/>-axis, then 45 degrees about the <img src="ltxpng/dft_7caba42fa0145427d12beda30808356e5038ef71.png" alt="$y$"/>-axis. Note that this only affects the image, not the actual coordinates. See Figure ref:ref:fig:ch3cn-rot.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

atoms = molecule(<span style="color: #00cd00;">'CH3CN'</span>)

atoms.center(vacuum=6)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'unit cell'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'---------'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_cell()

write(<span style="color: #00cd00;">'images/ch3cn-rotated.png'</span>, atoms,
      show_unit_cell=2,rotation=<span style="color: #00cd00;">'45x,45y,0z'</span>)
</pre>


<pre class="example">
unit cell
---------
[[ 13.775328   0.         0.      ]
 [  0.        13.537479   0.      ]
 [  0.         0.        15.014576]]
</pre>



<div class="figure">
<p><img src="./images/ch3cn-rotated.png"  alt="./images/ch3cn-rotated.png" /></p>
<p>The rotated version of CH<sub>3</sub>CN. \label{fig:ch3cn-rot}</p>
</div>

<p>
If you actually want to rotate the coordinates, there is a nice way to do that too, with the <TT>ase.Atoms.rotate</TT> method. Actually there are some subtleties in rotation. One rotates the molecule an angle (in radians) around a vector, but you have to choose whether the center of mass should be fixed or not. You also must decide whether or not the unit cell should be rotated. In the next example you can see the coordinates have changed due to the rotations. Note that the write function uses the rotation angle in degrees, while the rotate function uses radians.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> numpy <span style="color: #cd0000; font-weight: bold;">import</span> pi

atoms = molecule(<span style="color: #00cd00;">'CH3CN'</span>)
atoms.center(vacuum=6)
p1 = atoms.get_positions()

atoms.rotate(<span style="color: #00cd00;">'x'</span>, pi/4, center=<span style="color: #00cd00;">'COM'</span>, rotate_cell=<span style="color: #cd0000; font-weight: bold;">False</span>)
atoms.rotate(<span style="color: #00cd00;">'y'</span>, pi/4, center=<span style="color: #00cd00;">'COM'</span>, rotate_cell=<span style="color: #cd0000; font-weight: bold;">False</span>)

write(<span style="color: #00cd00;">'images/ch3cn-rotated-2.png'</span>, atoms, show_unit_cell=2)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'difference in positions after rotating'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'atom    difference vector'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'--------------------------------------'</span>
p2 = atoms.get_positions()

diff = p2 - p1
<span style="color: #cd0000; font-weight: bold;">for</span> i, d <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(diff):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0} {1}'</span>.format(i, d)
</pre>


<pre class="example">
difference in positions after rotating
atom    difference vector
--------------------------------------
0 [-0.65009456  0.91937255  0.65009456]
1 [ 0.08030744 -0.11357187 -0.08030744]
2 [ 0.66947344 -0.94677841 -0.66947344]
3 [-0.32532156  0.88463727  1.35030756]
4 [-1.35405183  1.33495444 -0.04610517]
5 [-0.8340703   1.33495444  1.2092413 ]
</pre>



<div class="figure">
<p><img src="./images/ch3cn-rotated-2.png"  alt="./images/ch3cn-rotated-2.png" /></p>
<p>Rotated CH<sub>3</sub>CN molecule</p>
</div>

<p>
Note in this last case the unit cell is oriented differently than the previous example, since we chose not to rotate the unit cell.
</p>
</div>

</div>

<div id="outline-container-3-1-4" class="outline-4">
<h4 id="sec-3-1-4"><span class="section-number-4">3.1.4</span> Combining Atoms objects</h4>
<div class="outline-text-4" id="text-3-1-4">

<p>It is frequently useful to combine two <code>Atoms</code> objects, e.g. for computing reaction barriers, or other types of interactions. In <code>ase</code>, we simply add two <code>Atoms</code> objects together. Here is an example of getting an ammonia and oxygen molecule in the same unit cell. See Figure ref:ref:fig:combined-atoms. We set the <code>Atoms</code> about three &Aring; apart using the <TT>ase.Atoms.translate</TT> function.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

atoms1 = molecule(<span style="color: #00cd00;">'NH3'</span>)

atoms2 = molecule(<span style="color: #00cd00;">'O2'</span>)
atoms2.translate([3, 0, 0])

bothatoms = atoms1 + atoms2
bothatoms.center(5)

write(<span style="color: #00cd00;">'images/bothatoms.png'</span>, bothatoms, show_unit_cell=2, rotation=<span style="color: #00cd00;">'90x'</span>)
</pre>




<div class="figure">
<p><img src="./images/bothatoms.png"  alt="./images/bothatoms.png" /></p>
<p>Image featuring ammonia and oxygen molecule in one unit cell. \label{fig:combined-atoms}</p>
</div>

</div>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Simple properties</h3>
<div class="outline-text-3" id="text-3-2">

<p>Simple properties do not require a DFT calculation. They are typically only functions of the atom types and geometries.
</p>
</div>

<div id="outline-container-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> Getting cartesian positions</h4>
<div class="outline-text-4" id="text-3-2-1">

<p>If you want the <img src="ltxpng/dft_9aac708762d70746720cd1e43eeddef178fd97bc.png" alt="$(x,y,z)$"/> coordinates of the atoms, use the <TT>ase.Atoms.get_positions</TT>. If you are interested in the fractional coordinates, use <TT>ase.Atoms.get_scaled_positions</TT>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

atoms = molecule(<span style="color: #00cd00;">'C6H6'</span>)  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">benzene</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">access properties on each atom</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">' #  sym   p_x     p_y     p_z'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'------------------------------'</span>
<span style="color: #cd0000; font-weight: bold;">for</span> i, atom <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(atoms):
  <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:3d}{1:^4s}{2:-8.2f}{3:-8.2f}{4:-8.2f}'</span>.format(i,
                                                          atom.symbol,
                                                          atom.x,
                                                          atom.y,
                                                          atom.z)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get all properties in arrays</span>
sym = atoms.get_chemical_symbols()
pos = atoms.get_positions()
num = atoms.get_atomic_numbers()

atom_indices = <span style="color: #cd0000; font-weight: bold;">range</span>(len(atoms))

<span style="color: #cd0000; font-weight: bold;">print</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'  # sym    at#    p_x     p_y     p_z'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'-------------------------------------'</span>
<span style="color: #cd0000; font-weight: bold;">for</span> i, s, n, p <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">zip</span>(atom_indices, sym, num, pos):
  px, py, pz = p
  <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:3d}{1:&gt;3s}{2:8d}{3:-8.2f}{4:-8.2f}{5:-8.2f}'</span>.format(i, s, n,
                                                                px, py, pz)
</pre>



<pre class="example"> #  sym   p_x     p_y     p_z
------------------------------
  0 C      0.00    1.40    0.00
  1 C      1.21    0.70    0.00
  2 C      1.21   -0.70    0.00
  3 C      0.00   -1.40    0.00
  4 C     -1.21   -0.70    0.00
  5 C     -1.21    0.70    0.00
  6 H      0.00    2.48    0.00
  7 H      2.15    1.24    0.00
  8 H      2.15   -1.24    0.00
  9 H      0.00   -2.48    0.00
 10 H     -2.15   -1.24    0.00
 11 H     -2.15    1.24    0.00

  # sym    at#    p_x     p_y     p_z
-------------------------------------
  0  C       6    0.00    1.40    0.00
  1  C       6    1.21    0.70    0.00
  2  C       6    1.21   -0.70    0.00
  3  C       6    0.00   -1.40    0.00
  4  C       6   -1.21   -0.70    0.00
  5  C       6   -1.21    0.70    0.00
  6  H       1    0.00    2.48    0.00
  7  H       1    2.15    1.24    0.00
  8  H       1    2.15   -1.24    0.00
  9  H       1    0.00   -2.48    0.00
 10  H       1   -2.15   -1.24    0.00
 11  H       1   -2.15    1.24    0.00
</pre>


</div>

</div>

<div id="outline-container-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> Molecular weight and molecular formula</h4>
<div class="outline-text-4" id="text-3-2-2">


<p>
We can quickly compute the molecular weight of a molecule with this recipe. We use <TT>ase.Atoms.get_masses</TT> to get an array of the atomic masses of each atom in the <code>Atoms</code> object, and then just sum them up.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule

atoms = molecule(<span style="color: #00cd00;">'C6H6'</span>)
masses = atoms.get_masses()

molecular_weight = masses.sum()
molecular_formula = atoms.get_chemical_symbols(reduce=<span style="color: #cd0000; font-weight: bold;">True</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The molecular weight of {0} is {1:1.2f} gm/mol'</span>.format(molecular_formula,
                                                              molecular_weight)
</pre>


<pre class="example">
The molecular weight of C6H6 is 78.11 gm/mol
</pre>


<p>
Note that the argument <code>reduce=True</code> for <TT>ase.Atoms.get_chemical_symbols</TT> collects all the symbols to provide a molecular formula.
</p>
</div>

</div>

<div id="outline-container-3-2-3" class="outline-4">
<h4 id="sec-3-2-3"><span class="section-number-4">3.2.3</span> Center of mass</h4>
<div class="outline-text-4" id="text-3-2-3">


<p>
The center of mass (COM) is defined as:
</p>
<p>
COM = <img src="ltxpng/dft_5484470fc8dd6800d0a6b7f88ce78c8859e41efd.png" alt="$\frac{\sum m_i \cdot r_i}{\sum m_i}$"/>
</p>
<p>
The center of mass is essentially the average position of the atoms, weighted by the mass of each atom. Here is an example of getting the center of mass from an <code>Atoms</code> object using <TT>ase.Atoms.get_center_of_mass</TT>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.structure <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">ammonia</span>
atoms = molecule(<span style="color: #00cd00;">'NH3'</span>)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'COM1 = {0}'</span>.format(atoms.get_center_of_mass())  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">cartesian coordinates</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">compute the center of mass by hand</span>
pos = atoms.positions
masses = atoms.get_masses()

COM = np.array([0., 0., 0.])
<span style="color: #cd0000; font-weight: bold;">for</span> m,p <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">zip</span>(masses, pos):
    COM += m*p
COM /= masses.sum()

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'COM2 = {0}'</span>.format(COM)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">one-line linear algebra definition of COM</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'COM3 = {0}'</span>.format(np.dot(masses, pos)/np.sum(masses))
</pre>


<pre class="example">
COM1 = [  0.00000000e+00   5.91843349e-08   4.75457009e-02]
COM2 = [  0.00000000e+00   5.91843349e-08   4.75457009e-02]
COM3 = [  0.00000000e+00   5.91843349e-08   4.75457009e-02]
</pre>


<p>
You can see see that these centers of mass, which are calculated by different methods, are the same.
</p>
</div>

</div>

<div id="outline-container-3-2-4" class="outline-4">
<h4 id="sec-3-2-4"><span class="section-number-4">3.2.4</span> Moments of inertia</h4>
<div class="outline-text-4" id="text-3-2-4">


<p>
The <a href="http://en.wikipedia.org/wiki/Moment_of_inertia">moment of inertia</a> is a measure of resistance to changes in rotation. It is defined by <img src="ltxpng/dft_a8a3ec0667c4318804395fe96db0a424bc201ee2.png" alt="$I = \sum_{i=1}^N m_i r_i^2$"/> where <img src="ltxpng/dft_9d474b5512b1af91bcb109d35ca4989ae0cd7bff.png" alt="$r_i$"/> is the distance to an axis of rotation. There are typically three moments of inertia, although some may be zero depending on symmetry, and others may be degenerate. There is a convenient function to get the  moments of inertia: <TT>ase.Atoms.get_moments_of_inertia</TT>. Here are several examples of molecules with different types of symmetry.:
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.structure <span style="color: #cd0000; font-weight: bold;">import</span> molecule

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'linear rotors: I = [0 Ia Ia]'</span>
atoms = molecule(<span style="color: #00cd00;">'CO2'</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'  CO2 moments of inertia: '</span>,atoms.get_moments_of_inertia()
<span style="color: #cd0000; font-weight: bold;">print</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'symmetric rotors (Ia = Ib) &lt; Ic'</span>
atoms = molecule(<span style="color: #00cd00;">'NH3'</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'  NH3 moments of inertia: '</span> ,atoms.get_moments_of_inertia()

atoms = molecule(<span style="color: #00cd00;">'C6H6'</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'  C6H6 moments of inertia:'</span> ,atoms.get_moments_of_inertia()
<span style="color: #cd0000; font-weight: bold;">print</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'symmetric rotors Ia &lt; (Ib = Ic)'</span>
atoms = molecule(<span style="color: #00cd00;">'CH3Cl'</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'CH3Cl moments of inertia: '</span>,atoms.get_moments_of_inertia()
<span style="color: #cd0000; font-weight: bold;">print</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'spherical rotors Ia = Ib = Ic'</span>
atoms = molecule(<span style="color: #00cd00;">'CH4'</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'  CH4 moments of inertia: '</span> ,atoms.get_moments_of_inertia()
<span style="color: #cd0000; font-weight: bold;">print</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'unsymmetric rotors Ia != Ib != Ic'</span>
atoms = molecule(<span style="color: #00cd00;">'C3H7Cl'</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'  C3H7Cl moments of inertia: '</span> ,atoms.get_moments_of_inertia()
</pre>



<pre class="example">linear rotors: I = [0 Ia Ia]
  CO2 moments of inertia:  [  0.          44.45384271  44.45384271]

symmetric rotors (Ia = Ib) &lt; Ic
  NH3 moments of inertia:  [ 1.71012426  1.71012548  2.67031768]
  C6H6 moments of inertia: [  88.77914641   88.77916799  177.5583144 ]

symmetric rotors Ia &lt; (Ib = Ic)
CH3Cl moments of inertia:  [  3.20372189  37.97009644  37.97009837]

spherical rotors Ia = Ib = Ic
  CH4 moments of inertia:  [ 3.19145621  3.19145621  3.19145621]

unsymmetric rotors Ia != Ib != Ic
  C3H7Cl moments of inertia:  [  19.41351508  213.18961963  223.16255537]
</pre>


<p>
If you want to know the principle axes of rotation, we simply pass <code>vectors=True</code> to the function, and it returns the moments of inertia and the principle axes.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.structure <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

atoms = molecule(<span style="color: #00cd00;">'CH3Cl'</span>)
moments, axes = atoms.get_moments_of_inertia(vectors=<span style="color: #cd0000; font-weight: bold;">True</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Moments = {0}'</span>.format(moments)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'axes = {0}'</span>.format(axes)
</pre>


<pre class="example">
Moments = [  3.20372189  37.97009644  37.97009837]
axes = [[ 0.  0.  1.]
 [ 0.  1.  0.]
 [ 1.  0.  0.]]
</pre>


<p>
This shows the first moment is about the z-axis, the second moment is about the y-axis, and the third moment is about the x-axis.
</p>
</div>

</div>

<div id="outline-container-3-2-5" class="outline-4">
<h4 id="sec-3-2-5"><span class="section-number-4">3.2.5</span> Computing bond lengths and angles</h4>
<div class="outline-text-4" id="text-3-2-5">

<p>A typical question we might ask is, "What is the structure of a molecule?" In other words, what are the bond lengths, angles between bonds, and similar properties. The Atoms object contains an <TT>ase.Atoms.get_distance</TT> method to make this easy. To calculate the distance between two atoms, you have to specify their indices, remembering that the index starts at 0.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.structure <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">ammonia</span>
atoms = molecule(<span style="color: #00cd00;">'NH3'</span>)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'atom symbol'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'==========='</span>
<span style="color: #cd0000; font-weight: bold;">for</span> i, atom <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(atoms):
  <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:2d} {1:3s}'</span> .format(i,atom.symbol)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">N-H bond length</span>
s = <span style="color: #00cd00;">'The N-H distance is {0:1.3f} angstroms'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> s.format(atoms.get_distance(0,1))
</pre>


<pre class="example">
atom symbol
===========
 0   N
 1   H
 2   H
 3   H
The N-H distance is 1.017 angstroms
</pre>


<p>
Bond angles are a little trickier. If we had vectors describing the directions between two atoms, we could use some simple trigonometry to compute the angle between the vectors: <img src="ltxpng/dft_0ca250e0327e1bcbbf8af438801c36a485853184.png" alt="$\vec{a} \cdot \vec{b} = |\vec{a}||\vec{b}| \cos(\theta)$"/>.  So we can calculate the angle as <img src="ltxpng/dft_67ebd51de50c41ce841f24cf1b22e926ba48cca0.png" alt="$\theta = \arccos\left(\frac{\vec{a} \cdot \vec{b}}{|\vec{a}||\vec{b}|}\right)$"/>, we just have to define our two vectors <img src="ltxpng/dft_f0f3c0dc2a9262c67de4c0bca7a4fcc667f5ba0d.png" alt="$\vec{a}$"/> and <img src="ltxpng/dft_4e545c903aef50e9562d11c53793ebde1a1779ba.png" alt="$\vec{b}$"/>. We compute these vectors as the difference in positions of two atoms. For example, here we compute the angle H-N-H in an ammonia molecule. This is the angle between N-H<img src="ltxpng/dft_7bd2cafdb5654b1b9971fc9827c9035656d837ca.png" alt="$_1$"/> and N-H<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/>. In the next example, we utilize functions in <TT>numpy</TT> to perform the calculations, specifically the <TT>numpy.arccos</TT> function, the <TT>numpy.dot</TT> function, and <TT>numpy.linalg.norm</TT> functions.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.structure <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">ammonia</span>
atoms = molecule(<span style="color: #00cd00;">'NH3'</span>)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'atom symbol'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'==========='</span>
<span style="color: #cd0000; font-weight: bold;">for</span> i, atom <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(atoms):
  <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:2d} {1:3s}'</span>.format(i,atom.symbol)

a = atoms.positions[0] - atoms.positions[1]
b = atoms.positions[0] - atoms.positions[2]

<span style="color: #cd0000; font-weight: bold;">from</span> numpy <span style="color: #cd0000; font-weight: bold;">import</span> arccos, dot, pi
<span style="color: #cd0000; font-weight: bold;">from</span> numpy.linalg <span style="color: #cd0000; font-weight: bold;">import</span> norm

theta_rad = arccos(dot(a,b)/(norm(a)*norm(b))) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">in radians</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'theta = {0:1.1f} degrees'</span>.format(theta_rad*180./pi)
</pre>


<pre class="example">
atom symbol
===========
 0   N
 1   H
 2   H
 3   H
theta = 106.3 degrees
</pre>



<div class="figure">
<p><img src="./images/NH3-vectors.png"  alt="./images/NH3-vectors.png" /></p>
<p>Schematic of the vectors defining the H-N-H angle.</p>
</div>

<p>
Alternatively you could use <TT>ase.Atoms.get_angle</TT>. Note we want the angle between atoms with indices [1, 0, 2] to get the H-N-H angle.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> numpy <span style="color: #cd0000; font-weight: bold;">import</span> pi
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">ammonia</span>
atoms = molecule(<span style="color: #00cd00;">'NH3'</span>)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'theta = {0} degrees'</span>.format(atoms.get_angle([1,0,2])*180./pi)
</pre>


<pre class="example">
theta = 106.334624232 degrees
</pre>



</div>

<div id="outline-container-3-2-5-1" class="outline-5">
<h5 id="sec-3-2-5-1"><span class="section-number-5">3.2.5.1</span> Dihedral angles</h5>
<div class="outline-text-5" id="text-3-2-5-1">

<p>There is support in ase for computing <a href="http://en.wikipedia.org/wiki/Dihedral_angle">dihedral angles</a>. Let us illustrate that for ethane. We will compute the dihedral angle between atoms 5, 1, 0, and 4. That is a H-C-C-H dihedral angle, and one can visually see (although not here) that these atoms have a dihedral angle of 60<sup>&circ;</sup> (Figure ref:ref:fig:ethane-dihedral).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">calculate an ethane dihedral angle</span>
<span style="color: #cd0000; font-weight: bold;">from</span> ase.structure <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

atoms = molecule(<span style="color: #00cd00;">'C2H6'</span>)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'atom symbol'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'==========='</span>
<span style="color: #cd0000; font-weight: bold;">for</span> i, atom <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(atoms):
  <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:2d} {1:3s}'</span>.format(i,atom.symbol)

da = atoms.get_dihedral([5,1,0,4])*180./np.pi
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'dihedral angle = {0:1.2f} degrees'</span>.format(da)
</pre>



<pre class="example">atom symbol
===========
 0   C
 1   C
 2   H
 3   H
 4   H
 5   H
 6   H
 7   H
dihedral angle = 60.00 degrees
</pre>



<div class="figure">
<p><img src="./images/ethane-dihedral.png"  alt="./images/ethane-dihedral.png" /></p>
<p>Schematic of the calculated ethane dihedral angle. \label{fig:ethane-dihedral}</p>
</div>
<p>
In this section we cover properties that require simple calculations, but not DFT calculations, to compute.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Simple properties that require single computations</h3>
<div class="outline-text-3" id="text-3-3">

<p>There are many properties that only require a single DFT calculation to obtain the energy, forces, density of states, electron denisty and electrostatic potential. This section describes some of these calculations and their analysis.
</p>
</div>

<div id="outline-container-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> Energy and forces</h4>
<div class="outline-text-4" id="text-3-3-1">

<p>Two of the most important quantities we are interested in are the total
energy and the forces on the atoms. To get these quantities, we have
to define a calculator and attach it to an <TT>ase.Atoms</TT> object so
that <code>ase</code> knows how to get the data. After defining the calculator a
DFT calculation must be run.
</p>
<p>
Here is an example of getting the energy and forces from a CO
molecule. The forces in this case are very high, indicating that this
geometry is not close to the ground state geometry. Note that the
forces are only along the <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/>-axis, which is along the molecular axis. We will see how to minimize this force in <a href="#sec-3-4-1">Manual determination</a> and <a href="#sec-3-4-2">Automatic geometry optimization with VASP</a>.
</p>

<div class="note">
<p>This is your first DFT calculation in the book! See <a href=http://cms.mpi.univie.ac.at/wiki/index.php/ISMEAR>ISMEAR</a>, <a href=http://cms.mpi.univie.ac.at/wiki/index.php/SIGMA>SIGMA</a>, <a href=http://cms.mpi.univie.ac.at/wiki/index.php/NBANDS>NBANDS</a>, and <a href=http://cms.mpi.univie.ac.at/wiki/index.php/ENCUT>ENCUT</a> to learn more about these VASP keywords.
</p>
</div>




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
np.set_printoptions(precision=3, suppress=<span style="color: #cd0000; font-weight: bold;">True</span>)

co = Atoms([Atom(<span style="color: #00cd00;">'C'</span>,[0,   0, 0]),
            Atom(<span style="color: #00cd00;">'O'</span>,[1.2, 0, 0])],
            cell=(6., 6., 6.))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/simple-co'</span>, <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">output dir</span>
          xc=<span style="color: #00cd00;">'PBE'</span>,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">the exchange-correlation functional</span>
          nbands=6,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">number of bands</span>
          encut=350, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">planewave cutoff</span>
          ismear=1,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Methfessel-Paxton smearing</span>
          sigma=0.01,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">very small smearing factor for a molecule</span>
          atoms=co) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'energy = {0} eV'</span>.format(co.get_potential_energy())
    <span style="color: #cd0000; font-weight: bold;">print</span> co.get_forces()
</pre>


<pre class="example">
energy = -14.687906 eV
[[ 5.095  0.     0.   ]
 [-5.095  0.     0.   ]]
</pre>



</div>

<div id="outline-container-3-3-1-1" class="outline-5">
<h5 id="sec-3-3-1-1"><span class="section-number-5">3.3.1.1</span> Convergence with unit cell size</h5>
<div class="outline-text-5" id="text-3-3-1-1">

<p>There are a number of parameters that affect the energy and forces including the calculation parameters and the unit cell. We will first consider the effect of the unit cell on the total energy and forces. The reason that the unit cell affects the total energy is that it can change the distribution of electrons in the molecule.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms,Atom
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
np.set_printoptions(precision=3, suppress=<span style="color: #cd0000; font-weight: bold;">True</span>)

atoms = Atoms([Atom(<span style="color: #00cd00;">'C'</span>,[0,   0, 0]),
               Atom(<span style="color: #00cd00;">'O'</span>,[1.2, 0, 0])])

L = [4, 5, 6, 8, 10]

volumes, energies = [], []
<span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> L:
    atoms.set_cell([a,a,a], scale_atoms=<span style="color: #cd0000; font-weight: bold;">False</span>)
    atoms.center()
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-L-{0}'</span>.format(a),
              encut=350,
              xc=<span style="color: #00cd00;">'PBE'</span>,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            energies.append(atoms.get_potential_energy())
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">pass</span>
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(L, energies, <span style="color: #00cd00;">'bo-'</span>)
plt.xlabel(<span style="color: #00cd00;">'Unit cell length ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/co-e-v.png'</span>)
plt.show()
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/co-e-v.png"  alt="./images/co-e-v.png" /></p>
<p>Total energy of a CO molecule as a function of the unit cell length.</p>
</div>

<p>
Here there are evidently attractive interactions between the CO molecules which lower the total energy for small box sizes. We have to decide what an appropriate volume for our calculation is, and the choice depends on the goal. We may wish to know the total energy of a molecule that is not interacting with any other molecules, e.g. in the ideal gas limit. In that case we need a large unit cell so the electron density from the molecule does not go outside the unit cell where it would overlap with neighboring images.
</p>
<p>
Let us consider what the pressure in the unit cell is. In the ideal gas limit we have <img src="ltxpng/dft_f7d6f2c87b6b5e6a9a6df30af6d65e829354a7db.png" alt="$PV = nRT$"/>, which gives a pressure of zero at absolute zero. At non-zero temperatures, we have <img src="ltxpng/dft_3e5c5a4a9dd9cf449a1229d768d88386850ee478.png" alt="$P=n/V RT$"/>. Let us consider some examples. In atomic units we use <img src="ltxpng/dft_adde2f8fb7c28211f763655dc19f7a46ddad7a59.png" alt="$k_B$"/> instead of <img src="ltxpng/dft_4e7a51e1e47a30c6824157edf5af15fc51904005.png" alt="$R$"/>, and it has a value of
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> kB, Pascal
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

atm = 101325 * Pascal

L = np.linspace(4,10)
V = L**3

n = 1 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">one atom per unit cell</span>

<span style="color: #cd0000; font-weight: bold;">for</span> T <span style="color: #cd0000; font-weight: bold;">in</span> [298, 600, 1000]:
    P = n/V*kB*T / atm <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">convert to atmospheres</span>

    plt.plot(V, P, label=<span style="color: #00cd00;">'{0}K'</span>.format(T))

plt.xlabel(<span style="color: #00cd00;">'Unit cell volume ($\AA^3$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Pressure (atm)'</span>)
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/ideal-gas-pressure.png'</span>)
plt.show()
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/ideal-gas-pressure.png"  alt="./images/ideal-gas-pressure.png" /></p>
<p>Ideal gas pressure dependence on temperature and unit cell volume.</p>
</div>

</div>

</div>

<div id="outline-container-3-3-1-2" class="outline-5">
<h5 id="sec-3-3-1-2"><span class="section-number-5">3.3.1.2</span> Convergence of ENCUT</h5>
<div class="outline-text-5" id="text-3-3-1-2">

<p>The total energy and forces also depend on the computational parameters, notably <a href=http://cms.mpi.univie.ac.at/wiki/index.php/ENCUT>ENCUT</a>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms,Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
np.set_printoptions(precision=3, suppress=<span style="color: #cd0000; font-weight: bold;">True</span>)

atoms = Atoms([Atom(<span style="color: #00cd00;">'C'</span>,[0,   0, 0]),
               Atom(<span style="color: #00cd00;">'O'</span>,[1.2, 0, 0])],
               cell=(6,6,6))
atoms.center()

ENCUTS = [250, 300, 350, 400, 450, 500]

energies = []
ready = <span style="color: #cd0000; font-weight: bold;">True</span>
<span style="color: #cd0000; font-weight: bold;">for</span> en <span style="color: #cd0000; font-weight: bold;">in</span> ENCUTS:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-en-{0}'</span>.format(en),
              encut=en,
              xc=<span style="color: #00cd00;">'PBE'</span>,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            energies.append(atoms.get_potential_energy())
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            ready = <span style="color: #cd0000; font-weight: bold;">False</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">not</span> ready:
   <span style="color: #cd0000; font-weight: bold;">import</span> sys; sys.exit()

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(ENCUTS, energies, <span style="color: #00cd00;">'bo-'</span>)
plt.xlabel(<span style="color: #00cd00;">'ENCUT (eV)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/co-encut-v.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/co-encut-v.png"  alt="./images/co-encut-v.png" /></p>
<p>Dependence of the total energy of CO molecule on ENCUT.</p>
</div>

<p>
You can see in this figure that it takes a cutoff energy of about 400 eV to achieve a convergence level around 10 meV, and that even at 500 meV the energy is still changing slightly. Keep in mind that we are generally interested in differences in total energy, and the differences tend to converge faster than a single total energy. Also it is important to note that it is usually a single element that determines the rate of convergence. The reason we do not just use very high ENCUT all the time is it is expensive.
</p>



<pre class="src src-sh">grep <span style="color: #00cd00;">"Elapsed time (sec):"</span> molecules/co-en-*/OUTCAR
</pre>


<p>
molecules/co-en-250/OUTCAR:                         Elapsed time (sec):        4.954
molecules/co-en-300/OUTCAR:                         Elapsed time (sec):        7.662
molecules/co-en-350/OUTCAR:                         Elapsed time (sec):        8.232
molecules/co-en-400/OUTCAR:                         Elapsed time (sec):       11.148
molecules/co-en-450/OUTCAR:                         Elapsed time (sec):       12.592
molecules/co-en-500/OUTCAR:                         Elapsed time (sec):       15.425
</p>
<p>
Although here the times do not seem that unreasonable, note we increased the time by a factor of three by simply doubling ENCUT. If the first time was a week, this is a significant increase in time!
</p>
</div>
</div>

</div>

<div id="outline-container-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> Visualizing electron density</h4>
<div class="outline-text-4" id="text-3-3-2">


<p>
The electron density is a 3<img src="ltxpng/dft_bc313c7761de36cde3cb106773f4c7c2740a8572.png" alt="\(d\)"/> quantity: for every <img src="ltxpng/dft_9aac708762d70746720cd1e43eeddef178fd97bc.png" alt="$(x,y,z)$"/> point, there is a charge density. That means we need 4 numbers for each point: <img src="ltxpng/dft_9aac708762d70746720cd1e43eeddef178fd97bc.png" alt="$(x,y,z)$"/> and <img src="ltxpng/dft_fd4f0e2087a0d4eec987ed5e29c7e2092fd8cf26.png" alt="$\rho(x,y,z)$"/>. Below we show an example (Figure ref:ref:fig:cd1) of plotting the charge density, and we consider some issues we have to consider when visualizing volumetric data in unit cells with periodic boundary conditions. We will use the results from a previous calculation.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> enthought.mayavi <span style="color: #cd0000; font-weight: bold;">import</span> mlab
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data <span style="color: #cd0000; font-weight: bold;">import</span> vdw_radii
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.colors <span style="color: #cd0000; font-weight: bold;">import</span> cpk_colors

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/simple-co'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    x, y, z, cd = calc.get_charge_density()

mlab.figure(1, bgcolor=(1, 1, 1)) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make a white figure</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">plot the atoms as spheres</span>
<span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms:
    mlab.points3d(atom.x,
                  atom.y,
                  atom.z,
                  scale_factor=vdw_radii[atom.number]/5., <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">this determines the size of the atom</span>
                  resolution=20,
                  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">a tuple is required for the color</span>
                  color=<span style="color: #cd0000; font-weight: bold;">tuple</span>(cpk_colors[atom.number]),
                  scale_mode=<span style="color: #00cd00;">'none'</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">draw the unit cell - there are 8 corners, and 12 connections</span>
a1, a2, a3 = atoms.get_cell()
origin = [0, 0, 0]
cell_matrix = [[origin,  a1],
               [origin,  a2],
               [origin,  a3],
               [a1,      a1 + a2],
               [a1,      a1 + a3],
               [a2,      a2 + a1],
               [a2,      a2 + a3],
               [a3,      a1 + a3],
               [a3,      a2 + a3],
               [a1 + a2, a1 + a2 + a3],
               [a2 + a3, a1 + a2 + a3],
               [a1 + a3, a1 + a3 + a2]]

<span style="color: #cd0000; font-weight: bold;">for</span> p1, p2 <span style="color: #cd0000; font-weight: bold;">in</span> cell_matrix:
    mlab.plot3d([p1[0], p2[0]], <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">x-positions</span>
                [p1[1], p2[1]], <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">y-positions</span>
                [p1[2], p2[2]], <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">z-positions</span>
                tube_radius=0.02)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Now plot the charge density</span>
mlab.contour3d(x, y, z, cd)
mlab.view(azimuth=-90, elevation=90, distance=<span style="color: #00cd00;">'auto'</span>)

mlab.savefig(<span style="color: #00cd00;">'images/co-cd.png'</span>)
mlab.show()
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/co-cd.png"  alt="./images/co-cd.png" /></p>
<p>Charge density of a CO molecule that is located at the origin. The electron density that is outside the cell is wrapped around to the other corners. \label{fig:cd1}</p>
</div>

<p>
If we take care to center the CO molecule in the unit cell, we get a nicer looking result.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> enthought.mayavi <span style="color: #cd0000; font-weight: bold;">import</span> mlab
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data <span style="color: #cd0000; font-weight: bold;">import</span> vdw_radii
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.colors <span style="color: #cd0000; font-weight: bold;">import</span> cpk_colors
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'C'</span>, [2.422, 0.0, 0.0]),
               Atom(<span style="color: #00cd00;">'O'</span>, [3.578, 0.0, 0.0])],
               cell=(10,10,10))

atoms.center()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-centered'</span>,
          encut=350,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    atoms = calc.get_atoms()
    x, y, z, cd = calc.get_charge_density()

mlab.figure(bgcolor=(1, 1, 1))

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">plot the atoms as spheres</span>
<span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms:
    mlab.points3d(atom.x,
                  atom.y,
                  atom.z,
                  scale_factor=vdw_radii[atom.number]/5.,
                  resolution=20,
                  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">a tuple is required for the color</span>
                  color=<span style="color: #cd0000; font-weight: bold;">tuple</span>(cpk_colors[atom.number]),
                  scale_mode=<span style="color: #00cd00;">'none'</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">draw the unit cell - there are 8 corners, and 12 connections</span>
a1, a2, a3 = atoms.get_cell()
origin = [0, 0, 0]
cell_matrix = [[origin,  a1],
               [origin,  a2],
               [origin,  a3],
               [a1,      a1 + a2],
               [a1,      a1 + a3],
               [a2,      a2 + a1],
               [a2,      a2 + a3],
               [a3,      a1 + a3],
               [a3,      a2 + a3],
               [a1 + a2, a1 + a2 + a3],
               [a2 + a3, a1 + a2 + a3],
               [a1 + a3, a1 + a3 + a2]]

<span style="color: #cd0000; font-weight: bold;">for</span> p1, p2 <span style="color: #cd0000; font-weight: bold;">in</span> cell_matrix:
    mlab.plot3d([p1[0], p2[0]], <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">x-positions</span>
                [p1[1], p2[1]], <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">y-positions</span>
                [p1[2], p2[2]], <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">z-positions</span>
                tube_radius=0.02)


<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Now plot the charge density</span>
mlab.contour3d(x, y, z, cd, transparent=<span style="color: #cd0000; font-weight: bold;">True</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this view was empirically found by iteration</span>
mlab.view(azimuth=-90, elevation=90, distance=<span style="color: #00cd00;">'auto'</span>)

mlab.savefig(<span style="color: #00cd00;">'images/co-centered-cd.png'</span>)
mlab.show()
</pre>




<div class="figure">
<p><img src="./images/co-centered-cd.png"  alt="./images/co-centered-cd.png" /></p>
<p>Charge density of a CO molecule centered in the unit cell. Now the electron density is centered in the unit cell. \label{fig:cd2}</p>
</div>
</div>

</div>

<div id="outline-container-3-3-3" class="outline-4">
<h4 id="sec-3-3-3"><span class="section-number-4">3.3.3</span> Dipole moments</h4>
<div class="outline-text-4" id="text-3-3-3">


<p>
The <a href="http://en.wikipedia.org/wiki/Molecular_dipole_moment#Molecular_dipoles">dipole moment</a> is a vector describing the separation of  electrical (negative) and nuclear (positive) charge. The magnitude of this vector is the dipole moment, which has units of Coulomb-meter, or more commonly Debye. The symmetry of a molecule determines if a molecule has a dipole moment or not. Below we compute the dipole moment of CO. We must integrate the electron density to find the center of electrical charge, and compute a sum over the nuclei to find the center of positive charge.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> Debye

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-centered'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms.get_potential_energy()

    vcd = VaspChargeDensity()

    cd = np.array(vcd.chg[0])
    n0, n1, n2 = cd.shape

    s0 = 1.0/n0
    s1 = 1.0/n1
    s2 = 1.0/n2

    X, Y, Z = np.mgrid[0.0:1.0:s0,
                       0.0:1.0:s1,
                       0.0:1.0:s2]

    C = np.column_stack([X.ravel(),
                         Y.ravel(),
                         Z.ravel()])

    atoms = calc.get_atoms()
    uc = atoms.get_cell()
    real = np.dot(C, uc)

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">now convert arrays back to unitcell shape</span>
    x = np.reshape(real[:, 0], (n0, n1, n2))
    y = np.reshape(real[:, 1], (n0, n1, n2))
    z = np.reshape(real[:, 2], (n0, n1, n2))

    nelements = n0 * n1 * n2
    voxel_volume = atoms.get_volume() / nelements
    total_electron_charge = -cd.sum() * voxel_volume


    electron_density_center = np.array([(cd * x).sum(),
                                        (cd * y).sum(),
                                        (cd * z).sum()])
    electron_density_center *= voxel_volume
    electron_density_center /= total_electron_charge

    electron_dipole_moment = -electron_density_center * total_electron_charge

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now the ion charge center. We only need the Zval listed in the potcar</span>
    <span style="color: #cd0000; font-weight: bold;">from</span> jasp.POTCAR <span style="color: #cd0000; font-weight: bold;">import</span> get_ZVAL

    LOP = calc.get_pseudopotentials()
    ppp = os.environ[<span style="color: #00cd00;">'VASP_PP_PATH'</span>]

    zval = {}
    <span style="color: #cd0000; font-weight: bold;">for</span> sym, ppath, <span style="color: #cd0000; font-weight: bold;">hash</span> <span style="color: #cd0000; font-weight: bold;">in</span> LOP:
        fullpath = os.path.join(ppp, ppath)
        z = get_ZVAL(fullpath)
        zval[sym] = z
    ion_charge_center = np.array([0.0, 0.0, 0.0])
    total_ion_charge = 0.0
    <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms:
        Z = zval[atom.symbol]
        total_ion_charge += Z
        pos = atom.position
        ion_charge_center += Z*pos

    ion_charge_center /= total_ion_charge
    ion_dipole_moment = ion_charge_center * total_ion_charge

    dipole_vector = (ion_dipole_moment + electron_dipole_moment)

    dipole_moment = ((dipole_vector**2).sum())**0.5 / Debye

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The dipole moment is {0:1.2f} Debye'</span>.format(dipole_moment)
</pre>


<pre class="example">
The dipole moment is 0.10 Debye
</pre>


<p>
Note that a function using the code above exists in <code>jasp</code> which makes it trivial to compute the dipole moment. Here is an example of its usage.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> Debye

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-centered'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    dipole_vector = calc.get_dipole_moment()
    dipole_moment = ((dipole_vector**2).sum())**0.5/Debye
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The dipole moment is {0:1.2f} Debye'</span>.format(dipole_moment)
</pre>


<pre class="example">
The dipole moment is 0.10 Debye
</pre>


</div>

</div>

<div id="outline-container-3-3-4" class="outline-4">
<h4 id="sec-3-3-4"><span class="section-number-4">3.3.4</span> The density of states (DOS)</h4>
<div class="outline-text-4" id="text-3-3-4">

<p>The density of states (DOS) gives you the number of electronic states (i.e., the orbitals) that have a particular energy. We can get this information from the last calculation we just ran without having to run another DFT calculation.
</p>

<div class="warning">
<p>One way that <code>jasp</code> is unintuitive is that whenever you are "inside" (indented) a <code>with</code> statement, the current working directory may be different than where your script started. In this example that can lead to your figure not being saved where you expect it to be saved!
</p>
</div>




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.dft.dos <span style="color: #cd0000; font-weight: bold;">import</span> DOS
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/simple-co'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc: <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">we already ran this!</span>
    dos = DOS(calc)
    plt.plot(dos.get_energies(), dos.get_dos())
    plt.xlabel(<span style="color: #00cd00;">'Energy - $E_f$ (eV)'</span>)
    plt.ylabel(<span style="color: #00cd00;">'DOS'</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make sure you save the figure outside the with statement, or provide</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">the correct relative or absolute path to where you want it.</span>
plt.savefig(<span style="color: #00cd00;">'images/co-dos.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/co-dos.png"  alt="./images/co-dos.png" /></p>
<p>Density of states for a CO molecule.</p>
</div>

</div>

</div>

<div id="outline-container-3-3-5" class="outline-4">
<h4 id="sec-3-3-5"><span class="section-number-4">3.3.5</span> Atom-projected density of states on molecules</h4>
<div class="outline-text-4" id="text-3-3-5">

<p>Let us consider which states in the density of states belong to which atoms in a molecule. This can only be a qualitative consideration because the orbitals on the atoms often hybridize to form molecular orbitals, e.g. in methane the <img src="ltxpng/dft_fa772b0e1d1b97e293f3daf123bce4d25f789dcc.png" alt="$s$"/> and <img src="ltxpng/dft_90444012c6044316254889f04a1260f51809f999.png" alt="$p$"/> orbitals can form what we call <img src="ltxpng/dft_3f734587dafa0d4ce1fd3cf192c40c1f3e902a78.png" alt="$sp^3$"/> orbitals. We can compute atom-projected density of states in VASP, which is done by projecting the wave function onto localized atomic orbitals. Here is an example. We will consider the CO molecule. To get atom-projected density of states, we must set <a href=http://cms.mpi.univie.ac.at/wiki/index.php/RWIGS>RWIGS</a> for each atom. This parameter defines the radius of the sphere around the atom which cuts off the projection. The total density of states and projected density of states information comes from the DOSCAR file.
</p>
<p>
Note that unlike the DOS, here we must run another calculation because we did not specify the atom-projected keywords above. Our strategy is to get the atoms from the previous calculation, and use them in a new calculation. You could redo the calculation in the same directory, but you risk losing the results of the first step. That can make it difficult to reproduce a result. We advocate our approach of using multiple directories for the subsequent calculations, because it leaves a clear trail of how the work was done.
</p>

<div class="note">
<p>The <a href=http://cms.mpi.univie.ac.at/wiki/index.php/RWIGS>RWIGS</a> is not uniquely determined for an element. There are various natural choices, e.g. the ionic radius of an atom, or a value that minimizes overlap of neighboring spheres, but these values can change slightly in different environments.
</p>
<p>
You can also get spin-polarized atom-projected DOS, and magnetization projected DOS. See <a href="http://cms.mpi.univie.ac.at/vasp/vasp/DOSCAR_file.html#doscar">http://cms.mpi.univie.ac.at/vasp/vasp/DOSCAR_file.html#doscar</a> for more details.
</p>
</div>




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.dft.dos <span style="color: #cd0000; font-weight: bold;">import</span> DOS
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get the geometry from another calculation</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/simple-co'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-ados'</span>,
          encut=300,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          rwigs=[1.0, 1.0],     <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">these are the cutoff radii for projected states</span>
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now get results</span>
    dos = DOS(calc)
    plt.plot(dos.get_energies(), dos.get_dos() + 10)

    ados = VaspDos(efermi=calc.get_fermi_level())
    energies = ados.energy

    plt.plot(energies, ados.dos + 8, label=<span style="color: #00cd00;">'ADOS'</span>) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">these are the total DOS</span>

    c_s = ados.site_dos(0, <span style="color: #00cd00;">'s'</span>)
    c_p = ados.site_dos(0, <span style="color: #00cd00;">'p'</span>)
    o_s = ados.site_dos(1, <span style="color: #00cd00;">'s'</span>)
    o_p = ados.site_dos(1, <span style="color: #00cd00;">'p'</span>)

    c_d = ados.site_dos(0,<span style="color: #00cd00;">'d'</span>)
    o_d = ados.site_dos(1,<span style="color: #00cd00;">'d'</span>)

    plt.plot(energies, c_s + 6, energies, o_s + 5)
    plt.plot(energies, c_p + 4, energies, o_p + 3)
    plt.plot(energies, c_d, energies, o_d + 2)
    plt.xlabel(<span style="color: #00cd00;">'Energy - $E_f$ (eV)'</span>)
    plt.ylabel(<span style="color: #00cd00;">'DOS'</span>)
    plt.legend([<span style="color: #00cd00;">'DOS'</span>, <span style="color: #00cd00;">'ADOS'</span>,
                <span style="color: #00cd00;">'C$_s$'</span>, <span style="color: #00cd00;">'O$_s$'</span>,
                <span style="color: #00cd00;">'C$_p$'</span>, <span style="color: #00cd00;">'O$_p$'</span>,
                <span style="color: #00cd00;">'C$_d$'</span>, <span style="color: #00cd00;">'O$_d$'</span>],
                ncol=2,loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/co-ados.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/co-ados.png"  alt="./images/co-ados.png" /></p>
<p>Atom-projected DOS for a CO molecule. The total density of states and the \(s\), \(p\) and \(d\) states on the C and O are shown.</p>
</div>

</div>

</div>

<div id="outline-container-3-3-6" class="outline-4">
<h4 id="sec-3-3-6"><span class="section-number-4">3.3.6</span> <span class="todo TODO">TODO</span> Electrostatic potential</h4>
<div class="outline-text-4" id="text-3-3-6">

<p>This is an example of the so-called &sigma; hole in a <a href="http://pubs.acs.org/cen/science/87/8738sci2.html">halogen bond</a>. The coordinates for the CF<sub>3</sub>Br molecule were found at <a href="http://cccbdb.nist.gov/exp2.asp?casno=75638">http://cccbdb.nist.gov/exp2.asp?casno=75638</a>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

<span style="color: #cd0000; font-weight: bold;">from</span> enthought.mayavi <span style="color: #cd0000; font-weight: bold;">import</span> mlab
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data <span style="color: #cd0000; font-weight: bold;">import</span> vdw_radii
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.colors <span style="color: #cd0000; font-weight: bold;">import</span> cpk_colors

atoms = Atoms([Atom(<span style="color: #00cd00;">'C'</span>,  [ 0.0000,     0.0000,         -0.8088]),
               Atom(<span style="color: #00cd00;">'Br'</span>, [ 0.0000,     0.0000,          1.1146]),
               Atom(<span style="color: #00cd00;">'F'</span>,  [ 0.0000,     1.2455,         -1.2651]),
               Atom(<span style="color: #00cd00;">'F'</span>,  [ 1.0787,    -0.6228,         -1.2651]),
               Atom(<span style="color: #00cd00;">'F'</span>,  [-1.0787,    -0.6228,         -1.2651])],
               cell=(10, 10, 10))
atoms.center()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/CF3Br'</span>,
          encut=350,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          ibrion=1,
          nsw=50,
          lvtot=<span style="color: #cd0000; font-weight: bold;">True</span>,
          lvhar=<span style="color: #cd0000; font-weight: bold;">True</span>,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set_nbands(f=2)
    calc.calculate()

    x, y, z, lp = calc.get_local_potential()
    x, y, z, cd = calc.get_charge_density()

mlab.figure(1, bgcolor=(1, 1, 1)) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make a white figure</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">plot the atoms as spheres</span>
<span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms:
    mlab.points3d(atom.x,
                  atom.y,
                  atom.z,
                  scale_factor=vdw_radii[atom.number]/5.,
                  resolution=20,
                  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">a tuple is required for the color</span>
                  color=<span style="color: #cd0000; font-weight: bold;">tuple</span>(cpk_colors[atom.number]),
                  scale_mode=<span style="color: #00cd00;">'none'</span>)
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">plot the bonds. We want a line from C-Br, C-F, etc...</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">We create a bond matrix showing which atoms are connected.</span>
bond_matrix = [[0, 1],
               [0, 2],
               [0, 3],
               [0, 4]]

<span style="color: #cd0000; font-weight: bold;">for</span> a1, a2 <span style="color: #cd0000; font-weight: bold;">in</span> bond_matrix:
    mlab.plot3d(atoms.positions[[a1,a2], 0], <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">x-positions</span>
                atoms.positions[[a1,a2], 1], <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">y-positions</span>
                atoms.positions[[a1,a2], 2], <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">z-positions</span>
                [2, 2],
                tube_radius=0.02,
                colormap=<span style="color: #00cd00;">'Reds'</span>)

mlab.contour3d(x, y, z, lp)
mlab.savefig(<span style="color: #00cd00;">'images/halogen-ep.png'</span>)
mlab.show()
</pre>




<div class="figure">
<p><img src="./images/halogen-ep.png"  alt="./images/halogen-ep.png" /></p>
<p>Plot of the electrostatic potential of CF<sub>3</sub>Br. TODO: figure out how to do an isosurface of charge, colormapped by the local potential.</p>
</div>

<p>
See <a href="http://www.uni-due.de/~hp0058/?file=manual03.html&amp;dir=vmdplugins">http://www.uni-due.de/~hp0058/?file=manual03.html&amp;dir=vmdplugins</a> for examples of using <a href="http://www.ks.uiuc.edu/Research/vmd/">VMD</a> for visualization.
</p>
</div>

</div>

<div id="outline-container-3-3-7" class="outline-4">
<h4 id="sec-3-3-7"><span class="section-number-4">3.3.7</span> Bader analysis</h4>
<div class="outline-text-4" id="text-3-3-7">


<p>
Bader analysis is a charge partitioning scheme where charge is divided by surfaces of zero flux that define atomic basins of charge. The most modern way of calculating the Bader charges is using the <code>bader</code> program from Graeme Henkelmen's group (<cite>Henkelman2006354,doi.10.1021/ct100125x</cite>). Let us consider a water molecule, centered in a box. The strategy is first to run the calculation, then run the bader program on the results.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.structure <span style="color: #cd0000; font-weight: bold;">import</span> molecule
atoms = molecule(<span style="color: #00cd00;">'H2O'</span>)
atoms.center(vacuum=6)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o-bader'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()

    os.system(<span style="color: #00cd00;">'bader -p all_atom -p atom_index CHG'</span>)
</pre>



<pre class="example">
  GRID BASED BADER ANALYSIS  (Version 0.27e 05/09/11)

  OPEN ... CHG
  VASP-STYLE INPUT FILE
 VASP5 format
  FFT-grid:   112 x 128 x 120
  CLOSE ... CHG

  RUN TIME:    0.73 SECONDS

  CALCULATING BADER CHARGE DISTRIBUTION
                 0  10  25  50  75  100
  PERCENT DONE:  **********************

  REFINING AUTOMATICALLY
  ITERATION: 1
  EDGE POINTS:       1400048
  REASSIGNED POINTS:  111249
  ITERATION: 2
  CHECKED POINTS:     913184
  REASSIGNED POINTS:    1424
  ITERATION: 3
  CHECKED POINTS:      15784
  REASSIGNED POINTS:     362
  ITERATION: 4
  CHECKED POINTS:       3190
  REASSIGNED POINTS:     176
  ITERATION: 5
  CHECKED POINTS:       1228
  REASSIGNED POINTS:      99
  ITERATION: 6
  CHECKED POINTS:        688
  REASSIGNED POINTS:      21
  ITERATION: 7
  CHECKED POINTS:        267
  REASSIGNED POINTS:       1
  ITERATION: 8
  CHECKED POINTS:         26
  REASSIGNED POINTS:       0

  RUN TIME:      27.04 SECONDS

  CALCULATING MINIMUM DISTANCES TO ATOMS
                 0  10  25  50  75  100
  PERCENT DONE:  **********************

  RUN TIME:    1.30 SECONDS

  WRITING BADER ATOMIC CHARGES TO ACF.dat
  WRITING BADER VOLUME CHARGES TO BCF.dat

  NUMBER OF BADER MAXIMA FOUND:           5407
      SIGNIFICANT MAXIMA FOUND:             10
           NUMBER OF ELECTRONS:        7.99999

  WRITING ATOMIC VOLUMES
                 0  10  25  50  75  100
  PERCENT DONE:  **********************

  RUN TIME:    4.06 SECONDS

  WRITING BADER ATOMIC INDEX TO AtIndex.dat

</pre>



<pre class="src src-sh">cat ACF.dat
</pre>


<pre class="example">
    #         X           Y           Z        CHARGE     MIN DIST    ATOMIC VOL
 --------------------------------------------------------------------------------
    1      6.0000      7.5265      6.0000      0.0007      1.6422    759.8654
    2      6.0000      6.0000      6.0000      0.0003      1.6422    640.1559
    3      6.0000      6.7632      6.5963      7.9990      2.2193    644.5831
 --------------------------------------------------------------------------------
    VACUUM CHARGE:               0.0000
    VACUUM VOLUME:               0.0000
    NUMBER OF ELECTRONS:         8.0000
</pre>



<p>
This script should work, but only if displacement is set to None or we
convert the positions to Bohr. Otherwise, the positions do not match
because of a Bohr/Angstrom units problem in the code. Note the sorting that has to be done, because the order of atoms in the Atoms
object is not the same as in the POSCAR file.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io.bader <span style="color: #cd0000; font-weight: bold;">import</span> attach_charges
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> Bohr

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o-bader'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()

    symbols = np.array(atoms.get_chemical_symbols())[calc.sort]
    pos = atoms.positions[calc.sort] * Bohr
    newatoms = Atoms(symbols, positions=pos, cell=atoms.get_cell())

    attach_charges(newatoms, <span style="color: #00cd00;">'ACF.dat'</span>)

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+tblname: bader'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+caption: Bader charges for a water molecule'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'| atom | Bader charge|'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|-'</span>
    <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> newatoms:
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|{0} | {1} |'</span>.format(atom.symbol, atom.charge)
</pre>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>Bader charges for a water molecule</caption>
<colgroup><col class="left" /><col class="right" />
</colgroup>
<thead>
<tr><th scope="col" class="left">atom</th><th scope="col" class="right">Bader charge</th></tr>
</thead>
<tbody>
<tr><td class="left">H</td><td class="right">0.9993</td></tr>
<tr><td class="left">H</td><td class="right">0.9997</td></tr>
<tr><td class="left">O</td><td class="right">0.001</td></tr>
</tbody>
</table>


<p>
TODO: figure out these charges
</p>
</div>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Geometry optimization</h3>
<div class="outline-text-3" id="text-3-4">


</div>

<div id="outline-container-3-4-1" class="outline-4">
<h4 id="sec-3-4-1"><span class="section-number-4">3.4.1</span> Manual determination of a bond length</h4>
<div class="outline-text-4" id="text-3-4-1">

<p>The equilibrium bond length of a CO molecule is approximately the bond length that minimizes the total energy. We can find that by computing the total energy as a function of bond length, and noting where the minimum is. Here is an example in VASP. There are a few features to point out here. We want to compute 5 bond lengths, and each calculation is independent of all the others. <TT>jasp</TT> is set up to automatically handle jobs for you by submitting them to the queue. It raises a variety of exceptions to let you know what has happened, and you must handle these to control the workflow. We will illustrate this by the following examples.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
np.set_printoptions(precision=3,suppress=<span style="color: #cd0000; font-weight: bold;">True</span>)

bond_lengths = [1.05, 1.1, 1.15, 1.2, 1.25]
energies = []

<span style="color: #cd0000; font-weight: bold;">for</span> d <span style="color: #cd0000; font-weight: bold;">in</span> bond_lengths: <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">possible bond lengths</span>

    co = Atoms([Atom(<span style="color: #00cd00;">'C'</span>, [0, 0, 0]),
                Atom(<span style="color: #00cd00;">'O'</span>, [d, 0, 0])],
                cell=(6, 6, 6))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-{0}'</span>.format(d), <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">output dir</span>
              xc=<span style="color: #00cd00;">'PBE'</span>,
              nbands=6,
              encut=350,
              ismear=1,
              sigma=0.01,
              atoms=co):
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            e = co.get_potential_energy()
            energies.append(e)
            <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'d = {0:1.2f} ang'</span>.format(d)
            <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'energy = {0:1.3f} eV'</span>.format(e)
            <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'forces = (eV/ang)\n {0}'</span>.format(co.get_forces())
            <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">''</span> <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">blank line</span>
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            energies.append(<span style="color: #cd0000; font-weight: bold;">None</span>)
            <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">not</span> <span style="color: #cd0000; font-weight: bold;">None</span> <span style="color: #cd0000; font-weight: bold;">in</span> energies:
    <span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
    plt.plot(bond_lengths, energies, <span style="color: #00cd00;">'bo-'</span>)
    plt.xlabel(<span style="color: #00cd00;">'Bond length ($\AA$)'</span>)
    plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
    plt.savefig(<span style="color: #00cd00;">'images/co-bondlengths.png'</span>)
</pre>



<pre class="example">d = 1.05 ang
energy = -14.215189 eV
forces = (eV/ang)
[[-14.903   0.      0.   ]
 [ 14.903   0.      0.   ]]

d = 1.10 ang
energy = -14.719882 eV
forces = (eV/ang)
[[-5.8  0.   0. ]
 [ 5.8  0.   0. ]]

d = 1.15 ang
energy = -14.838448 eV
forces = (eV/ang)
[[ 0.645  0.     0.   ]
 [-0.645  0.     0.   ]]

d = 1.20 ang
energy = -14.687906 eV
forces = (eV/ang)
[[ 5.095  0.     0.   ]
 [-5.095  0.     0.   ]]

d = 1.25 ang
energy = -14.351675 eV
forces = (eV/ang)
[[ 8.141  0.     0.   ]
 [-8.141  0.     0.   ]]

</pre>


<p>
To find the minimum we could run more calculations, but a simpler and faster way is to fit a polynomial to the data, and find the analytical minimum. The results are shown in Figure ref:ref:fig:co-bondlengths.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
np.set_printoptions(precision=3,suppress=<span style="color: #cd0000; font-weight: bold;">True</span>)

bond_lengths = [1.05, 1.1, 1.15, 1.2, 1.25]
energies = []

<span style="color: #cd0000; font-weight: bold;">for</span> d <span style="color: #cd0000; font-weight: bold;">in</span> bond_lengths: <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">possible bond lengths</span>

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-{0}'</span>.format(d)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        energies.append(atoms.get_potential_energy())

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Now we fit an equation - cubic polynomial</span>
pp = np.polyfit(bond_lengths, energies, 3)
dp = np.polyder(pp)  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">first derivative - quadratic</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">we expect two roots from the quadratic eqn. These are where the</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">first derivative is equal to zero.</span>
roots = np.roots(dp)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">The minimum is where the second derivative is positive.</span>
dpp = np.polyder(dp) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">second derivative - line</span>
secd = np.polyval(dpp, roots)

minV = roots[secd &gt; 0]
minE = np.polyval(pp, minV)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The minimum energy is {0} eV at V = {1} Ang^3'</span>.format(minE,minV)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">plot the fit</span>
x = np.linspace(1.05, 1.25)
fit = np.polyval(pp, x)

plt.plot(bond_lengths, energies, <span style="color: #00cd00;">'bo '</span>)
plt.plot(x,fit, <span style="color: #00cd00;">'r-'</span>)
plt.plot(minV, minE, <span style="color: #00cd00;">'m* '</span>)
plt.legend([<span style="color: #00cd00;">'DFT'</span>,<span style="color: #00cd00;">'fit'</span>,<span style="color: #00cd00;">'minimum'</span>], numpoints=1)
plt.xlabel(<span style="color: #00cd00;">'Bond length ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/co-bondlengths.png'</span>)
plt.show()
</pre>


<pre class="example">
The minimum energy is [-14.843] eV at V = [ 1.144] Ang^3
</pre>




<div class="figure">
<p><img src="./images/co-bondlengths.png"  alt="./images/co-bondlengths.png" /></p>
<p>Energy vs CO bond length. \label{fig:co-bondlengths}</p>
</div>

</div>

</div>

<div id="outline-container-3-4-2" class="outline-4">
<h4 id="sec-3-4-2"><span class="section-number-4">3.4.2</span> Automatic geometry optimization with VASP</h4>
<div class="outline-text-4" id="text-3-4-2">

<p>It is generally the case that the equilibrium geometry of a system is the one that minimizes the total energy and forces. Since each atom has three degrees of freedom, you can quickly get a high dimensional optimization problem. Luckily, VASP has built-in geometry optimization using the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/IBRION>IBRION</a> and <a href=http://cms.mpi.univie.ac.at/wiki/index.php/NSW>NSW</a> tags. Here we compute the bond length for a CO molecule, letting VASP do the geometry optimization for us.
</p>
<p>
Here are the most common choices for IBRION.
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="right" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="right">IBRION value</th><th scope="col" class="left">algorithm</th></tr>
</thead>
<tbody>
<tr><td class="right">1</td><td class="left">quasi-Newton    (use if initial guess is good)</td></tr>
<tr><td class="right">2</td><td class="left">conjugate gradient</td></tr>
</tbody>
</table>




<div class="note">
<p>VASP applies a criteria for stopping a geometry optimization. When the change in energy between two steps is less than 0.001 eV (or 10*EDIFF), the relaxation is stopped. This criteria is controlled by the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/EDIFFG>EDIFFG</a> tag. If you prefer to stop based on forces, set EDIFFG=-0.05, i.e. to a negative number. The units of force is eV/&Aring;. For most work, a force tolerance of 0.05 eV/&Aring; is usually sufficient.
</p>
</div>




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

co = Atoms([Atom(<span style="color: #00cd00;">'C'</span>,[0,0,0]),
            Atom(<span style="color: #00cd00;">'O'</span>,[1.2,0,0])],
            cell=(6,6,6))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-cg'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          nbands=6,
          encut=350,
          ismear=1,
          sigma=0.01, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this is small for a molecule</span>
          ibrion=2,   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">conjugate gradient optimizer</span>
          nsw=5,      <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">do at least 5 steps to relax</span>
          atoms=co) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Forces'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'======='</span>
    <span style="color: #cd0000; font-weight: bold;">print</span>  co.get_forces()

    pos = co.get_positions()
    d = ((pos[0] - pos[1])**2).sum()**0.5
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Bondlength = {0:1.2f} angstroms'</span>.format(d)
</pre>


<pre class="example">
Forces
=======
[[ 0.003  0.     0.   ]
 [-0.003  0.     0.   ]]
Bondlength = 1.14 angstroms
</pre>


</div>

</div>

<div id="outline-container-3-4-3" class="outline-4">
<h4 id="sec-3-4-3"><span class="section-number-4">3.4.3</span> Relaxation of a water molecule</h4>
<div class="outline-text-4" id="text-3-4-3">

<p>It is not more complicated to relax more atoms, it just may take longer because there are more electrons and degrees of freedom. Here we relax a water molecule which has three atoms.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

atoms = Atoms([Atom(<span style="color: #00cd00;">'H'</span>, [0.5960812,  -0.7677068,   0.0000000]),
               Atom(<span style="color: #00cd00;">'O'</span>, [0.0000000,   0.0000000,   0.0000000]),
               Atom(<span style="color: #00cd00;">'H'</span>, [0.5960812,   0.7677068,   0.0000000])],
               cell=(8, 8, 8))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o_relax'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Gaussian smearing</span>
          ibrion=2,
          ediff=1e-8,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">"forces"</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'======='</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_forces()
</pre>


<pre class="example">
forces
=======
[[ 0.    -0.     0.   ]
 [-0.001  0.     0.   ]
 [ 0.     0.     0.   ]]
</pre>


</div>
</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Vibrational frequencies</h3>
<div class="outline-text-3" id="text-3-5">



</div>

<div id="outline-container-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> Manual calculation of vibrational frequency</h4>
<div class="outline-text-4" id="text-3-5-1">


<p>
The principle idea in calculating vibrational frequencies is that we consider a molecular system as masses connected by springs. If the springs are Hookean, e.g. the force is proportional to the displacement, then we can readily solve the equations of motion and find that the vibrational frequencies are related to the force constants and the masses of the atoms. For example, in a simple molecule like CO where there is only one spring, the frequency is:
</p>
<p>
<img src="ltxpng/dft_c9dacd8fba3e2c9804431740fea1b63e5d2be11c.png" alt="$\nu = \frac{1}{2\pi}\sqrt{k/\mu}$"/> where <img src="ltxpng/dft_a9a68363476f71748e5107ddcf7c79bbd29a7194.png" alt="$\frac{1}{\mu} = \frac{1}{m_C} + \frac{1}{m_O}$"/> and <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/> is the spring constant. We will compute the value of <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/> from DFT calculations as follows:
</p>
<p>
<img src="ltxpng/dft_a9058c4fe79899d46181b8bc6b97be69889c1c0d.png" alt="$k = \frac{\partial^2E}{\partial x^2}$"/> at the equilibrium bond length. We actually already have the data to do this from <a href="#sec-3-4-1">Manual determination</a>. We only need to fit an equation to the energy vs. bond-length data, find the minimum energy bond-length, and then evaluate the second derivative of the fitted function at the minimum. We will use a cubic polynomial for demonstration here. Polynomials are numerically convenient because they are easy to fit, and it is trivial to get the roots and derivatives of the polynomials, as well as to evaluate them at other points using <TT>numpy.polyfit</TT>, <TT>numpy.polyder</TT>, and <TT>numpy.polyval</TT>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> *

bond_lengths = [1.05, 1.1, 1.15, 1.2, 1.25]
energies = []

<span style="color: #cd0000; font-weight: bold;">for</span> d <span style="color: #cd0000; font-weight: bold;">in</span> bond_lengths:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-{0}'</span>.format(d)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        energies.append(atoms.get_potential_energy())

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">fit the data</span>
pars = np.polyfit(bond_lengths, energies, 3)
xfit = np.linspace(1.05, 1.25)
efit = np.polyval(pars, xfit)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">first derivative</span>
dpars = np.polyder(pars)
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">find where the minimum is. chose the second one because it is the</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">minimum we need.</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'roots of first derivative are {0}'</span>.format(np.roots(dpars))

d_min = 1.14425395 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">we manually copy this from the output to here</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">second derivative</span>
ddpars = np.polyder(dpars)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">curvature at minimum = force constant</span>
k = np.polyval(ddpars, d_min) / kg * s**2

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">reduced mass</span>
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data <span style="color: #cd0000; font-weight: bold;">import</span> atomic_masses
C_mass = atomic_masses[6] / kg
O_mass = atomic_masses[8] / kg

mu = (C_mass*O_mass)/(C_mass + O_mass)

frequency = 1. / (2. * np.pi) * np.sqrt(k / mu)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The CO vibrational frequency is {0} cm^{{-1}}'</span>.format(frequency/3e10)

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(bond_lengths, energies, <span style="color: #00cd00;">'bo '</span>)
plt.plot(xfit, efit, <span style="color: #00cd00;">'b-'</span>)
plt.xlabel(<span style="color: #00cd00;">'Bond length ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.show()
</pre>


<pre class="example">
roots of first derivative are [ 1.43384501  1.14425395]
The frequency is 2143.60766258 cm^{-1}
</pre>


<p>
This result is in good agreement with <a href="http://webbook.nist.gov/cgi/cbook.cgi?ID=C630080&amp;Units=SI&amp;Type=IR-SPEC&amp;Index=0#IR-SPEC">experiment</a>. The procedure described above is basically how many vibrational calculations are performed. With more atoms, you have to determine a force constant matrix and diagonalize it. For more details, see (<cite>wilson1955</cite>). In practice, we usually allow a packaged code to automate this, which we cover in <a href="#sec-3-5-2">Automated vibrational calculations</a>.
</p>
<p>
We now consider how much energy is in this vibration. This is commonly called zero-point energy (ZPE) and it is defined as <img src="ltxpng/dft_e0730b11bc233e3fce3a944ebe05345973b0cffa.png" alt="$E_{ZPE} = \frac{1}{2} h \nu$"/> for a single mode, and <img src="ltxpng/dft_9d9531e8dfadd23e968f662de81486da4ad2ca53.png" alt="$h$"/> is Planck's constant (4.135667516e-15 eV/s).
</p>



<pre class="src src-python">c = 3e10 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">speed of light cm/s</span>
h = 4.135667516e-15 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">eV/s</span>

nu = 2143.6076625*c <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">1/s</span>

E_zpe = 0.5*h*nu

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'E_ZPE = {0:1.3f} eV'</span>.format(E_zpe)
</pre>


<pre class="example">
E_ZPE = 0.133 eV
</pre>


<p>
This is a reasonable amount of energy! Zero-point energy increases with increasing vibrational frequency, and tends to be very important for small atoms.
</p>
<p>
A final note is that this analysis is in the "harmonic approximation". The frequency equation is the solution to a harmonic oscillator. If the spring is non-linear, then there are anharmonic effects that may become important, especially at higher temperatures.
</p>
</div>

</div>

<div id="outline-container-3-5-2" class="outline-4">
<h4 id="sec-3-5-2"><span class="section-number-4">3.5.2</span> Automated vibrational calculations</h4>
<div class="outline-text-4" id="text-3-5-2">

<p>VASP has built-in capability for performing vibrational calculations. We access the capability by using a new value for <a href=http://cms.mpi.univie.ac.at/wiki/index.php/IBRION>IBRION</a>. The values of 5 and 6 calculated the Hessian matrix using finite differences. For IBRION=5, all atoms that are not constrained are displaced. For IBRION=6, only symmetry inequivalent displacements are considered, which makes the calculations slightly cheaper. You can specify the number of displacements with <a href=http://cms.mpi.univie.ac.at/wiki/index.php/NFREE>NFREE</a>. The default number of displacements is 2. You can also specify the size of the displacement with <a href=http://cms.mpi.univie.ac.at/wiki/index.php/POTIM>POTIM</a> (the default is 0.015 &Aring;).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">adapted from http://cms.mpi.univie.ac.at/wiki/index.php/H2O_vibration</span>
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> ase.units

atoms = Atoms([Atom(<span style="color: #00cd00;">'H'</span>, [0.5960812,  -0.7677068,   0.0000000]),
               Atom(<span style="color: #00cd00;">'O'</span>, [0.0000000,   0.0000000,   0.0000000]),
               Atom(<span style="color: #00cd00;">'H'</span>, [0.5960812,   0.7677068,   0.0000000])],
               cell=(8, 8, 8))
atoms.center()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o_vib'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Gaussian smearing</span>
          ibrion=6,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">finite differences with symmetry</span>
          nfree=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">central differences (default)</span>
          potim=0.015,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">default as well</span>
          ediff=1e-8, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">for vibrations you need precise energies</span>
          nsw=1,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Forces'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'======'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_forces()
    <span style="color: #cd0000; font-weight: bold;">print</span>
    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">vibrational energies are in eV</span>
    energies, modes = calc.get_vibrational_modes()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'energies\n========'</span>
    <span style="color: #cd0000; font-weight: bold;">for</span> i, e <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(energies):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:02d}: {1} eV'</span>.format(i, e)
</pre>



<pre class="example">Forces
======
[[ 0.018 -0.032 -0.001]
 [-0.035  0.     0.003]
 [ 0.018  0.032 -0.001]]

energies
========
00: 0.475824705 eV
01: 0.461734211 eV
02: 0.19618999 eV
03: 0.007093876 eV
04: 0.002459836 eV
05: (0.000291856+0j) eV
06: (0.012642767+0j) eV
07: (0.012959493+0j) eV
08: (0.015883929+0j) eV
</pre>


<p>
Note we get 9 frequencies here. Water has 3 atoms, with three degrees of freedom each, leading to 9 possible combinations of collective motions. Three of those collective motions are translations, i.e. where all atoms move in the same direction (either <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/>, <img src="ltxpng/dft_7caba42fa0145427d12beda30808356e5038ef71.png" alt="$y$"/> or <img src="ltxpng/dft_e9250f6ac1fdc9d8c2aa68e27459d678b8ef389b.png" alt="$z$"/>) and there is no change in the total energy of the molecule. Another three of those motions are rotations, which also do not change the total energy of the molecule. That leaves 3N-6 = 3 degrees of vibrational freedom where some or all of the bonds are stretched, resulting in a change in the total energy. The modes of water vibration are (with our calculated values in parentheses):
</p>
<ol>
<li>a symmetric stretch at 3657 cm<sup>-1</sup>   (3723)
</li>
<li>an asymmetric stretch at 3756 cm<sup>-1</sup> (3836)
</li>
<li>and a bending mode at 1595 cm<sup>-1</sup>    (1583)
</li>
</ol>


<p>
<a href="http://webbook.nist.gov/cgi/cbook.cgi?ID=C7732185&amp;Mask=800#Electronic-Spec">http://webbook.nist.gov/cgi/cbook.cgi?ID=C7732185&amp;Mask=800#Electronic-Spec</a>
</p>
<p>
The results are not too far off, and more accurate frequencies may be possible using tighter tolerance on <a href=http://cms.mpi.univie.ac.at/wiki/index.php/POTIM>POTIM</a>, or by using <a href=http://cms.mpi.univie.ac.at/wiki/index.php/IBRION>IBRION</a>=7 or 8.
</p>
<p>
Let us briefly discuss how to determine which vectors are vibrations and which are rotations or translations. One way is to visualize the modes. The vibrations are easy to spot. The rotations/translations are not always cleanly separable. This is an issue of accuracy and convergence. We usually do not worry about this because these modes are usually not important.
</p>
<ol>
<li>mode 0 is an asymmetric stretch
</li>
<li>mode 1 is a symmetric stretch
</li>
<li>mode 2 is a bending mode
</li>
<li>mode 3 is a mixed translation/rotation
</li>
<li>mode 4 is a rotation
</li>
<li>mode 5 is a translation
</li>
<li>mode 6 is a rotation
</li>
<li>mode 7 is a partial translation
</li>
<li>mode 8 is a rotation
</li>
</ol>





<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o_vib'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    energies, modes = calc.get_vibrational_modes(mode=3, massweighted=<span style="color: #cd0000; font-weight: bold;">True</span>,
                                                 show=<span style="color: #cd0000; font-weight: bold;">True</span>)
</pre>



<p>
See <a href="http://www.gaussian.com/g_whitepap/vib.htm">http://www.gaussian.com/g_whitepap/vib.htm</a> for a more quantitative discussion of these modes, identifying them, and a method to project the rotations and translations out of the Hessian matrix.
</p>

</div>

<div id="outline-container-3-5-2-1" class="outline-5">
<h5 id="sec-3-5-2-1"><span class="section-number-5">3.5.2.1</span> Zero-point energy for multiple modes</h5>
<div class="outline-text-5" id="text-3-5-2-1">

<p>For a molecule with lots of vibrational modes the zero-point energy is defined as the sum over all the vibrational modes:
</p>
<p>
<img src="ltxpng/dft_37dfa6ae59e24ebdc00c728b57515087be7bab1b.png" alt="$E_{ZPE} = \sum_i \frac{1}{2} h \nu_i$"/>
</p>
<p>
Here is an example for water. Note we do not sum over the imaginary modes. We should also ignore the rotational and translational modes (some of those are imaginary, but some are just small).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
c = 3e10 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">speed of light cm/s</span>
h = 4.135667516e-15 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">eV/s</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">first, get the frequencies.</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o_vib'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    freq = calc.get_vibrational_frequencies()

ZPE = 0.0
<span style="color: #cd0000; font-weight: bold;">for</span> f <span style="color: #cd0000; font-weight: bold;">in</span> freq:
    <span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">not</span> <span style="color: #cd0000; font-weight: bold;">isinstance</span>(f,float):
        <span style="color: #cd0000; font-weight: bold;">continue</span> <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">skip complex numbers</span>
    nu = f*c <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">convert to frequency</span>
    ZPE += 0.5*h*nu

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The ZPE of water is {0:1.3f} eV'</span>.format(ZPE)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">one liner</span>
ZPE = np.sum([0.5*h*f*c <span style="color: #cd0000; font-weight: bold;">for</span> f <span style="color: #cd0000; font-weight: bold;">in</span> freq <span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">isinstance</span>(f, float)])
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The ZPE of water is {0:1.3f} eV'</span>.format(ZPE)
</pre>


<pre class="example">
The ZPE of water is 0.571 eV
</pre>


<p>
Note the zero-point energy of water is also fairly high (more than 0.5 eV). That is because of the high frequency O-H stretches.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> Simulated infrared spectra</h3>
<div class="outline-text-3" id="text-3-6">


<p>
At <a href="http://homepage.univie.ac.at/david.karhanek/downloads.html#Entry02">http://homepage.univie.ac.at/david.karhanek/downloads.html#Entry02</a> there is a recipe for computing the Infrared vibrational spectroscopy intensities in VASP. We are going to do that for water here. First, we will relax a water molecule.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

atoms = Atoms([Atom(<span style="color: #00cd00;">'H'</span>, [0.5960812,  -0.7677068,   0.0000000]),
               Atom(<span style="color: #00cd00;">'O'</span>, [0.0000000,   0.0000000,   0.0000000]),
               Atom(<span style="color: #00cd00;">'H'</span>, [0.5960812,   0.7677068,   0.0000000])],
               cell=(8, 8, 8))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o_relax'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Gaussian smearing</span>
          ibrion=2,
          ediff=1e-8,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Forces'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'==========================='</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_forces()
</pre>


<pre class="example">
Forces
===========================
[[ 0.    -0.     0.   ]
 [-0.001  0.     0.   ]
 [ 0.     0.     0.   ]]
</pre>


<p>
Next, we instruct VASP to compute the vibrational modes using <a href="http://cmt.dur.ac.uk/sjc/thesis_prt/node39.html">density functional perturbation theory</a> with IBRION=7. Note, this is different than in <a href="#sec-3-5">Vibrational frequencies</a> where finite differences were used.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">read in relaxed geometry</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o_relax'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now define a new calculator</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o_vib_dfpt'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Gaussian smearing</span>
          ibrion=7, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">switches on the DFPT vibrational analysis (with</span>
                    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">no symmetry constraints)</span>
          nfree=2,
          potim=0.015,
          lepsilon=<span style="color: #cd0000; font-weight: bold;">True</span>, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">enables to calculate and to print the BEC</span>
                         <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">tensors</span>
          lreal=<span style="color: #cd0000; font-weight: bold;">False</span>,
          nsw=1,
          nwrite=3, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">affects OUTCAR verbosity: explicitly forces</span>
                    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">SQRT(mass)-divided eigenvectors to be printed</span>
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate(atoms)
</pre>



<p>
To analyze the results, this <a href="http://homepage.univie.ac.at/david.karhanek/downloads.html#Entry02">shell script</a> was provided to extract the results.
</p>


<pre class="src src-sh"><span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">!/bin/</span><span style="color: #cd0000; font-weight: bold;">bash</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">A utility for calculating the vibrational intensities from VASP output (OUTCAR)</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">(C) David Karhanek, 2011-03-25, ICIQ Tarragona, Spain (www.iciq.es)</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">extract Born effective charges tensors</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"..reading OUTCAR"</span>
<span style="color: #cd00cd;">BORN_NROWS</span>=<span style="color: #cd00cd;">`grep NIONS OUTCAR | awk '{print $12*4+1}'`</span>
<span style="color: #cd0000; font-weight: bold;">if</span> [ <span style="color: #cd00cd;">`grep 'BORN' OUTCAR | wc -l`</span> = 0 ] ; <span style="color: #cd0000; font-weight: bold;">then</span> <span style="color: #00cd00;">\</span>
   <span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">" .. FAILED! Born effective charges missing! Bye! \n\n"</span> ; <span style="color: #cd0000; font-weight: bold;">exit</span> 1 ; <span style="color: #cd0000; font-weight: bold;">fi</span>
grep <span style="color: #00cd00;">"in e, cummulative"</span> -A $<span style="color: #cd00cd;">BORN_NROWS</span> OUTCAR &gt; born.txt

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">extract Eigenvectors and eigenvalues</span>
<span style="color: #cd0000; font-weight: bold;">if</span> [ <span style="color: #cd00cd;">`grep 'SQRT(mass)' OUTCAR | wc -l`</span> != 1 ] ; <span style="color: #cd0000; font-weight: bold;">then</span> <span style="color: #00cd00;">\</span>
   <span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">" .. FAILED! Restart VASP with NWRITE=3! Bye! \n\n"</span> ; <span style="color: #cd0000; font-weight: bold;">exit</span> 1 ; <span style="color: #cd0000; font-weight: bold;">fi</span>
<span style="color: #cd00cd;">EIG_NVIBS</span>=<span style="color: #cd00cd;">`grep -A 2000 'SQRT(mass)' OUTCAR | grep 'cm-1' | wc -l`</span>
<span style="color: #cd00cd;">EIG_NIONS</span>=<span style="color: #cd00cd;">`grep NIONS OUTCAR | awk '{print $12}'`</span>
<span style="color: #cd00cd;">EIG_NROWS</span>=<span style="color: #cd00cd;">`echo "($EIG_NIONS+3)*$EIG_NVIBS+3" | bc`</span>
grep -A $(($<span style="color: #cd00cd;">EIG_NROWS</span>+2)) <span style="color: #00cd00;">'SQRT(mass)'</span> OUTCAR | tail -n $(($<span style="color: #cd00cd;">EIG_NROWS</span>+1)) | sed <span style="color: #00cd00;">'s/f\/i/fi /g'</span> &gt; eigenvectors.txt
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">" ..done\n"</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">set up a new directory, split files - prepare for parsing</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"..splitting files"</span>
mkdir intensities ; mv born.txt eigenvectors.txt intensities/
<span style="color: #cd0000; font-weight: bold;">cd</span> intensities/
<span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">NBORN_NROWS</span>=BORN_NROWS-1
<span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">NEIG_NROWS</span>=EIG_NROWS-3
<span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">NBORN_STEP</span>=4
<span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">NEIG_STEP</span>=EIG_NIONS+3
tail -n $<span style="color: #cd00cd;">NBORN_NROWS</span> born.txt &gt; temp.born.txt
tail -n $<span style="color: #cd00cd;">NEIG_NROWS</span> eigenvectors.txt &gt; temp.eige.txt
mkdir inputs ; mv born.txt eigenvectors.txt inputs/
split -a 3 -d -l $<span style="color: #cd00cd;">NEIG_STEP</span> temp.eige.txt temp.ei.
split -a 3 -d -l $<span style="color: #cd00cd;">NBORN_STEP</span> temp.born.txt temp.bo.
mkdir temps01 ; mv temp.born.txt temp.eige.txt temps01/
<span style="color: #cd0000; font-weight: bold;">for</span> nu<span style="color: #cd0000; font-weight: bold;"> in</span> <span style="color: #cd00cd;">`seq 1 $EIG_NVIBS`</span> ; <span style="color: #cd0000; font-weight: bold;">do</span>
 <span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">nud</span>=nu-1 ; <span style="color: #cd00cd;">ei</span>=<span style="color: #cd00cd;">`printf "%03u" $nu`</span> ; <span style="color: #cd00cd;">eid</span>=<span style="color: #cd00cd;">`printf "%03u" $nud`</span> ; mv temp.ei.$<span style="color: #cd00cd;">eid</span> eigens.vib.$<span style="color: #cd00cd;">ei</span>
<span style="color: #cd0000; font-weight: bold;">done</span>
<span style="color: #cd0000; font-weight: bold;">for</span> s<span style="color: #cd0000; font-weight: bold;"> in</span> <span style="color: #cd00cd;">`seq 1 $EIG_NIONS`</span> ; <span style="color: #cd0000; font-weight: bold;">do</span>
 <span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">sd</span>=s-1 ; <span style="color: #cd00cd;">bo</span>=<span style="color: #cd00cd;">`printf "%03u" $s`</span> ; <span style="color: #cd00cd;">bod</span>=<span style="color: #cd00cd;">`printf "%03u" $sd`</span> ; mv temp.bo.$<span style="color: #cd00cd;">bod</span> borncs.$<span style="color: #cd00cd;">bo</span>
<span style="color: #cd0000; font-weight: bold;">done</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">" ..done\n"</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">parse deviation vectors (eig)</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"..parsing eigenvectors"</span>
<span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">sad</span>=$<span style="color: #cd00cd;">EIG_NIONS</span>+1
<span style="color: #cd0000; font-weight: bold;">for</span> nu<span style="color: #cd0000; font-weight: bold;"> in</span> <span style="color: #cd00cd;">`seq 1 $EIG_NVIBS`</span> ; <span style="color: #cd0000; font-weight: bold;">do</span>
 <span style="color: #cd00cd;">nuu</span>=<span style="color: #cd00cd;">`printf "%03u" $nu`</span>
 tail -n $<span style="color: #cd00cd;">sad</span> eigens.vib.$<span style="color: #cd00cd;">nuu</span> | head -n $<span style="color: #cd00cd;">EIG_NIONS</span> | awk <span style="color: #00cd00;">'{print $4,$5,$6}'</span> &gt; e.vib.$<span style="color: #cd00cd;">nuu</span>.allions
 split -a 3 -d -l 1 e.vib.$<span style="color: #cd00cd;">nuu</span>.allions temp.e.vib.$<span style="color: #cd00cd;">nuu</span>.ion.
 <span style="color: #cd0000; font-weight: bold;">for</span> s<span style="color: #cd0000; font-weight: bold;"> in</span> <span style="color: #cd00cd;">`seq 1 $EIG_NIONS`</span> ; <span style="color: #cd0000; font-weight: bold;">do</span>
  <span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">sd</span>=s-1; <span style="color: #cd00cd;">bo</span>=<span style="color: #cd00cd;">`printf "%03u" $s`</span>; <span style="color: #cd00cd;">bod</span>=<span style="color: #cd00cd;">`printf "%03u" $sd`</span>; mv temp.e.vib.$<span style="color: #cd00cd;">nuu</span>.ion.$<span style="color: #cd00cd;">bod</span> e.vib.$<span style="color: #cd00cd;">nuu</span>.ion.$<span style="color: #cd00cd;">bo</span>
 <span style="color: #cd0000; font-weight: bold;">done</span>
<span style="color: #cd0000; font-weight: bold;">done</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">" ..done\n"</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">parse born effective charge matrices (born)</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"..parsing eff.charges"</span>
<span style="color: #cd0000; font-weight: bold;">for</span> s<span style="color: #cd0000; font-weight: bold;"> in</span> <span style="color: #cd00cd;">`seq 1 $EIG_NIONS`</span> ; <span style="color: #cd0000; font-weight: bold;">do</span>
 <span style="color: #cd00cd;">ss</span>=<span style="color: #cd00cd;">`printf "%03u" $s`</span>
 awk <span style="color: #00cd00;">'{print $2,$3,$4}'</span> borncs.$<span style="color: #cd00cd;">ss</span> | tail -3 &gt; bornch.$<span style="color: #cd00cd;">ss</span>
<span style="color: #cd0000; font-weight: bold;">done</span>
mkdir temps02 ; mv eigens.* borncs.* temps02/
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">" ..done\n"</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">parse matrices, multiply them and collect squares (giving intensities)</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"..multiplying matrices, summing "</span>
<span style="color: #cd0000; font-weight: bold;">for</span> nu<span style="color: #cd0000; font-weight: bold;"> in</span> <span style="color: #cd00cd;">`seq 1 $EIG_NVIBS`</span> ; <span style="color: #cd0000; font-weight: bold;">do</span>
 <span style="color: #cd00cd;">nuu</span>=<span style="color: #cd00cd;">`printf "%03u" $nu`</span>
 <span style="color: #cd00cd;">int</span>=0.0
 <span style="color: #cd0000; font-weight: bold;">for</span> alpha<span style="color: #cd0000; font-weight: bold;"> in</span> 1 2 3 ;  <span style="color: #cd0000; font-weight: bold;">do</span>            <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">summing over alpha coordinates</span>
  <span style="color: #cd00cd;">sumpol</span>=0.0
  <span style="color: #cd0000; font-weight: bold;">for</span> s<span style="color: #cd0000; font-weight: bold;"> in</span> <span style="color: #cd00cd;">`seq 1 $EIG_NIONS`</span> ; <span style="color: #cd0000; font-weight: bold;">do</span>   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">summing over atoms</span>
   <span style="color: #cd00cd;">ss</span>=<span style="color: #cd00cd;">`printf "%03u" $s`</span>
   awk -v <span style="color: #cd00cd;">a</span>=<span style="color: #00cd00;">"$alpha"</span> <span style="color: #00cd00;">'(NR==a){print}'</span> bornch.$<span style="color: #cd00cd;">ss</span> &gt; z.ion.$<span style="color: #cd00cd;">ss</span>.alpha.$<span style="color: #cd00cd;">alpha</span>
   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">summing over beta coordinates and multiplying Z(s,alpha)*e(s) done by the following awk script</span>
   paste z.ion.$<span style="color: #cd00cd;">ss</span>.alpha.$<span style="color: #cd00cd;">alpha</span>  e.vib.$<span style="color: #cd00cd;">nuu</span>.ion.$<span style="color: #cd00cd;">ss</span> | <span style="color: #00cd00;">\</span>
   awk <span style="color: #00cd00;">'{pol=$1*$4+$2*$5+$3*$6; print $0,"  ",pol}'</span> &gt; matr-vib-${<span style="color: #cd00cd;">nuu</span>}-alpha-${<span style="color: #cd00cd;">alpha</span>}-ion-${<span style="color: #cd00cd;">ss</span>}
  <span style="color: #cd0000; font-weight: bold;">done</span>
  <span style="color: #cd00cd;">sumpol</span>=<span style="color: #cd00cd;">`cat matr-vib-${nuu}-alpha-${alpha}-ion-* | awk '{sum+=$7} END {print sum}'`</span>
  <span style="color: #cd00cd;">int</span>=<span style="color: #cd00cd;">`echo "$int+($sumpol)^2" | sed 's/[eE]/*10^/g' |  bc -l`</span>
 <span style="color: #cd0000; font-weight: bold;">done</span>
 <span style="color: #cd00cd;">freq</span>=<span style="color: #cd00cd;">`awk '(NR==1){print $8}' temps02/eigens.vib.$nuu`</span>
 <span style="color: #cd0000; font-weight: bold;">echo</span> <span style="color: #00cd00;">"$nuu $freq $int"</span>&gt;&gt; exact.res.txt
 <span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"."</span>
<span style="color: #cd0000; font-weight: bold;">done</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">" ..done\n"</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">format results, normalize intensities</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"..normalizing intensities"</span>
<span style="color: #cd00cd;">max</span>=<span style="color: #cd00cd;">`awk '(NR==1){max=$3} $3&gt;=max {max=$3} END {print max}' exact.res.txt`</span>
awk -v <span style="color: #cd00cd;">max</span>=<span style="color: #00cd00;">"$max"</span> <span style="color: #00cd00;">'{printf "%03u %6.1f %5.3f\n",$1,$2,$3/max}'</span> exact.res.txt &gt; results.txt
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">" ..done\n"</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">clean up, display results</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"..finalizing:\n"</span>
mkdir temps03; mv bornch.* e.vib.*.allions temps03/
mkdir temps04; mv z.ion* e.vib.*.ion.* temps04/
mkdir temps05; mv matr-* temps05/
mkdir results; mv *res*txt results/
<span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">NMATRIX</span>=$<span style="color: #cd00cd;">EIG_NVIBS</span>**2
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"%5u atoms found\n%5u vibrations found\n%5u matrices evaluated"</span> <span style="color: #00cd00;">\</span>
       $<span style="color: #cd00cd;">EIG_NIONS</span> $<span style="color: #cd00cd;">EIG_NVIBS</span> $<span style="color: #cd00cd;">NMATRIX</span> &gt; results/statistics.txt
  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">fast switch to clean up all temporary files</span>
  rm -r temps*
cat results/results.txt
</pre>



<pre class="example">..reading OUTCAR ..done
..splitting files ..done
..parsing eigenvectors ..done
..parsing eff.charges ..done
..multiplying matrices, summing ......... ..done
..normalizing intensities ..done
..finalizing:
001 3827.3 0.227
002 3713.0 0.006
003 1587.2 0.312
004  235.5 1.000
005   19.1 0.006
006    2.3 0.000
007   16.6 0.005
008   45.0 0.000
009  136.1 0.345
</pre>



<p>
Note the results above include the rotational and vibrational modes (modes 4-9). The following <a href="http://homepage.univie.ac.at/david.karhanek/downloads.html#Entry02">shell script</a> removes those, and recalculates the intensities. Note that it appears to just remove the last 6 modes and req compute the intensities. It is not obvious that will always be the right way to do it as the order of the eigenvectors is not guaranteed.
</p>



<pre class="src src-sh"><span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">!/bin/</span><span style="color: #cd0000; font-weight: bold;">bash</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">reformat intensities, just normal modes: 3N -&gt; (3N-6)</span>
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">"..reformatting and normalizing intensities"</span>
<span style="color: #cd0000; font-weight: bold;">cd</span> intensities/results/
<span style="color: #cd00cd;">nlns</span>=<span style="color: #cd00cd;">`wc -l exact.res.txt | awk '{print $1}' `</span>; <span style="color: #cd0000; font-weight: bold;">let</span> <span style="color: #cd00cd;">bodylns</span>=nlns-6
head -n $<span style="color: #cd00cd;">bodylns</span> exact.res.txt &gt; temp.reform.res.txt
<span style="color: #cd00cd;">max</span>=<span style="color: #cd00cd;">`awk '(NR==1){max=$3} $3&gt;=max {max=$3} END {print max}' temp.reform.res.txt`</span>
awk -v <span style="color: #cd00cd;">max</span>=<span style="color: #00cd00;">"$max"</span> <span style="color: #00cd00;">'{print $1,$2,$3/max}'</span> temp.reform.res.txt &gt; exact.reform.res.txt
awk -v <span style="color: #cd00cd;">max</span>=<span style="color: #00cd00;">"$max"</span> <span style="color: #00cd00;">'{printf "%03u %6.1f %5.3f\n",$1,$2,$3/max}'</span> temp.reform.res.txt &gt; reform.res.txt
<span style="color: #cd0000; font-weight: bold;">printf</span> <span style="color: #00cd00;">" ..done\n..normal modes:\n"</span>
rm temp.reform.res.txt
cat reform.res.txt
<span style="color: #cd0000; font-weight: bold;">cd</span> ../..
</pre>


<pre class="example">
..reformatting and normalizing intensities ..done
..normal modes:
001 3827.3 0.726
002 3713.0 0.019
003 1587.2 1.000
</pre>


<p>
The interpretation of these results is that the mode at 3713 cm<sup>-1</sup> would be nearly invisible in the IR spectrum. Earlier we interpreted that as the symmetric stretch. In this mode, there is only a small change in the molecule dipole moment, so there is a small IR intensity.
</p>
<p>
See also (<cite>giannozzi:8537</cite>). For HREELS simulations see (<cite>0953-8984-22-26-265006</cite>).
</p>
<p>
The shell script above has been translated to a convenient python function in <TT>jasp</TT>.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/h2o_vib_dfpt'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'mode  Relative intensity'</span>
    <span style="color: #cd0000; font-weight: bold;">for</span> i, intensity <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(calc.get_infrared_intensities()):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:02d}     {1:1.3f}'</span>.format(i, intensity)
</pre>



<pre class="example">mode  Relative intensity
00     0.227
01     0.006
02     0.312
03     1.000
04     0.006
05     0.000
06     0.005
07     0.000
08     0.345
</pre>


</div>

</div>

<div id="outline-container-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Thermochemical properties of molecules</h3>
<div class="outline-text-3" id="text-3-7">


<p>
<TT>ase.thermochemistry</TT> can be used to estimate thermodynamic properties of gases in the ideal gas limit. The module needs as input the geometry, the total energy, the vibrational energies, and some information about the molecular symmetry. We first consider an N<sub>2</sub> molecule.
</p>
<p>
The symmetry numbers are determined by the molecular point group (<cite>springerlink-10.1007/s00214-007-0328-0</cite>). Here is a table of the most common ones.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>Symmetry numbers for common point groups</caption>
<colgroup><col class="left" /><col class="right" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">point group</th><th scope="col" class="right"><img src="ltxpng/dft_48a03aebd52f0148d80be7e65e92ed5793afcca1.png" alt="$\sigma$"/></th><th scope="col" class="left">examples</th></tr>
</thead>
<tbody>
<tr><td class="left">C<sub>1</sub></td><td class="right">1</td><td class="left"></td></tr>
<tr><td class="left">C<sub>s</sub></td><td class="right">1</td><td class="left"></td></tr>
<tr><td class="left">C<sub>2</sub></td><td class="right">2</td><td class="left"></td></tr>
<tr><td class="left">C<sub>2v</sub></td><td class="right">2</td><td class="left">H<sub>2</sub>O</td></tr>
<tr><td class="left">C<sub>3v</sub></td><td class="right">3</td><td class="left">NH<sub>3</sub></td></tr>
<tr><td class="left"><img src="ltxpng/dft_e79867e82df957a75ca2c109414d6ced5e309162.png" alt="$C_{\infty v}$"/></td><td class="right">1</td><td class="left">CO</td></tr>
<tr><td class="left">D<sub>2h</sub></td><td class="right">4</td><td class="left"></td></tr>
<tr><td class="left">D<sub>3h</sub></td><td class="right">6</td><td class="left"></td></tr>
<tr><td class="left">D<sub>5h</sub></td><td class="right">10</td><td class="left"></td></tr>
<tr><td class="left"><img src="ltxpng/dft_2df8e58bced331351a1de451e94e9b11edc83e88.png" alt="$D_{\infty h}$"/></td><td class="right">2</td><td class="left">CO<sub>2</sub>, H<sub>2</sub></td></tr>
<tr><td class="left">D<sub>3d</sub></td><td class="right">6</td><td class="left"></td></tr>
<tr><td class="left">T<sub>d</sub></td><td class="right">12</td><td class="left">CH<sub>4</sub></td></tr>
<tr><td class="left">O<sub>h</sub></td><td class="right">24</td><td class="left"></td></tr>
</tbody>
</table>





<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.structure <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.thermochemistry <span style="color: #cd0000; font-weight: bold;">import</span> IdealGasThermo
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

atoms = molecule(<span style="color: #00cd00;">'N2'</span>)
atoms.set_cell((10,10,10), scale_atoms=<span style="color: #cd0000; font-weight: bold;">False</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">first we relax a molecule</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/n2-relax'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=300,
          ibrion=2,
          nsw=5,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    electronicenergy = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">next, we get vibrational modes</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/n2-vib'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=300,
          ibrion=6,
          nfree=2,
          potim=0.15,
          nsw=1,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
    vib_freq = calc.get_vibrational_frequencies() <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">in cm^1</span>

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">convert wavenumbers to energy</span>
    h = 4.1356675e-15 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">eV*s</span>
    c = 3.0e10 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">cm/s</span>
    vib_energies = [h*c*nu <span style="color: #cd0000; font-weight: bold;">for</span> nu <span style="color: #cd0000; font-weight: bold;">in</span> vib_freq]
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational energies\n===================='</span>
    <span style="color: #cd0000; font-weight: bold;">for</span> i,e <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(vib_energies):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:02d}: {1} eV'</span>.format(i,e)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;"># now we can get some properties. Note we only need one vibrational</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">energy since there is only one mode. This example does not work if</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">you give all the energies because one energy is zero.</span>
thermo = IdealGasThermo(vib_energies=vib_energies[0:0],
                        electronicenergy=electronicenergy, atoms=atoms,
                        geometry=<span style="color: #00cd00;">'linear'</span>, symmetrynumber=2, spin=0)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">temperature in K, pressure in Pa, G in eV</span>
G = thermo.get_free_energy(temperature=298.15, pressure=101325.)
</pre>



<pre class="example">vibrational energies
====================
00: 0.29159234324 eV
01: 0.0169775241059 eV
02: 0.0169775241059 eV
03: 2.853610575e-09 eV
04: 8.68490175e-10 eV
05: 0.0 eV
Enthalpy components at T = 298.15 K:
===============================
E_elec               -16.478 eV
E_ZPE                  0.000 eV
Cv_trans (0-&gt;T)        0.039 eV
Cv_rot (0-&gt;T)          0.026 eV
Cv_vib (0-&gt;T)          0.000 eV
(C_v -&gt; C_p)           0.026 eV
-------------------------------
H                    -16.388 eV
===============================

Entropy components at T = 298.15 K and P = 101325.0 Pa:
=================================================
                           S               T*S
S_trans (1 atm)    0.0015579 eV/K        0.464 eV
S_rot              0.0007870 eV/K        0.235 eV
S_elec             0.0000000 eV/K        0.000 eV
S_vib              0.0000000 eV/K        0.000 eV
S (1 atm -&gt; P)    -0.0000000 eV/K       -0.000 eV
-------------------------------------------------
S                  0.0023449 eV/K        0.699 eV
=================================================

Free energy components at T = 298.15 K and P = 101325.0 Pa:
=======================
    H        -16.388 eV
 -T*S         -0.699 eV
-----------------------
    G        -17.087 eV
=======================
</pre>


<p>
Let us compare this to what is in the <a href="http://webbook.nist.gov/cgi/cbook.cgi?ID=C7727379&amp;Units=SI&amp;Mask=1#Thermo-Gas">Nist webbook</a> via the Shomate equations.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
A = 28.98641
B = 1.853978
C = -9.647459
D = 16.63537
E = 0.000117
F = -8.671914
G = 226.4168
H = 0.0

T = 298.15
t = T/1000.

S = A*np.log(t) + B*t + C*t**2/2 + D*t**3/3 - E/(2*t**2) + G
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'-T*S = {0:1.3f} eV'</span>.format(-T*S/1000/96.4853)
</pre>


<pre class="example">
0.00028578754105
-T*S = -0.592 eV
</pre>


<p>
This is reasonable agreement for the entropy.
</p>
</div>

</div>

<div id="outline-container-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> Molecular reaction energies</h3>
<div class="outline-text-3" id="text-3-8">


</div>

<div id="outline-container-3-8-1" class="outline-4">
<h4 id="sec-3-8-1"><span class="section-number-4">3.8.1</span> O<sub>2</sub> dissociation</h4>
<div class="outline-text-4" id="text-3-8-1">

<p>The first reaction we consider is a simple dissociation of oxygen molecule into two oxygen atoms: O<sub>2</sub> &rarr; 2O. The dissociation energy is pretty straightforward to define: it is the energy of the products minus the energy of the reactant. <img src="ltxpng/dft_645e253c1fa94762d2eeb9a26aad6606cb096054.png" alt="$D = 2*E_O - E_{O_2}$"/>. It would appear that we simply calculate the energy of an oxygen atom, and the energy of an oxygen molecule and evaluate the formula. Let us do that.
</p>

</div>

<div id="outline-container-3-8-1-1" class="outline-5">
<h5 id="sec-3-8-1-1"><span class="section-number-5">3.8.1.1</span> Simple estimate of O<sub>2</sub> dissociation energy</h5>
<div class="outline-text-5" id="text-3-8-1-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[5,5,5])],
              cell=(10,10,10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now relaxed O2 dimer</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[5,5,5]),
               Atom(<span style="color: #00cd00;">'O'</span>,[6.22, 5,5])],
              cell=(10,10,10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          ibrion=2,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O2 = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O2 = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">None</span> <span style="color: #cd0000; font-weight: bold;">not</span> <span style="color: #cd0000; font-weight: bold;">in</span> (E_O, E_O2):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'O2 -&gt; 2O  D = {0:1.3f} eV'</span>.format(2*E_O - E_O2)
</pre>


<pre class="example">
O2 -&gt; 2O  D = 8.521 eV
</pre>


<p>
The answer we have obtained is way too high! Experimentally the dissociation energy is about 5.2 eV (need reference), which is <b>very</b> different than what we calculated! Let us consider some factors that contribute to this error.
</p>
<p>
We implicitly neglected spin-polarization in the example above. That could be a problem, since the O<sub>2</sub> molecule can be in one of two spin states, a singlet or a triplet, and these should have different energies. Furthermore, the oxygen atom can be a singlet or a triplet, and these would have different energies. To account for spin polarization, we have to tell VASP to use spin-polarization, and give initial guesses for the magnetic moments of the atoms. Let us try again with spin polarization.
</p>
</div>

</div>

<div id="outline-container-3-8-1-2" class="outline-5">
<h5 id="sec-3-8-1-2"><span class="section-number-5">3.8.1.2</span> Estimating O<sub>2</sub> dissociation energy with spin polarization in triplet ground states</h5>
<div class="outline-text-5" id="text-3-8-1-2">

<p>To tell VASP to use spin-polarization we use <a href=http://cms.mpi.univie.ac.at/wiki/index.php/ISPIN>ISPIN</a>=2, and we set initial guesses for magnetic moments on the atoms with the magmom keyword. In a triplet state there are two electrons with spins of the same sign.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [5, 5, 5], magmom=2)],
              cell=(10, 10, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-sp-triplet'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Magnetic moment on O = {0} Bohr magnetons'</span>.format(atoms.get_magnetic_moment())

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now relaxed O2 dimer</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [5,    5, 5], magmom=1),
               Atom(<span style="color: #00cd00;">'O'</span>, [6.22, 5, 5], magmom=1)],
              cell=(10,10,10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          ispin=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn spin-polarization on</span>
          ibrion=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make sure we relax the geometry</span>
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O2 = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O2 = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">verify magnetic moment</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Magnetic moment on O2 = {0} Bohr magnetons'</span>.format(atoms.get_magnetic_moment())

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">None</span> <span style="color: #cd0000; font-weight: bold;">not</span> <span style="color: #cd0000; font-weight: bold;">in</span> (E_O, E_O2):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'O2 -&gt; 2O  D = {0:1.3f} eV'</span>.format(2*E_O - E_O2)
</pre>


<pre class="example">
Magnetic moment on O = 2.0000072 Bohr magnetons
Magnetic moment on O2 = 2.0000083 Bohr magnetons
O2 -&gt; 2O  D = 6.668 eV
</pre>


<p>
This is much closer to accepted literature values for the DFT-GGA O<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/> dissociation energy. It is still more than 1 eV above an experimental value, but most of that error is due to the GGA exchange correlation functional. Some additional parameters that might need to be checked for convergence are the SIGMA value (it is probably too high for a molecule), as well as the cutoff energy. Oxygen is a "hard" atom that requires a high cutoff energy to achieve high levels of convergence.
</p>
<p>
TODO: show what "hard or soft" is in the pseudopotential.
</p>
<ul>
<li id="sec-3-8-1-2-1">Looking at the two spin densities<br/>
In a spin-polarized calculation there are actually two electron densities: one for spin-up and one for spin-down. We will look at the differences in these two through the density of states.




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.dft.dos <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    dos = DOS(calc, width=0.2)
    d_up = dos.get_dos(spin=0)
    d_down = dos.get_dos(spin=1)
    e = dos.get_energies()

ind = e &lt;= 0.0
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">integrate up to 0eV</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'number of up states = {0}'</span>.format(np.trapz(d_up[ind], e[ind]))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'number of down states = {0}'</span>.format(np.trapz(d_down[ind], e[ind]))

<span style="color: #cd0000; font-weight: bold;">import</span> pylab <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(e, d_up,
         e, -d_down)
plt.xlabel(<span style="color: #00cd00;">'energy [eV]'</span>)
plt.ylabel(<span style="color: #00cd00;">'DOS'</span>)
plt.legend([<span style="color: #00cd00;">'up'</span>, <span style="color: #00cd00;">'down'</span>])
plt.savefig(<span style="color: #00cd00;">'images/O2-sp-dos.png'</span>)
</pre>


<pre class="example">
number of up states = 7.00000343617
number of down states = 5.00001715094
</pre>



<div class="figure">
<p><img src="./images/O2-sp-dos.png"  alt="./images/O2-sp-dos.png" /></p>
<p>Spin-polarized DOS for the O<sub>2</sub> molecule. \label{fig:o2-sp-dos}</p>
</div>

<p>
You can see in Figure ref:ref:fig:o2-sp-dos that there are two different densities of states for the two spins. One has 7 electrons in it (the blue lines), and the other has 5 electrons in it (the green line). The difference of two electrons leads to the magnetic moment of 2 which we calculated earlier. Remember that only peaks in the DOS below the Fermi level are occupied. It is customary to set the Fermi level to 0 eV in DOS plots. The peaks roughly correspond to electrons. For example, the blue peak between -25 and -30 eV corresponds to one electron, in a 1s orbital, where as the blue peak between -5 and -10 eV corresponds to three electrons.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-3-8-1-3" class="outline-5">
<h5 id="sec-3-8-1-3"><span class="section-number-5">3.8.1.3</span> Convergence study of the O<sub>2</sub> dissociation energy</h5>
<div class="outline-text-5" id="text-3-8-1-3">





<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
encuts = [250, 300, 350, 400, 450, 500, 550]

D = []
<span style="color: #cd0000; font-weight: bold;">for</span> encut <span style="color: #cd0000; font-weight: bold;">in</span> encuts:
    atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [5, 5, 5], magmom=2)],
                   cell=(10,10,10))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-sp-triplet-{0}'</span>.format(encut),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=encut,
              ismear=0,
              ispin=2,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            E_O = atoms.get_potential_energy()
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            E_O = <span style="color: #cd0000; font-weight: bold;">None</span>

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now relaxed O2 dimer</span>
    atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [5,    5, 5], magmom=1),
                   Atom(<span style="color: #00cd00;">'O'</span>, [6.22, 5, 5], magmom=1)],
              cell=(10,10,10))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-{0}'</span>.format(encut),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=encut,
              ismear=0,
              ispin=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn spin-polarization on</span>
              ibrion=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this turns relaxation on</span>
              nsw=10,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            E_O2 = atoms.get_potential_energy()
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            E_O2 = <span style="color: #cd0000; font-weight: bold;">None</span>

    <span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">None</span> <span style="color: #cd0000; font-weight: bold;">not</span> <span style="color: #cd0000; font-weight: bold;">in</span> (E_O, E_O2):
        d = 2*E_O - E_O2
        D.append(d)
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'O2 -&gt; 2O encut = {0}  D = {1:1.3f} eV'</span>.format(encut, d)

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(encuts, D)
plt.xlabel(<span style="color: #00cd00;">'ENCUT (eV)'</span>)
plt.ylabel(<span style="color: #00cd00;">'O$_2$ dissociation energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/O2-dissociation-convergence.png'</span>)
</pre>


<pre class="example">
O2 -&gt; 2O encut = 250  D = 6.696 eV
O2 -&gt; 2O encut = 300  D = 6.727 eV
O2 -&gt; 2O encut = 350  D = 6.708 eV
O2 -&gt; 2O encut = 400  D = 6.668 eV
O2 -&gt; 2O encut = 450  D = 6.650 eV
O2 -&gt; 2O encut = 500  D = 6.648 eV
O2 -&gt; 2O encut = 550  D = 6.650 eV
</pre>



<div class="figure">
<p><img src="./images/O2-dissociation-convergence.png"  alt="./images/O2-dissociation-convergence.png" /></p>
<p>Convergence study of the O<sub>2</sub> dissociation energy as a function of ENCUT. \label{fig:o2-encut}</p>
</div>

<p>
Based on these results (Figure ref:ref:fig:o2-encut), you could argue the dissociation energy is converged to about 2 meV at a planewave cutoff of 450 eV, and within 50 meV at 350 eV cutoff. You have to decide what an appropriate level of convergence is. Note that increasing the planewave cutoff significantly increases the computational time, so you are balancing level of convergence with computational speed. It would appear that planewave cutoff is not the cause for the discrepancy between our calculations and literature values.
</p>



<pre class="src src-python">encuts = [250, 300, 350, 400, 450, 500, 550]
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'encut (eV)            Total CPU time'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'--------------------------------------------------------'</span>

<span style="color: #cd0000; font-weight: bold;">for</span> encut <span style="color: #cd0000; font-weight: bold;">in</span> encuts:
    OUTCAR = <span style="color: #00cd00;">'molecules/O2-sp-triplet-{0}/OUTCAR'</span>.format(encut)
    f = <span style="color: #cd0000; font-weight: bold;">open</span>(OUTCAR, <span style="color: #00cd00;">'r'</span>)
    <span style="color: #cd0000; font-weight: bold;">for</span> line <span style="color: #cd0000; font-weight: bold;">in</span> f:
        <span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #00cd00;">'Total CPU time used (sec)'</span> <span style="color: #cd0000; font-weight: bold;">in</span> line:
            <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0} eV: {1}'</span>.format(encut, line)
    f.close()
</pre>



<pre class="example">250:                   Total CPU time used (sec):       67.926

300:                   Total CPU time used (sec):      121.296

350:                   Total CPU time used (sec):      150.808

400:                   Total CPU time used (sec):      166.956

450:                   Total CPU time used (sec):      199.381

500:                   Total CPU time used (sec):      240.705

550:                   Total CPU time used (sec):      266.318

</pre>


</div>

</div>

<div id="outline-container-3-8-1-4" class="outline-5">
<h5 id="sec-3-8-1-4"><span class="section-number-5">3.8.1.4</span> Illustration of the effect of SIGMA</h5>
<div class="outline-text-5" id="text-3-8-1-4">


<p>
The methodology for extrapolation of the total energy to absolute zero is
only valid for a continuous density of states at the Fermi level
(<cite>Kresse199615</cite>). Consequently, it should not be used for
semiconductors, molecules or atoms. In VASP, this means a very small
Fermi temperature (SIGMA) should be used.  The O<sub>2</sub> dissociation energy
as a function of SIGMA is shown in Figure
ref:ref:fig:sigma-o2-diss. A variation of nearly 0.2 eV is seen from the
default Fermi temperature of <img src="ltxpng/dft_901b5b83ddadb7b58e571d0a1718b425e1f5ba20.png" alt="$k_bT=0.2$"/> eV and the value of
<img src="ltxpng/dft_6b0c11192ad12ab9dcfd2543ab6b7b23907abf1d.png" alt="$k_bT=0.0001$"/> eV. However, virtually no change was observed for a
hydrogen atom or molecule or for an oxygen molecule as a function of
the Fermi temperature. It is recommended that the total energy be
calculated at several values of the Fermi temperature to make sure the
total energy is converged with respect to the Fermi temperature.
</p>
<p>
We were not careful in selecting a good value for <a href=http://cms.mpi.univie.ac.at/wiki/index.php/SIGMA>SIGMA</a> in the calculations above. The default value of SIGMA is 0.2, which may be fine for metals, but it is not correct for molecules. SIGMA is the broadening factor used to smear the electronic density of states at the Fermi level. For a metal with a continuous density of states this is appropriate, but for molecules with discrete energy states it does not make sense. We are somewhat forced to use the machinery designed for metals on molecules. The solution is to use a very small SIGMA. Ideally you would use SIGMA=0, but that is not practical for convergence reasons, so we try to find what is small enough. Let us examine the effect of SIGMA on the dissociation energy here.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

sigmas = [0.2, 0.1, 0.05, 0.02, 0.01, 0.001]

D = []
<span style="color: #cd0000; font-weight: bold;">for</span> sigma <span style="color: #cd0000; font-weight: bold;">in</span> sigmas:
    atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[5, 5, 5], magmom=2)],
                   cell=(10,10,10))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-sp-triplet-sigma-{0}'</span>.format(sigma),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=400,
              ismear=0,
              sigma=sigma,
              ispin=2,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            E_O = atoms.get_potential_energy()
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            E_O = <span style="color: #cd0000; font-weight: bold;">None</span>

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now relaxed O2 dimer</span>
    atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[5,    5, 5],magmom=1),
                   Atom(<span style="color: #00cd00;">'O'</span>,[6.22, 5, 5],magmom=1)],
              cell=(10,10,10))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-sigma-{0}'</span>.format(sigma),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=400,
              ismear=0,
              sigma=sigma,
              ispin=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn spin-polarization on</span>
              ibrion=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make sure we relax the geometry</span>
              nsw=10,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            E_O2 = atoms.get_potential_energy()
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            E_O2 = <span style="color: #cd0000; font-weight: bold;">None</span>

    <span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">None</span> <span style="color: #cd0000; font-weight: bold;">not</span> <span style="color: #cd0000; font-weight: bold;">in</span> (E_O, E_O2):
        d = 2*E_O - E_O2
        D.append(d)
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'O2 -&gt; 2O sigma = {0}  D = {1:1.3f} eV'</span>.format(sigma, d)

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(sigmas, D, <span style="color: #00cd00;">'bo-'</span>)
plt.xlabel(<span style="color: #00cd00;">'SIGMA (eV)'</span>)
plt.ylabel(<span style="color: #00cd00;">'O$_2$ dissociation energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/O2-dissociation-sigma-convergence.png'</span>)
</pre>


<pre class="example">
O2 -&gt; 2O sigma = 0.2  D = 6.668 eV
O2 -&gt; 2O sigma = 0.1  D = 6.746 eV
O2 -&gt; 2O sigma = 0.05  D = 6.784 eV
O2 -&gt; 2O sigma = 0.02  D = 6.807 eV
O2 -&gt; 2O sigma = 0.01  D = 6.815 eV
O2 -&gt; 2O sigma = 0.001  D = 6.822 eV
</pre>



<div class="figure">
<p><img src="./images/O2-dissociation-sigma-convergence.png"  alt="./images/O2-dissociation-sigma-convergence.png" /></p>
<p>Effect of SIGMA on the oxygen dissociation energy. \label{fig:sigma-o2-diss}</p>
</div>

<p>
Clearly SIGMA has an effect, but it does not move the dissociation energy closer to the literature values!
</p>
</div>

</div>

<div id="outline-container-3-8-1-5" class="outline-5">
<h5 id="sec-3-8-1-5"><span class="section-number-5">3.8.1.5</span> Estimating triplet oxygen dissociation energy with low symmetry</h5>
<div class="outline-text-5" id="text-3-8-1-5">

<p>It has been suggested that breaking spherical symmetry of the atom can result in lower energy of the atom. The symmetry is broken by putting the atom off-center in a box. We will examine the total energy of an oxygen atom in a few geometries. First, let us consider variations of a square box.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">square box origin</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[0, 0, 0], magmom=2)],
              cell=(10, 10, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-square-box-origin'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          sigma=0.01,
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Square box (origin): E = {0} eV'</span>.format(atoms.get_potential_energy())
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">square box center</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [5, 5, 5], magmom=2)],
              cell=(10, 10, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-square-box-center'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          sigma=0.01,
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Square box (center): E = {0} eV'</span>.format(atoms.get_potential_energy())
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">square box random</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [2.13, 7.32, 1.11], magmom=2)],
              cell=(10, 10, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-square-box-random'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          sigma=0.01,
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Square box (random): E = {0} eV'</span>.format(atoms.get_potential_energy())
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        <span style="color: #cd0000; font-weight: bold;">pass</span>
</pre>


<pre class="example">
Square box (origin): E = -1.516623 eV
Square box (center): E = -1.516623 eV
Square box (random): E = -1.515359 eV
</pre>


<p>
There is no significant difference in these energies. The origin and center calculations are identical in energy. The meV variation in the random calculation is negligible. Now, let us consider some non-square boxes.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">calculate O atom energy in orthorhombic boxes</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">orthorhombic box origin</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [0, 0, 0], magmom=2)],
              cell=(8, 9, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-orthorhombic-box-origin'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          sigma=0.01,
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Orthorhombic box (origin): E = {0} eV'</span>.format(atoms.get_potential_energy())
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">orthrhombic box center</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[4, 4.5, 5],magmom=2)],
              cell=(8,9,10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-orthorhombic-box-center'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          sigma=0.01,
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Orthorhombic box (center): E = {0} eV'</span>.format(atoms.get_potential_energy())
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">orthorhombic box random</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[2.13, 7.32, 1.11], magmom=2)],
              cell=(8, 9, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-orthorhombic-box-random'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          sigma=0.01,
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Orthorhombic box (random): E = {0} eV'</span>.format(atoms.get_potential_energy())
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        <span style="color: #cd0000; font-weight: bold;">pass</span>

</pre>


<pre class="example">
Orthorhombic box (origin): E = -1.8941 eV
Orthorhombic box (center): E = -1.894124 eV
Orthorhombic box (random): E = -1.494285 eV
</pre>


<p>
This is a surprisingly large difference in energy! Nearly 0.4 eV. This is precisely the amount of energy we were in disagreement with the literature values. Surprisingly, the "random" position is higher in energy, similar to the cubic boxes. Finally, we put this all together. We use a non-symmetric box for the O-atom.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[5.1, 4.2, 6.1], magmom=2)],
              cell=(8, 9, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-sp-triplet-lowsym'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          sigma=0.01,
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O = atoms.get_potential_energy()
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Magnetic moment on O = {0} Bohr  magnetons'</span>.format(atoms.get_magnetic_moment())
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now relaxed O2 dimer</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [5,    5, 5], magmom=1),
               Atom(<span style="color: #00cd00;">'O'</span>, [6.22, 5, 5], magmom=1)],
              cell=(10, 10, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          sigma=0.01,
          ispin=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn spin-polarization on</span>
          ibrion=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make sure we relax the geometry</span>
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O2 = atoms.get_potential_energy()
        <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">verify magnetic moment</span>
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Magnetic moment on O2 = {0} Bohr magnetons'</span>.format(atoms.get_magnetic_moment())

    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O2 = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">None</span> <span style="color: #cd0000; font-weight: bold;">not</span> <span style="color: #cd0000; font-weight: bold;">in</span> (E_O, E_O2):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'E_O: '</span>,E_O
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'O2 -&gt; 2O  D = {0:1.3f} eV'</span>.format(2*E_O - E_O2)
</pre>


<pre class="example">
Magnetic moment on O = 2.0000016 Bohr  magnetons
Magnetic moment on O2 = 2.0000083 Bohr magnetons
E_O:  -1.893571
O2 -&gt; 2O  D = 6.061 eV
</pre>


<p>
This actually agrees within 30-50 meV of reported literature values, although still nearly an eV greater than the experimental dissociation energy. Note that with a different "random" position, we get the lower energy for the O atom. All the disagreement we had been seeing was apparently in the O atom energy. So, if you do not need the dissociation energy in your analysis, you will not see the error. Also note that this error is specific to there being a spherical atom in a symmetric cell. This is not a problem for most molecules, which are generally non-spherical.
</p>
</div>

</div>

<div id="outline-container-3-8-1-6" class="outline-5">
<h5 id="sec-3-8-1-6"><span class="section-number-5">3.8.1.6</span> Estimating singlet oxygen dissociation energy</h5>
<div class="outline-text-5" id="text-3-8-1-6">

<p>Finally, let us consider the case where each species is in the singlet state.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [5, 5, 5], magmom=0)],
              cell=(10, 10, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-sp-singlet'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Magnetic moment on O = {0} Bohr magnetons'</span>.format(atoms.get_magnetic_moment())

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now relaxed O2 dimer</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [5,   5, 5], magmom=1),
               Atom(<span style="color: #00cd00;">'O'</span>,[6.22, 5, 5], magmom=-1)],
              cell=(10, 10, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-singlet'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=400,
          ismear=0,
          ispin=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn spin-polarization on</span>
          ibrion=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make sure we relax the geometry</span>
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O2 = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O2 = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">verify magnetic moment</span>
<span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_magnetic_moment()

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">None</span> <span style="color: #cd0000; font-weight: bold;">not</span> <span style="color: #cd0000; font-weight: bold;">in</span> (E_O, E_O2):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'O2 -&gt; 2O  D = {0:1.3f} eV'</span>.format(2*E_O - E_O2)
</pre>


<pre class="example">
Magnetic moment on O = 1.9998232 Bohr magnetons
0.0
O2 -&gt; 2O  D = 5.650 eV
</pre>


<p>
Interestingly, VASP still found a triplet spin state on the oxygen atom, even though we guessed an initial magnetic moment of 0. This highlights a difficulty in computing magnetic moments: you provide an initial guess and a solution is found. The magnetic moment of a singlet state is zero, so the  molecule is correct. Also interesting is that the dissociation energy is almost equal to the experimental value. This is probably a coincidence, and may reflect the fact that the singlet oxygen state is less stable than the triplet state. Let us directly compare their total energies:
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-singlet'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'singlet: {0} eV'</span>.format(calc.get_atoms().get_potential_energy())

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'triplet: {0} eV'</span>.format(calc.get_atoms().get_potential_energy())
</pre>


<pre class="example">
singlet:  -8.830101
triplet:  -9.848238
</pre>


<p>
You can see here the triplet state has an energy that is 1 eV more stable than the singlet state.
</p>
</div>

</div>

<div id="outline-container-3-8-1-7" class="outline-5">
<h5 id="sec-3-8-1-7"><span class="section-number-5">3.8.1.7</span> Verifying the magnetic moments on each atom</h5>
<div class="outline-text-5" id="text-3-8-1-7">

<p>It is one thing to see the total magnetic moment of a singlet state, and another to ask what are the magnetic moments on each atom. In VASP you must use <a href=http://cms.mpi.univie.ac.at/wiki/index.php/LORBIT>LORBIT</a>=11 to get the magnetic moments of the atoms written out.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-singlet'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'molecules/O2-sp-singlet-magmoms'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-singlet-magmoms'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set(lorbit=11)
    atoms = calc.get_atoms()
    magmoms = atoms.get_magnetic_moments()

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'singlet ground state'</span>
    <span style="color: #cd0000; font-weight: bold;">for</span> i,atom <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(atoms):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'atom {0}: magmom = {1}'</span>.format(i, magmoms[i])
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_magnetic_moment()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'molecules/O2-sp-triplet-magmoms'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-magmoms'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set(lorbit=11)
    atoms = calc.get_atoms()
    magmoms = atoms.get_magnetic_moments()
    <span style="color: #cd0000; font-weight: bold;">print</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'triplet ground state'</span>
    <span style="color: #cd0000; font-weight: bold;">for</span> i,atom <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(atoms):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'atom {0}: magmom = {1}'</span>.format(i, magmoms[i])
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_magnetic_moment()
</pre>


<pre class="example">
singlet ground state
atom 0: magmom = 0.0
atom 1: magmom = 0.0
0.0

triplet ground state
atom 0: magmom = 0.815
atom 1: magmom = 0.815
2.0000084
</pre>


<p>
Note the atomic magnetic moments do not add up to the total magnetic moment. The atomic magnetic moments are not really true observable properties. The moments are determined by a projection method that probably involves a spherical orbital, so the moments may be over or underestimated.
</p>
</div>

</div>

<div id="outline-container-3-8-1-8" class="outline-5">
<h5 id="sec-3-8-1-8"><span class="section-number-5">3.8.1.8</span> Using a different potential</h5>
<div class="outline-text-5" id="text-3-8-1-8">

<p>It is possible we need a higher quality potential to get the 6.02 eV value quoted by many in the literature. Here we try the O_sv potential, which treats the 1s electrons as valence electrons. Note however, the ENMIN in the POTCAR is very high!
</p>



<pre class="src src-sh">grep ENMIN $<span style="color: #cd00cd;">VASP_PP_PATH</span>/potpaw_PBE/O_sv/POTCAR
</pre>


<pre class="example">
ENMAX  = 1421.493; ENMIN  = 1066.119 eV
</pre>


<p>
In the following calculation, we let VASP select an appropriate ENCUT value.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [4, 4.5, 5], magmom=2)],
              cell=(8, 9, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O-sp-triplet-lowsym-sv'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          ismear=0,
          ispin=2,
          sigma=0.01,
          setups={<span style="color: #00cd00;">'O'</span>:<span style="color: #00cd00;">'_sv'</span>},
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Magnetic moment on O = {0} Bohr magnetons'</span>.format(atoms.get_magnetic_moment())

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now relaxed O2 dimer</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>, [5,    5, 5], magmom=1),
               Atom(<span style="color: #00cd00;">'O'</span>, [6.22, 5, 5], magmom=1)],
              cell=(10, 10, 10))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-sv'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          ismear=0,
          sigma=0.01,
          ispin=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn spin-polarization on</span>
          ibrion=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make sure we relax the geometry</span>
          nsw=10,
          setups={<span style="color: #00cd00;">'O'</span>:<span style="color: #00cd00;">'_sv'</span>},
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        E_O2 = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        E_O2 = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">verify magnetic moment</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Magnetic moment on O2 = {0} Bohr magnetons'</span>.format(atoms.get_magnetic_moment())

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">None</span> <span style="color: #cd0000; font-weight: bold;">not</span> <span style="color: #cd0000; font-weight: bold;">in</span> (E_O, E_O2):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'O2 -&gt; 2O  D = {0:1.3f} eV'</span>.format(2*E_O - E_O2)
</pre>


<pre class="example">
Magnetic moment on O = 2.0000001 Bohr magnetons
Magnetic moment on O2 = 1.9999996 Bohr magnetons
O2 -&gt; 2O  D = 6.299 eV
</pre>


<p>
This result is close to other reported values. It is possibly not converged, since we let VASP choose the ENCUT value, and that value is the ENMIN value in the POTCAR. Nevertheless, the point is that a harder potential does not fix the problem of overbinding in the O<sub>2</sub> molecule. That is a fundamental flaw in the GGA exchange-correlation functional.
</p>
</div>
</div>

</div>

<div id="outline-container-3-8-2" class="outline-4">
<h4 id="sec-3-8-2"><span class="section-number-4">3.8.2</span> Water gas shift example</h4>
<div class="outline-text-4" id="text-3-8-2">

<p>We consider calculating the reaction energy of the water-gas shift reaction in this example.
</p>
<p>
CO + H<sub>2</sub>O <img src="ltxpng/dft_04e6ffcd4bf86c23885a694f2adf22768ca345bd.png" alt="$\leftrightharpoons$"/> CO<sub>2</sub> + H<sub>2</sub>
</p>
<p>
We define the reaction energy as the difference in energy between the products and reactants.
</p>
<p>
<img src="ltxpng/dft_c55678efc9bcfc13b5eab3da94a8434c684135fb.png" alt="$\Delta E = E_{CO_2} + E_{H_2} - E_{CO} - E_{H_2O}$"/>
</p>
<p>
For now, we compute this energy simply as the difference in DFT energies. In the next section we will add zero-point energies and compute the energy difference as a function of temperature. For now, we simply need to compute the total energy of each molecule in its equilibrium geometry.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">first we define our molecules. These will automatically be at the coordinates from the G2 database.</span>

CO =  molecule(<span style="color: #00cd00;">'CO'</span>)
CO.set_cell([8, 8, 8], scale_atoms=<span style="color: #cd0000; font-weight: bold;">False</span>)

H2O = molecule(<span style="color: #00cd00;">'H2O'</span>)
H2O.set_cell([8, 8, 8], scale_atoms=<span style="color: #cd0000; font-weight: bold;">False</span>)

CO2 =  molecule(<span style="color: #00cd00;">'CO2'</span>)
CO2.set_cell([8, 8, 8], scale_atoms=<span style="color: #cd0000; font-weight: bold;">False</span>)

H2 = molecule(<span style="color: #00cd00;">'H2'</span>)
H2.set_cell([8, 8, 8], scale_atoms=<span style="color: #cd0000; font-weight: bold;">False</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now the calculators to get the energies</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ismear=0,
          ibrion=2,
          nsw=10,
          atoms=CO) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        eCO = CO.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        eCO = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO2'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ismear=0,
          ibrion=2,
          nsw=10,
          atoms=CO2) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        eCO2 = CO2.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        eCO2 = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ismear=0,
          ibrion=2,
          nsw=10,
          atoms=H2) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        eH2 = H2.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        eH2 = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2O'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ismear=0,
          ibrion=2,
          nsw=10,
          atoms=H2O) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        eH2O = H2O.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        eH2O = <span style="color: #cd0000; font-weight: bold;">None</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">None</span> <span style="color: #cd0000; font-weight: bold;">in</span> (eCO2, eH2, eCO, eH2O):
    <span style="color: #cd0000; font-weight: bold;">pass</span>
<span style="color: #cd0000; font-weight: bold;">else:</span>
    dE = eCO2 + eH2 - eCO - eH2O
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Delta E = {0:1.3f} eV'</span>.format(dE)
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Delta E = {0:1.3f} kcal/mol'</span>.format(dE*23.06035)
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Delta E = {0:1.3f} kJ/mol'</span>.format(dE*96.485)
</pre>


<pre class="example">
\Delta E = -0.720 eV
\Delta E = -16.614 kcal/mol
\Delta E = -69.514 kJ/mol
</pre>


<p>
We <a href="http://matlab.cheme.cmu.edu/2011/12/12/water-gas-shift-equilibria-via-the-nist-webbook/#7">estimated</a> the enthalpy of this reaction at standard conditions to be -41 kJ/mol using data from the NIST webbook, which is a fair bit lower than we calculated here. In the next section we will examine whether additional corrections are needed, such as zero-point and temperature corrections.
</p>
<p>
It is a good idea to verify your calculations and structures are what you expected. Let us print them here. Inspection of these results shows the geometries were all relaxed, i.e., the forces on each atom are less than 0.05 eV/&Aring;.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'**** Calculation summaries'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'***** CO'</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+begin_example'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+end_example'</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'***** CO2'</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO2'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+begin_example'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+end_example'</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'***** H2'</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+begin_example'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+end_example'</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'***** H2O'</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2O'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+begin_example'</span>
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+end_example'</span>
</pre>



</div>

<div id="outline-container-3-8-2-1" class="outline-5">
<h5 id="sec-3-8-2-1"><span class="section-number-5">3.8.2.1</span> Calculation summaries</h5>
<div class="outline-text-5" id="text-3-8-2-1">

<ul>
<li id="sec-3-8-2-1-1">CO<br/>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/molecules/wgs/CO
  converged: True
  Energy = -14.789536 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 8.000  0.000  0.000] 8.000
  a1 [ 0.000  8.000  0.000] 8.000
  a2 [ 0.000  0.000  8.000] 8.000
  a,b,c,alpha,beta,gamma (deg): 8.000 8.000 8.000 90.0 90.0 90.0
  Unit cell volume = 512.000 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
             0.005  0.005  0.005 -0.000 -0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    O   [0.000      0.000      0.490]   0   0.01      T T T
   1    C   [0.000      0.000      7.346]   0   0.01      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 9
        ismear: 0
           nsw: 10
        ibrion: 2
         encut: 350.0
          prec: Normal
          kpts: [1 1 1]
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
C: potpaw_PBE/C/POTCAR (git-hash: 2272d6745da89a3d872983542cef1d18750fc952)
O: potpaw_PBE/O/POTCAR (git-hash: 9a0489b46120b0cad515d935f44b5fbe3a3b1dfa)
</pre>

</li>
</ul>
<ul>
<li id="sec-3-8-2-1-2">CO<sub>2</sub><br/>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/molecules/wgs/CO2
  converged: True
  Energy = -22.959572 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 8.000  0.000  0.000] 8.000
  a1 [ 0.000  8.000  0.000] 8.000
  a2 [ 0.000  0.000  8.000] 8.000
  a,b,c,alpha,beta,gamma (deg): 8.000 8.000 8.000 90.0 90.0 90.0
  Unit cell volume = 512.000 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
             0.009  0.009  0.008 -0.000 -0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    C   [0.000      0.000      0.000]   0   0.00      T T T
   1    O   [0.000      0.000      1.177]   0   0.01      T T T
   2    O   [0.000      0.000      6.823]   0   0.01      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 12
        ismear: 0
           nsw: 10
        ibrion: 2
         encut: 350.0
          prec: Normal
          kpts: [1 1 1]
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
C: potpaw_PBE/C/POTCAR (git-hash: 2272d6745da89a3d872983542cef1d18750fc952)
O: potpaw_PBE/O/POTCAR (git-hash: 9a0489b46120b0cad515d935f44b5fbe3a3b1dfa)
</pre>

</li>
</ul>
<ul>
<li id="sec-3-8-2-1-3">H<sub>2</sub><br/>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/molecules/wgs/H2
  converged: True
  Energy = -6.744001 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 8.000  0.000  0.000] 8.000
  a1 [ 0.000  8.000  0.000] 8.000
  a2 [ 0.000  0.000  8.000] 8.000
  a,b,c,alpha,beta,gamma (deg): 8.000 8.000 8.000 90.0 90.0 90.0
  Unit cell volume = 512.000 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
             0.000  0.000  0.000 -0.000 -0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    H   [0.000      0.000      0.376]   0   0.00      T T T
   1    H   [0.000      0.000      7.624]   0   0.00      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 5
        ismear: 0
           nsw: 10
        ibrion: 2
         encut: 350.0
          prec: Normal
          kpts: [1 1 1]
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
H: potpaw_PBE/H/POTCAR (git-hash: fbc0773b08b32f553234b0b50cc6ad6f5085c816)
</pre>

</li>
</ul>
<ul>
<li id="sec-3-8-2-1-4">H<sub>2</sub>O<br/>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/molecules/wgs/H2O
  converged: True
  Energy = -14.193569 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 8.000  0.000  0.000] 8.000
  a1 [ 0.000  8.000  0.000] 8.000
  a2 [ 0.000  0.000  8.000] 8.000
  a,b,c,alpha,beta,gamma (deg): 8.000 8.000 8.000 90.0 90.0 90.0
  Unit cell volume = 512.000 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
             0.005  0.004  0.005 -0.000 -0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    O   [0.000      0.000      0.122]   0   0.06      T T T
   1    H   [0.000      0.766      7.522]   0   0.04      T T T
   2    H   [0.000      7.234      7.522]   0   0.04      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 8
        ismear: 0
           nsw: 10
        ibrion: 2
         encut: 350.0
          prec: Normal
          kpts: [1 1 1]
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
H: potpaw_PBE/H/POTCAR (git-hash: fbc0773b08b32f553234b0b50cc6ad6f5085c816)
O: potpaw_PBE/O/POTCAR (git-hash: 9a0489b46120b0cad515d935f44b5fbe3a3b1dfa)
</pre>


</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3-8-3" class="outline-4">
<h4 id="sec-3-8-3"><span class="section-number-4">3.8.3</span> Temperature dependent water gas shift equilibrium constant</h4>
<div class="outline-text-4" id="text-3-8-3">

<p>To correct the reaction energy for temperature effects, we must compute the vibrational frequencies of each species, and estimate the temperature dependent contributions to vibrational energy and entropy. We will break these calculations into several pieces. First we do each vibrational calculation. After those are done, we can get the data and construct the thermochemistry objects we need to estimate the reaction energy as a function of temperature (at constant pressure).
</p>

</div>

<div id="outline-container-3-8-3-1" class="outline-5">
<h5 id="sec-3-8-3-1"><span class="section-number-5">3.8.3.1</span> CO vibrations</h5>
<div class="outline-text-5" id="text-3-8-3-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get relaxed geometry</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    CO = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now do the vibrations</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO-vib'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ismear=0,
          ibrion=6,
          nfree=2,
          potim=0.02,
          nsw=1,
          atoms=CO) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
    vib_freq = calc.get_vibrational_frequencies()
    <span style="color: #cd0000; font-weight: bold;">for</span> i,f <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(vib_freq):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:02d}: {1} cm^(-1)'</span>.format(i,f)
</pre>


<pre class="example">
00: 2115.528894 cm^(-1)
01: 60.594878 cm^(-1)
02: 60.594878 cm^(-1)
03: (0.987178+0j) cm^(-1)
04: (17.958586+0j) cm^(-1)
05: (17.958586+0j) cm^(-1)
</pre>


<p>
CO has only one vibrational mode (3N-5 = 6 - 5 = 1). The other 5 modes are 3 translations and 2 rotations.
</p>
</div>

</div>

<div id="outline-container-3-8-3-2" class="outline-5">
<h5 id="sec-3-8-3-2"><span class="section-number-5">3.8.3.2</span> CO<sub>2</sub> vibrations</h5>
<div class="outline-text-5" id="text-3-8-3-2">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get relaxed geometry</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO2'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    CO2 = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now do the vibrations</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO2-vib'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ismear=0,
          ibrion=6,
          nfree=2,
          potim=0.02,
          nsw=1,
          atoms=CO2) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
    vib_freq = calc.get_vibrational_frequencies()
    <span style="color: #cd0000; font-weight: bold;">for</span> i,f <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(vib_freq):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:02d}: {1} cm^(-1)'</span>.format(i,f)
</pre>


<pre class="example">
00: 2352.901285 cm^(-1)
01: 1316.689504 cm^(-1)
02: 635.015913 cm^(-1)
03: 635.015913 cm^(-1)
04: (0.344306+0j) cm^(-1)
05: (1.763867+0j) cm^(-1)
06: (1.763867+0j) cm^(-1)
07: (62.700411+0j) cm^(-1)
08: (62.700411+0j) cm^(-1)
</pre>


<p>
CO<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/> is a linear molecule with 3N-5 = 4 vibrational modes. They are the first four frequencies in the output above.
</p>
</div>

</div>

<div id="outline-container-3-8-3-3" class="outline-5">
<h5 id="sec-3-8-3-3"><span class="section-number-5">3.8.3.3</span> H<sub>2</sub> vibrations</h5>
<div class="outline-text-5" id="text-3-8-3-3">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get relaxed geometry</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    H2 = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now do the vibrations</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2-vib'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ismear=0,
          ibrion=6,
          nfree=2,
          potim=0.02,
          nsw=1,
          atoms=H2) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
    vib_freq = calc.get_vibrational_frequencies()
    <span style="color: #cd0000; font-weight: bold;">for</span> i,f <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(vib_freq):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:02d}: {1} cm^(-1)'</span>.format(i,f)
</pre>


<pre class="example">
00: 4281.917749 cm^(-1)
01: 129.146855 cm^(-1)
02: 129.146855 cm^(-1)
03: 0.0 cm^(-1)
04: 0.0 cm^(-1)
05: (1e-05+0j) cm^(-1)
</pre>


<p>
There is only one frequency of importance (the one at 4281 cm<img src="ltxpng/dft_11271b674b4cad9ea28701e09acf9e8c4b63d32d.png" alt="$^{-1}$"/>) for the linear H<sub>2</sub> molecule.
</p>
</div>

</div>

<div id="outline-container-3-8-3-4" class="outline-5">
<h5 id="sec-3-8-3-4"><span class="section-number-5">3.8.3.4</span> H<sub>2</sub>O vibrations</h5>
<div class="outline-text-5" id="text-3-8-3-4">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get relaxed geometry</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2O'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    H2O = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now do the vibrations</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2O-vib'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ismear=0,
          ibrion=6,
          nfree=2,
          potim=0.02,
          nsw=1,
          atoms=H2O) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
    vib_freq = calc.get_vibrational_frequencies()
    <span style="color: #cd0000; font-weight: bold;">for</span> i,f <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(vib_freq):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:02d}: {1} cm^(-1)'</span>.format(i,f)
</pre>


<pre class="example">
00: 3782.062213 cm^(-1)
01: 3672.1246 cm^(-1)
02: 1586.23055 cm^(-1)
03: 135.82763 cm^(-1)
04: 16.280411 cm^(-1)
05: (0.208582+0j) cm^(-1)
06: (26.297061+0j) cm^(-1)
07: (106.869518+0j) cm^(-1)
08: (131.286732+0j) cm^(-1)
</pre>


<p>
Water has 3N-6 = 3 vibrational modes.
</p>
</div>

</div>

<div id="outline-container-3-8-3-5" class="outline-5">
<h5 id="sec-3-8-3-5"><span class="section-number-5">3.8.3.5</span> <span class="todo TODO">TODO</span> Thermochemistry</h5>
<div class="outline-text-5" id="text-3-8-3-5">

<p>Now we are ready. We have the electronic energies and vibrational frequencies of each species in the reaction.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.thermochemistry <span style="color: #cd0000; font-weight: bold;">import</span> IdealGasThermo
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">first we get the electronic energies</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    CO = calc.get_atoms()
    E_CO = CO.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO2'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    CO2 = calc.get_atoms()
    E_CO2 = CO2.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    H2 = calc.get_atoms()
    E_H2 = H2.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2O'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    H2O = calc.get_atoms()
    E_H2O = H2O.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now we get the vibrational energies</span>
h = 4.1356675e-15 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">eV*s</span>
c = 3.0e10 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">cm/s</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO-vib'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    vib_freq = calc.get_vibrational_frequencies()
    CO_vib_energies = [h*c*nu <span style="color: #cd0000; font-weight: bold;">for</span> nu <span style="color: #cd0000; font-weight: bold;">in</span> vib_freq]

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/CO2-vib'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    vib_freq = calc.get_vibrational_frequencies()
    CO2_vib_energies = [h*c*nu <span style="color: #cd0000; font-weight: bold;">for</span> nu <span style="color: #cd0000; font-weight: bold;">in</span> vib_freq]

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2-vib'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    vib_freq = calc.get_vibrational_frequencies()
    H2_vib_energies = [h*c*nu <span style="color: #cd0000; font-weight: bold;">for</span> nu <span style="color: #cd0000; font-weight: bold;">in</span> vib_freq]

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/wgs/H2O-vib'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    vib_freq = calc.get_vibrational_frequencies()
    H2O_vib_energies = [h*c*nu <span style="color: #cd0000; font-weight: bold;">for</span> nu <span style="color: #cd0000; font-weight: bold;">in</span> vib_freq]

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now we make a thermo object for each molecule</span>
CO_t = IdealGasThermo(vib_energies=CO_vib_energies[0:0],
                      electronicenergy=E_CO, atoms=CO,
                      geometry=<span style="color: #00cd00;">'linear'</span>, symmetrynumber=1,
                      spin=0)

CO2_t = IdealGasThermo(vib_energies=CO2_vib_energies[0:4],
                      electronicenergy=E_CO2, atoms=CO2,
                      geometry=<span style="color: #00cd00;">'linear'</span>, symmetrynumber=2,
                      spin=0)

H2_t = IdealGasThermo(vib_energies=H2_vib_energies[0:0],
                      electronicenergy=E_H2, atoms=H2,
                      geometry=<span style="color: #00cd00;">'linear'</span>, symmetrynumber=2,
                      spin=0)

H2O_t = IdealGasThermo(vib_energies=H2O_vib_energies[0:3],
                      electronicenergy=E_H2O, atoms=H2O,
                      geometry=<span style="color: #00cd00;">'nonlinear'</span>, symmetrynumber=2,
                      spin=0)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now we can compute G_rxn for a range of temperatures from 298 to 1000 K</span>
Trange = np.linspace(298,1000,20) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">K</span>
P = 101325. <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Pa</span>
Grxn = np.array([(CO2_t.get_free_energy(temperature=T, pressure=P)
                  + H2_t.get_free_energy(temperature=T, pressure=P)
                  - H2O_t.get_free_energy(temperature=T, pressure=P)
                  - CO_t.get_free_energy(temperature=T, pressure=P))*96.485 <span style="color: #cd0000; font-weight: bold;">for</span> T <span style="color: #cd0000; font-weight: bold;">in</span> Trange])

Hrxn = np.array([(CO2_t.get_enthalpy(temperature=T)
                  + H2_t.get_enthalpy(temperature=T)
                  - H2O_t.get_enthalpy(temperature=T)
                  - CO_t.get_enthalpy(temperature=T))*96.485 <span style="color: #cd0000; font-weight: bold;">for</span> T <span style="color: #cd0000; font-weight: bold;">in</span> Trange])

plt.plot(Trange, Grxn, <span style="color: #00cd00;">'bo-'</span>,label=<span style="color: #00cd00;">'$\Delta G_{rxn}$'</span>)
plt.plot(Trange, Hrxn, <span style="color: #00cd00;">'ro:'</span>,label=<span style="color: #00cd00;">'$\Delta H_{rxn}$'</span>)
plt.xlabel(<span style="color: #00cd00;">'Temperature (K)'</span>)
plt.ylabel(<span style="color: #00cd00;">'$\Delta G_{rxn}$ (kJ/mol)'</span>)
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/wgs-dG-T.png'</span>)

plt.figure()
R = 8.314e-3 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">gas constant in kJ/mol/K</span>

Keq = np.exp(-Grxn/R/Trange)
plt.plot(Trange, Keq)
plt.ylim([0, 100])
plt.xlabel(<span style="color: #00cd00;">'Temperature (K)'</span>)
plt.ylabel(<span style="color: #00cd00;">'$K_{eq}$'</span>)
plt.savefig(<span style="color: #00cd00;">'images/wgs-Keq.png'</span>)
plt.show()
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/wgs-dG-T.png"  alt="./images/wgs-dG-T.png" /></p>
<p>Thermodynamic energies of the water gas shift reaction as a function of temperature.</p>
</div>
<p>
You can see a few things here. One is that at near 298K, the Gibbs free energy is about -75 kJ/mol. This is too negative compared to the experimental standard free energy, which we estimated to be about -29 kJ/mol from the <a href="http://matlab.cheme.cmu.edu/2011/12/12/water-gas-shift-equilibria-via-the-nist-webbook/#7">NIST webbook. </a>There could be several reasons for this disagreement, but the most likely one is errors in the exchange-correlation functional. The error in energy has a significant effect on the calculated equilibrium constant, significantly overestimating it.
</p>


<div class="figure">
<p><img src="./images/wgs-Keq.png"  alt="./images/wgs-Keq.png" /></p>
<p>Temperature dependence of the equilibrium constant.</p>
</div>


</div>
</div>
</div>

</div>

<div id="outline-container-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> Molecular reaction barriers</h3>
<div class="outline-text-3" id="text-3-9">

<p>We will consider a simple example of the barrier for NH<sub>3</sub> inversion. We have to create an NH<sub>3</sub> molecule in the initial and inverted state (these have exactly the same energy), and then interpolate a band of images. Then, we use the NEB method (<cite>sheppard:134106</cite>) to compute the barrier to inversion. The NEB class of methods are pretty standard, but other algorithms for finding barriers (saddle-points) exist that may be relevant (<cite>olsen:9776</cite>).
</p>

</div>

<div id="outline-container-3-9-1" class="outline-4">
<h4 id="sec-3-9-1"><span class="section-number-4">3.9.1</span> Get initial and final states</h4>
<div class="outline-text-4" id="text-3-9-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">compute initial and final states</span>
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = molecule(<span style="color: #00cd00;">'NH3'</span>)
constraint = FixAtoms(mask=[atom.symbol == <span style="color: #00cd00;">'N'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

Npos = atoms.positions[0]

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">move N to origin</span>
atoms.translate(-Npos)
atoms.set_cell((10, 10, 10), scale_atoms=<span style="color: #cd0000; font-weight: bold;">False</span>)

atoms2 = atoms.copy()
pos2 = atoms2.positions

<span style="color: #cd0000; font-weight: bold;">for</span> i,atom <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(atoms2):
    <span style="color: #cd0000; font-weight: bold;">if</span> atom.symbol == <span style="color: #00cd00;">'H'</span>:
        <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">reflect through z</span>
        pos2[i] *= np.array([1, 1, -1])
atoms2.positions = pos2

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">now move N to center of box</span>
atoms.translate([5, 5, 5])
atoms2.translate([5, 5, 5])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/nh3-initial'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ibrion=1,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        calc.calculate()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/nh3-final'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          ibrion=1,
          nsw=10,
          atoms=atoms2) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">try:</span>
        calc.calculate()
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        <span style="color: #cd0000; font-weight: bold;">pass</span>
</pre>


</div>

</div>

<div id="outline-container-3-9-2" class="outline-4">
<h4 id="sec-3-9-2"><span class="section-number-4">3.9.2</span> Run band calculation</h4>
<div class="outline-text-4" id="text-3-9-2">

<p>Now we do the band calculation. 
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Run NH3 NEB calculations</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.neb <span style="color: #cd0000; font-weight: bold;">import</span> NEB

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/nh3-initial'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/nh3-final'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms2 = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">5 images including endpoints</span>
images = [atoms]
images += [atoms.copy() <span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(3)]
images += [atoms2]

neb = NEB(images)
neb.interpolate()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/nh3-neb'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          ibrion=1,
          nsw=90,
          spring=-5,
          atoms=images) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    images,energies = calc.get_neb()

    calc.plot_neb(show=<span style="color: #cd0000; font-weight: bold;">False</span>)
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.savefig(<span style="color: #00cd00;">'images/nh3-neb.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/nh3-neb.png"  alt="./images/nh3-neb.png" /></p>
<p>Nudged elastic band results for ammonia flipping.</p>
</div>
</div>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Bulk systems</h2>
<div class="outline-text-2" id="text-4">


<p>
See <a href="http://arxiv.org/pdf/1204.2733.pdf">http://arxiv.org/pdf/1204.2733.pdf</a> for a very informative comparison of DFT codes for computing different bulk properties.
</p>

</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Defining and visualizing bulk systems</h3>
<div class="outline-text-3" id="text-4-1">


</div>

<div id="outline-container-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> Built-in functions in ase</h4>
<div class="outline-text-4" id="text-4-1-1">

<p>As with molecules, <TT>ase</TT> provides several helper functions to create bulk structures. We highlight a few of them here. Particularly common ones are:
</p>
<ul>
<li><TT>ase.lattice.cubic.FaceCenteredCubic</TT>
</li>
<li><TT>ase.lattice.cubic.BodyCenteredCubic</TT>
</li>
<li><TT>ase.lattice.hexagonal.Graphite</TT>
</li>
<li><TT>ase.lattice.compounds.NaCl</TT>
</li>
</ul>


<p>
For others, see <a href="https://wiki.fysik.dtu.dk/ase/ase/lattice.html">https://wiki.fysik.dtu.dk/ase/ase/lattice.html</a>
</p>
<p>
We start with a simple example, fcc Ag. By default, <TT>ase</TT> knows Ag is an fcc metal, and knows the experimental lattice constant. We have to specify the directions (vectors along each axis) to get something other than the default output. Here, the default fcc cell contains four atoms.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic

atoms = FaceCenteredCubic(<span style="color: #00cd00;">'Ag'</span>)

write(<span style="color: #00cd00;">'images/Ag-fcc.png'</span>,atoms,show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;">print</span> atoms
</pre>


<pre class="example">
Lattice(symbols='Ag4', positions=..., cell=[4.09, 4.09, 4.09], pbc=[True, True, True])
</pre>



<div class="note">
<p>A <TT>ase.lattice.bravais.Lattice</TT> object is returned! This is practically the same as as an <TT>ase.atoms.Atoms</TT> object.
</p>
</div>


<div class="figure">
<p><img src="./images/Ag-fcc.png"  alt="./images/Ag-fcc.png" /></p>
<p>A simple fcc Ag bulk structure in the primitive unit cell.</p>
</div>

<p>
Here we specify the primitive unit cell, which only has one atom in it.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic

atoms = FaceCenteredCubic(<span style="color: #00cd00;">'Ag'</span>, directions=[[0, 1, 1],
                                            [1, 0, 1],
                                            [1, 1, 0]])

write(<span style="color: #00cd00;">'images/Ag-fcc-primitive.png'</span>,atoms,show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;">print</span> atoms
</pre>


<pre class="example">
Lattice(symbols='Ag', positions=..., cell=[[2.892066735052979, 0.0, 0.0], [1.4460333675264898, 2.5046032619957996, 0.0], [1.4460333675264896, 0.8348677539985997, 2.3613626009855695]], pbc=[True, True, True])
</pre>



<div class="figure">
<p><img src="./images/Ag-fcc-primitive.png"  alt="./images/Ag-fcc-primitive.png" /></p>
<p>A simple fcc Ag bulk structure in the primitive unit cell.</p>
</div>

<p>
We can use these modules to build alloy unit cells. The basic strategy is to create the base unit cell in one element and then selectively change some atoms to different chemical symbols. Here we examine an Ag<sub>3</sub>Pd alloy structure.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic

atoms = FaceCenteredCubic(directions=[[1,0,0],
                                      [0,1,0],
                                      [0,0,1]],
                                      size=(1,1,1),
                                      symbol=<span style="color: #00cd00;">'Ag'</span>,
                                      latticeconstant=4.0)

write(<span style="color: #00cd00;">'images/Ag-bulk.png'</span>,atoms,show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">to make an alloy, we can replace one atom with another kind</span>
atoms[0].symbol = <span style="color: #00cd00;">'Pd'</span>
write(<span style="color: #00cd00;">'images/AgPd-bulk.png'</span>, atoms, show_unit_cell=2)

</pre>


<pre class="example">
None
</pre>




<div class="figure">
<p><img src="./images/Ag-bulk.png"  alt="./images/Ag-bulk.png" /></p>
<p>A simple fcc Ag bulk structure in the traditional unit cell.</p>
</div>


<div class="figure">
<p><img src="./images/AgPd-bulk.png"  alt="./images/AgPd-bulk.png" /></p>
<p>A simple Ag<sub>3</sub>Pd bulk structure.</p>
</div>

<p>
To create a graphite structure we use the following code. Note that we have to specify the lattice constants (taken from <a href="http://www.phy.ohiou.edu/~asmith/NewATOMS/HOPG.pdf">http://www.phy.ohiou.edu/~asmith/NewATOMS/HOPG.pdf</a>) because <TT>ase</TT> has C in the diamond structure by default. We show two views, because the top view does not show the spacing between the layers.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.hexagonal <span style="color: #cd0000; font-weight: bold;">import</span> Graphite
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

atoms = Graphite(<span style="color: #00cd00;">'C'</span>, latticeconstant={<span style="color: #00cd00;">'a'</span>:2.4612, <span style="color: #00cd00;">'c'</span>:6.7079})
write(<span style="color: #00cd00;">'images/graphite.png'</span>, atoms.repeat((2,2,1)),rotation=<span style="color: #00cd00;">'115x'</span>, show_unit_cell=2)
write(<span style="color: #00cd00;">'images/graphite-top.png'</span>, atoms.repeat((2,2,1)), show_unit_cell=2)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/graphite-top.png"  alt="./images/graphite-top.png" /></p>
<p>A top view of graphite.</p>
</div>


<div class="figure">
<p><img src="./images/graphite.png"  alt="./images/graphite.png" /></p>
<p>A side view of graphite.</p>
</div>

<p>
To get a compound, we use the following code. We have to specify the basis atoms to the function generating the compound, and the lattice constant. For NaCl we use the lattice constant at (<a href="http://en.wikipedia.org/wiki/Sodium_chloride">http://en.wikipedia.org/wiki/Sodium_chloride</a>).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.compounds <span style="color: #cd0000; font-weight: bold;">import</span> NaCl
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

atoms = NaCl([<span style="color: #00cd00;">'Na'</span>,<span style="color: #00cd00;">'Cl'</span>], latticeconstant=5.65)
write(<span style="color: #00cd00;">'images/NaCl.png'</span>, atoms, show_unit_cell=2, rotation=<span style="color: #00cd00;">'45x,45y,45z'</span>)
</pre>




<div class="figure">
<p><img src="./images/NaCl.png"  alt="./images/NaCl.png" /></p>
<p>A view of a NaCl crystal structure.</p>
</div>



</div>

<div id="outline-container-4-1-1-1" class="outline-5">
<h5 id="sec-4-1-1-1"><span class="section-number-5">4.1.1.1</span> <TT>ase.spacegroup</TT></h5>
<div class="outline-text-5" id="text-4-1-1-1">

<p>A final alternative to setting up bulk structures is <TT>ase.spacegroup</TT>. This is a concise way to setup structures if you know the following properties of the crystal structure:
</p>
<ol>
<li>Chemical symbols
</li>
<li>Coordinates of the non-equivalent sites in the unit cell
</li>
<li>the spacegroup
</li>
<li>the cell parameters (a, b, c, alpha, beta, gamma)
</li>
</ol>





<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.spacegroup <span style="color: #cd0000; font-weight: bold;">import</span> crystal
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">FCC aluminum</span>
a = 4.05
al = crystal(<span style="color: #00cd00;">'Al'</span>, [(0,0,0)], spacegroup=225, cellpar=[a, a, a, 90, 90, 90])
<span style="color: #cd0000; font-weight: bold;">print</span> al
</pre>


<pre class="example">
Atoms(symbols='Al4', positions=..., cell=[[4.05, 0.0, 0.0], [2.4799097682733903e-16, 4.05, 0.0], [2.4799097682733903e-16, 2.4799097682733903e-16, 4.05]], pbc=[True, True, True])
</pre>


<p>
Here is rutile TiO<sub>2</sub>.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.spacegroup <span style="color: #cd0000; font-weight: bold;">import</span> crystal

a = 4.6
c = 2.95
rutile =crystal([<span style="color: #00cd00;">'Ti'</span>, <span style="color: #00cd00;">'O'</span>], basis=[(0, 0, 0), (0.3, 0.3, 0.0)],
                spacegroup=136, cellpar=[a, a, c, 90, 90, 90])
</pre>

</div>
</div>

</div>

<div id="outline-container-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> Using <a href="http://materialsproject.org">http://materialsproject.org</a></h4>
<div class="outline-text-4" id="text-4-1-2">

<p>    The <a href="http://www.materialsproject.org/">Materials Project</a> offers web access to a pretty large number of materials (over 21,000 at the time of this writing), including structure and other computed properties. You must sign up for an account at the website, and then you can access the information. You can search for materials with lots of different criteria including formula, unit cell formula, by elements, by structure, etc&hellip; The website allows you to download the VASP files used to create the calculations. They also develop the <a href="https://github.com/materialsproject/pymatgen/">pymatgen</a> project (which requires python 2.7+).
</p>
<p>
For example, I downloaded this cif file for a RuO<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/> structure (Material ID 825).
</p>


<pre class="src src-text">#\#CIF1.1
##########################################################################
#               Crystallographic Information Format file
#               Produced by PyCifRW module
#
#  This is a CIF file.  CIF has been adopted by the International
#  Union of Crystallography as the standard for data archiving and
#  transmission.
#
#  For information on this file format, follow the CIF links at
#  http://www.iucr.org
##########################################################################

data_RuO2
_symmetry_space_group_name_H-M          'P 1'
_cell_length_a                          3.13970109
_cell_length_b                          4.5436378
_cell_length_c                          4.5436378
_cell_angle_alpha                       90.0
_cell_angle_beta                        90.0
_cell_angle_gamma                       90.0
_chemical_name_systematic               'Generated by pymatgen'
_symmetry_Int_Tables_number             1
_chemical_formula_structural            RuO2
_chemical_formula_sum                   'Ru2 O4'
_cell_volume                            64.8180127062
_cell_formula_units_Z                   2
loop_
  _symmetry_equiv_pos_site_id
  _symmetry_equiv_pos_as_xyz
   1  'x, y, z'

loop_
  _atom_site_type_symbol
  _atom_site_label
  _atom_site_symmetry_multiplicity
  _atom_site_fract_x
  _atom_site_fract_y
  _atom_site_fract_z
  _atom_site_attached_hydrogens
  _atom_site_B_iso_or_equiv
  _atom_site_occupancy
   O  O1  1  0.000000  0.694330  0.694330  0  .  1
   O  O2  1  0.500000  0.805670  0.194330  0  .  1
   O  O3  1  0.000000  0.305670  0.305670  0  .  1
   O  O4  1  0.500000  0.194330  0.805670  0  .  1
   Ru  Ru5  1  0.500000  0.500000  0.500000  0  .  1
   Ru  Ru6  1  0.000000  0.000000  0.000000  0  .  1
</pre>


<p>
We can read this file in with <TT>ase.io.read</TT>. That function automatically recognizes the file type by the extension.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> read, write

atoms = read(<span style="color: #00cd00;">'bulk/Ru2O4_1.cif'</span>)

write(<span style="color: #00cd00;">'images/Ru2O4.png'</span>, atoms, show_unit_cell=2)
</pre>



<div class="figure">
<p><img src="./images/Ru2O4.png"  alt="./images/Ru2O4.png" /></p>
<p>An RuO<sub>2</sub> unit cell prepared from a cif file.</p>
</div>

<p>
You can also download the VASP files. I have copied these files (INCAR, POSCAR, KPOINTS) to a directory (bulk/Ru2O4), and now we can run a calculation like this:
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Ru2O4'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          setups={<span style="color: #00cd00;">'Ru'</span>:<span style="color: #00cd00;">'_pv'</span>}) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
</pre>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/bulk/Ru2O4
  converged: True
  Energy = -44.302690 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 3.137  0.000  0.000] 3.137
  a1 [ 0.000  4.541  0.000] 4.541
  a2 [ 0.000  0.000  4.541] 4.541
  a,b,c,alpha,beta,gamma (deg): 3.137 4.541 4.541 90.0 90.0 90.0
  Unit cell volume = 64.694 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
            -0.002 -0.000 -0.000 -0.000 -0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    Ru  [1.569      2.270      2.270]   0   0.00      T T T
   1    Ru  [0.000      0.000      0.000]   0   0.00      T T T
   2    O   [0.000      3.153      3.153]   0   0.00      T T T
   3    O   [1.569      3.659      0.882]   0   0.00      T T T
   4    O   [0.000      1.388      1.388]   0   0.00      T T T
   5    O   [1.569      0.882      3.659]   0   0.00      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 31
        ismear: 1
          nelm: 100
        nelmin: 3
        icharg: 1
           nsw: 99
        ibrion: 2
          npar: 1
          isif: 3
         encut: 520.0
         sigma: 0.2
         ediff: 0.0003
         lwave: True
        magmom: [0.6, 0.6, 0.6, 0.6, 0.6, 0.6]
          prec: Accurate
          algo: Fast
         lreal: Auto
          kpts: [8, 6, 6]
    reciprocal: False
        setups: {'Ru': '_pv'}
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
Ru: potpaw_PBE/Ru_pv/POTCAR (git-hash: c29610ef9b7bfa353e710b09dfadcd2b0fb0d274)
O: potpaw_PBE/O/POTCAR (git-hash: 9a0489b46120b0cad515d935f44b5fbe3a3b1dfa)
</pre>


<p>
Some notes: we had to specify the PBE functional. That is good habit, since the default may be something else. We also had to specify the special setups used, since those were not defaults either.
</p>
<p>
We get exactly the same result as the website! Why is this helpful then? Well, we could use this as a starting point to look at an equation of state, or to plot some interesting electronic structure, etc&hellip; Or we can gain a little confidence that our version of VASP is working like the one they used.
</p>
</div>
</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Computational parameters that are important for bulk structures</h3>
<div class="outline-text-3" id="text-4-2">


</div>

<div id="outline-container-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> k-point convergence</h4>
<div class="outline-text-4" id="text-4-2-1">

<p>In the section on molecules, we learned that the total energy is a function of the planewave cutoff energy (ENCUT) used. In bulk systems that is true also. There is also another calculation parameter you must consider, the k-point grid. The k-point grid is a computational tool used to approximate integrals of some property, e.g. the electron density, over the entire unit cell. The integration is performed in reciprocal space (i.e. in the Brillouin zone) for convenience and efficiency, and the k-point grid is where the property is sampled for the integration. The higher the number of sampled points, the more accurately the integrals are approximated.
</p>
<p>
We will typically use a Monkhorst-Pack (<cite>PhysRevB.13.5188</cite>) <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-point grid, which is essentially a uniformly spaced grid in the Brillouin zone. Another less commonly used scheme is the Chadi-Cohen k-point grid (<cite>PhysRevB.8.5747</cite>). The Monkhorst-Pack grids are specified as <img src="ltxpng/dft_68a37168a725ba9b1b5e04d11c7324b0c3afad86.png" alt="$n1 \times n2 \times n3$"/> grids, and the total number of k-points is <img src="ltxpng/dft_b47f094d69514811b9276caacde090a876e9247b.png" alt="$n1 \cdot n2 \cdot n3$"/>. The computational cost is linear in the total number of k-points, so  a calculation on a <img src="ltxpng/dft_8dbbec6cb9273542e6de6f91021491c53c7ea7e6.png" alt="$4 \times 4 \times 4$"/> grid will be roughly 8 times more expensive than on a <img src="ltxpng/dft_0a9b0bff90d31a7ffa6d9578ab029077694d60c0.png" alt="$2 \times 2 \times 2$"/> grid. Hence, one seeks again to balance convergence with computational tractability. Below we consider the k-point convergence of fcc Ag.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

atoms = FaceCenteredCubic(<span style="color: #00cd00;">'Ag'</span>)

KPTS = [2, 3, 4, 5, 6, 8, 10]

TE = []

ready = <span style="color: #cd0000; font-weight: bold;">True</span>
<span style="color: #cd0000; font-weight: bold;">for</span> k <span style="color: #cd0000; font-weight: bold;">in</span> KPTS:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Ag-kpts-{0}'</span>.format(k),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              kpts=(k, k, k), <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">specifies the Monkhorst-Pack grid</span>
              encut=300,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            TE.append(atoms.get_potential_energy())
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            ready = <span style="color: #cd0000; font-weight: bold;">False</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">not</span> ready:
    <span style="color: #cd0000; font-weight: bold;">import</span> sys; sys.exit()

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">consider the change in energy from lowest energy state</span>
TE = np.array(TE)
TE -= TE.min()

plt.plot(KPTS, TE)
plt.xlabel(<span style="color: #00cd00;">'number of k-points in each dimension'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total Energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/Ag-kpt-convergence.png'</span>)
plt.show()
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/Ag-kpt-convergence.png"  alt="./images/Ag-kpt-convergence.png" /></p>
<p>k-point convergence of the total energy of fcc Ag.</p>
</div>

<p>
Based on this figure, we need at least a <img src="ltxpng/dft_9ab9877c24fe27e6eddc56b264c30cabef472619.png" alt="$6 \times 6 \times 6$"/> k-point grid to achieve a convergence level of at least 50 meV. Note: the k-point convergence is not always monotonic like it is in this example, and sometimes very dense grids (e.g. up to <img src="ltxpng/dft_efe368afd650420571b2ee9fb7f1182087c7b317.png" alt="$20 \times 20 \times 20$"/>) are needed for highly converged properties such as the density of states in smaller unit cells. Oscillations in the total energy are typical, and it can be difficult to get high levels of convergence. The best practices are to use the same k-point sampling grid in energy differences where possible, and dense (high numbers of k-points) otherwise. It is important to check for convergence in these cases.
</p>
<p>
As unit cells get larger, the number of k-points required becomes smaller. For example, if a <img src="ltxpng/dft_e883d1e2f891aae4799701ccc7ffd5240e0cbcc3.png" alt="$1 \times 1 \times 1$"/> fcc unit cell shows converged energies in a <img src="ltxpng/dft_70c30e77d2763a86ea671198bf4486c4aaeb26f0.png" alt="$12 \times 12 \times 12$"/> k-point grid, then a <img src="ltxpng/dft_0a9b0bff90d31a7ffa6d9578ab029077694d60c0.png" alt="$2 \times 2 \times 2$"/> fcc unit cell would show the same level of convergence with a <img src="ltxpng/dft_9ab9877c24fe27e6eddc56b264c30cabef472619.png" alt="$6 \times 6 \times 6$"/> k-point grid. In other words, doubling the unit cell vectors results in a halving of the number of k-points.
</p>
<p>
Sometimes you may see k-points described as k-points per reciprocal atom. For example, a <img src="ltxpng/dft_70c30e77d2763a86ea671198bf4486c4aaeb26f0.png" alt="$12 \times 12 \times 12$"/> k-point grid for a primitive fcc unit cell would be 1728 k-points per reciprocal atom. A <img src="ltxpng/dft_0a9b0bff90d31a7ffa6d9578ab029077694d60c0.png" alt="$2 \times 2 \times 2$"/> fcc unit cell has eight atoms in it, or 0.125 reciprical atoms, so a <img src="ltxpng/dft_9ab9877c24fe27e6eddc56b264c30cabef472619.png" alt="$6 \times 6 \times 6$"/> k-point grid has 216 k-points in it, or 216/0.125 = 1728 k-points per reciprocal atom, the same as we discussed before.
</p>
<p>
In the k-point convergence example above, we used a <img src="ltxpng/dft_9ab9877c24fe27e6eddc56b264c30cabef472619.png" alt="$6 \times 6 \times 6$"/> k-point grid on a unit cell with four atoms in it, leading to 864 k-points per reciprocal atom. If we had instead used the primitive unit cell, we would need either a <img src="ltxpng/dft_70aff9b11b160352569456ccde1d45bbe05fbe11.png" alt="$9 \times 9 \times 9$"/> or <img src="ltxpng/dft_a35de077e541e004a31ad7d7d02c2f00ea2d62e7.png" alt="$10 \times 10 \times 10$"/> k-point grid to get a similar level of accuracy. In this case, there is no exact matching of k-point grids due to the difference in shape of the cells.
</p>
</div>

</div>

<div id="outline-container-4-2-2" class="outline-4">
<h4 id="sec-4-2-2"><span class="section-number-4">4.2.2</span> Effect of <a href=http://cms.mpi.univie.ac.at/wiki/index.php/SIGMA>SIGMA</a></h4>
<div class="outline-text-4" id="text-4-2-2">




<p>
In the self-consistent cycle  of a DFT calculation, the total energy is minimized with respect to occupation of the Kohn-Sham orbitals. At absolute zero, a band is either occupied or empty. This discrete occupation results in discontinuous changes in energy with changes in occupation, which makes it difficult to converge. One solution is to artificially broaden the band occupancies, as if they were occupied at a higher temperature where partial occupation is possible. This results in a continuous dependence of energy on the partial occupancy, and dramatically increases the rate of convergence. <a href=http://cms.mpi.univie.ac.at/wiki/index.php/SIGMA>SIGMA</a> and <a href=http://cms.mpi.univie.ac.at/wiki/index.php/ISMEAR>ISMEAR</a> affect how the partial occupancies of the bands are determined.
</p>
<p>
Some rules to keep in mind:
</p><ol>
<li>The smearing methods were designed for metals. For molecules, semiconductors and insulators you should use a very small SIGMA (e.g. 0.01).
</li>
<li>Standard values for metallic systems is SIGMA=0.1, but the best SIGMA may be <a href="http://cms.mpi.univie.ac.at/vasp/guide/node159.html">material specific</a>.
</li>
</ol>


<p>
The consequence of this finite temperature is that additional bands
must be included in the calculation to allow for the partially
occupied states above the Fermi level; the number of extra bands depends on
the temperature used.  An example of the maximum occupancies of the
bands for an Al(111) slab as a function of the Fermi temperature is
shown in Figure ref:ref:fig:sigma-occ. Obviously, as the Fermi temperature
approaches 0 K, the occupancy approaches a step function.  It is preferable
that the occupancy of several of the highest bands be zero (or at
least of order <img src="ltxpng/dft_f5702b11b57a4e7a0e84bd2495f0ba0b0d307125.png" alt="$1\times 10^{-8}$"/>) to ensure enough variational freedom was
available in the calculation.  Consequently, it is suggested that fifteen to
twenty extra bands be used for a Fermi temperature of <img src="ltxpng/dft_202f546093b1e9d35c2fcefcaf04cba730133f80.png" alt="$k_bT=0.20$"/> eV, or
that the Fermi temperature be decreased to <img src="ltxpng/dft_7b5a2f17b2805415f45da38feaefc13bbb3ae816.png" alt="$k_bT=0.10$"/> eV. In any case,
it should be determined that enough bands were used by examination of
the occupancies.  It is undesirable to have too many extra bands, as
this will add computational time.
</p>

<p>
Below we show the effect of SIGMA on the band occupancies.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

a = 3.61
atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>, (0, 0, 0))],
              cell=0.5 * a * np.array([[1.0, 1.0, 0.0],
                                       [0.0, 1.0, 1.0],
                                       [1.0, 0.0, 1.0]])).repeat((2,2,2))

SIGMA = [0.001, 0.05, 0.1, 0.2, 0.5]

<span style="color: #cd0000; font-weight: bold;">for</span> sigma <span style="color: #cd0000; font-weight: bold;">in</span> SIGMA:

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu-sigma-{0}'</span>.format(sigma),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=350,
              kpts=(4, 4, 4),
              ismear=-1,
              sigma=sigma,
              nbands=9 * 8,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        e = atoms.get_potential_energy()

        nbands = calc.nbands
        nkpts = <span style="color: #cd0000; font-weight: bold;">len</span>(calc.get_ibz_k_points())

        occ = np.zeros((nkpts, nbands))
        <span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(nkpts):
            occ[i,:] = calc.get_occupation_numbers(kpt=i)

        max_occ = np.max(occ,axis=0) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">axis 0 is columns</span>

        plt.plot(<span style="color: #cd0000; font-weight: bold;">range</span>(nbands), max_occ, label=<span style="color: #00cd00;">'$\sigma = {0}$'</span>.format(sigma))

plt.xlabel(<span style="color: #00cd00;">'band number'</span>)
plt.ylabel(<span style="color: #00cd00;">'maximum occupancy (electrons)'</span>)
plt.ylim([-0.1, 2.1])
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/occ-sigma.png'</span>)
plt.show()
</pre>




<div class="figure">
<p><img src="./images/occ-sigma.png"  alt="./images/occ-sigma.png" /></p>
<p>Effects of SIGMA on the occupancies of the Cu system. \label{fig:sigma-occ}</p>
</div>

</div>

</div>

<div id="outline-container-4-2-3" class="outline-4">
<h4 id="sec-4-2-3"><span class="section-number-4">4.2.3</span> The number of bands</h4>
<div class="outline-text-4" id="text-4-2-3">

<p>In the last figure, it is evident that due to the smearing of the electronic states you need to have extra bands to accommodate the electrons above the Fermi level, and the higher the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/SIGMA>SIGMA</a> value is, the more bands you need. You need enough bands so that the highest energy bands are unoccupied, and VASP will give you a warning that looks like this:
</p>



<pre class="example"> -----------------------------------------------------------------------------
|                                                                             |
|  ADVICE TO THIS USER RUNNING 'VASP/VAMP'   (HEAR YOUR MASTER'S VOICE ...):  |
|                                                                             |
|      Your highest band is occupied at some k-points! Unless you are         |
|      performing a calculation for an insulator or semiconductor, without    |
|      unoccupied bands, you have included TOO FEW BANDS!! Please increase    |
|      the parameter NBANDS in file 'INCAR' to ensure that the highest band   |
|      is unoccupied at all k-points. It is always recommended to             |
|      include a few unoccupied bands to accelerate the convergence of        |
|      molecular dynamics runs (even for insulators or semiconductors).       |
|      Because the presence of unoccupied bands improves wavefunction         |
|      prediction, and helps to suppress 'band-crossings.'                    |
|      Following all k-points will be listed (with the Fermi weights of       |
|      the highest band given in paranthesis) ... :                           |
|                                                                             |
|                          6       (-0.01472)                                 |
|                          8       (-0.01413)                                 |
|                         13       (-0.01733)                                 |
|                         14       (-0.01838)                                 |
|                                                                             |
|      The total occupancy of band no.    49 is  -0.00932 electrons ...       |
|                                                                             |
 -----------------------------------------------------------------------------
</pre>


<p>
We tell VASP the number of bands to use with the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/NBANDS>NBANDS</a> keyword. VASP will set the NBANDS automatically if you do not provide a value, but this is in general bad practice (even though it is often done in this book!). There are a few general guidelines for setting NBANDS. First we recognize that a band can only have two electrons in it (one spin up, and one spin down) in an calculation without spin-polarization, or one electron per band for a spin-polarized calculation (note that spin-polarization doubles the number of bands).  There absolutely must be enough bands to accommodate all the electrons, so the minimum number of bands is int(ceil(nelectrons/2)).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

<span style="color: #cd0000; font-weight: bold;">print</span> int(np.ceil(50/2.))
<span style="color: #cd0000; font-weight: bold;">print</span> int(np.ceil(51/2.))
</pre>


<pre class="example">
25
26
</pre>


<p>
However, due to the smearing, the minimum number of bands is almost never enough, and we always add more bands. The default behavior in VASP is:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">non-spin polarized</td><td class="left">NELECT/2 + NIONS/2</td></tr>
<tr><td class="left">spin-polarized</td><td class="left">0.6*NELECT + NMAGIONS</td></tr>
</tbody>
</table>


<p>
These do not always work, especially for small molecular systems where NIONS/2 may be only 1, or transition metals where it may be necessary to add up to 2*NIONS extra bands.
</p>
<p>
To figure out how many bands you need, it is necessary to know how many electrons are in your calculation. The <TT>jasp.get_valence_electrons</TT> provides this for you. Alternatively, you can look in the <a href="#sec-9-4-6">Appendix</a> for a table listing the number of valence electrons for each POTCAR file. Armed with this information you can set NBANDS the way you want.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,  [0.000,      0.000,      0.000])],
              cell=  [[ 1.818,  0.000,  1.818],
                      [ 1.818,  1.818,  0.000],
                      [ 0.000,  1.818,  1.818]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(13,13,13),
          nbands=9,
          ibrion=2,
          isif=4,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> calc.get_valence_electrons()
</pre>


<pre class="example">
11.0
</pre>


<p>
For this calculation we need at least 6 bands (11/2=5.5 which is rounded up to 6) and we need to include some extra bands. The default rule would only add half a band, which is not enough. We add three additional bands. This system is so small it does not substantially increase the computational cost.
</p>
<p>
If you are too trifling to do that much work, you can use the <TT>jasp.set_nbands</TT> to automatically set the number of bands. This function takes an argument <code>N</code> to set the number of bands to N, <b>or</b> an argument <code>f</code> to set the NBANDS according to the formula <img src="ltxpng/dft_914b6d57fdf69654205d9c9e761b8e226eeda925.png" alt="$nbands = int(nelectrons/2 + len(atoms)*f)$"/>. The default value of <code>f</code> is 1.5. If you want the default VASP behavior, set f=0.5. For transition metals, it may be required that f=2. This function does not consider whether the calculation is spin-polarized or not. Here is an example of using <TT>jasp.set_nbands</TT>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,  [0.000,      0.000,      0.000])],
              cell=  [[ 1.818,  0.000,  1.818],
                      [ 1.818,  1.818,  0.000],
                      [ 0.000,  1.818,  1.818]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(13,13,13),
          ibrion=2,
          isif=4,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> calc.set_nbands(9)
</pre>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,  [0.000,      0.000,      0.000])],
              cell=  [[ 1.818,  0.000,  1.818],
                      [ 1.818,  1.818,  0.000],
                      [ 0.000,  1.818,  1.818]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu-setnbands'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(13,13,13),
          ibrion=2,
          isif=4,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> calc.set_nbands(f=3)
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
</pre>



<pre class="example">None
False
: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/bulk/alloy/cu-setnbands
  converged: None
  Energy = nan eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 1.818  0.000  1.818] 2.571
  a1 [ 1.818  1.818  0.000] 2.571
  a2 [ 0.000  1.818  1.818] 2.571
  a,b,c,alpha,beta,gamma (deg): 2.571 2.571 2.571 60.0 60.0 60.0
  Unit cell volume = 12.017 Ang^3
  Stress was not computed
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    Cu  [0.000      0.000      0.000]   0   nan      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 9
           nsw: 10
        ibrion: 2
          isif: 4
         encut: 350
        magmom: None
          prec: Normal
          kpts: (13, 13, 13)
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
None: None (git-hash: None)
</pre>


<p>
You are, of course, free to use any formula you want to set the number of bands. Some formulas I have used in the past include:
</p>
<ol>
<li>NBANDS = 0.65*NELECT + 10
</li>
<li>NBANDS = 0.5*NELECT + 15
</li>
<li>etc&hellip;
</li>
</ol>


</div>
</div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> Determining bulk structures</h3>
<div class="outline-text-3" id="text-4-3">

<p>What we typically mean by determining bulk structures includes the following:
</p>
<ul>
<li>What is the most stable crystal structure for a material?
</li>
<li>What is the lattice constant of fcc Cu?
</li>
<li>What are the lattice parameters and internal atom parameters for TiO<sub>2</sub>?
</li>
</ul>


<p>
All of these questions can often be addressed by finding the volume, shape and atomic positions that minimize the total energy of a bulk system. This is true at 0K. At higher temperatures, one must consider minimizing the free energy, rather than the internal energy.
</p>

</div>

<div id="outline-container-4-3-1" class="outline-4">
<h4 id="sec-4-3-1"><span class="section-number-4">4.3.1</span> fcc/bcc crystal structures</h4>
<div class="outline-text-4" id="text-4-3-1">


<p>
The fcc and bcc structures are simple. They only have one degree of freedom: the lattice constant. In this section we show how to calculate the equilibrium volume of each structure, and determine which one is more stable. We start with the fcc crystal structure of Cu. We will manually define the crystal structure based on the definitions in Kittel (<cite>kittel</cite>) (Chapter 1).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">fcc</span>
LC = [3.5, 3.55, 3.6, 3.65, 3.7, 3.75]
fcc_energies = []
ready = <span style="color: #cd0000; font-weight: bold;">True</span>
<span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> LC:
    atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,(0, 0, 0))],
              cell=0.5 * a*np.array([[1.0, 1.0, 0.0],
                                     [0.0, 1.0, 1.0],
                                     [1.0, 0.0, 1.0]]))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu-{0}'</span>.format(a),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=350,
              kpts=(8,8,8),
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

        <span style="color: #cd0000; font-weight: bold;">try:</span>
            e = atoms.get_potential_energy()
            fcc_energies.append(e)
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            ready = <span style="color: #cd0000; font-weight: bold;">False</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">not</span> ready:
    <span style="color: #cd0000; font-weight: bold;">import</span> sys; sys.exit()

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(LC, fcc_energies)
plt.xlabel(<span style="color: #00cd00;">'Lattice constant ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/Cu-fcc.png'</span>)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+tblname: cu-fcc-energies'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'| lattice constant ($\AA$) | Total Energy (eV) |'</span>
<span style="color: #cd0000; font-weight: bold;">for</span> lc, e <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">zip</span>(LC,fcc_energies):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'| {0} | {1} |'</span>.format(lc, e)
</pre>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="right" /><col class="right" />
</colgroup>
<tbody>
<tr><td class="right">lattice constant (<img src="ltxpng/dft_36c5db35bec638b7c50d41f52cad55f2c367cb90.png" alt="$\AA$"/>)</td><td class="right">Total Energy (eV)</td></tr>
<tr><td class="right">3.5</td><td class="right">-3.649238</td></tr>
<tr><td class="right">3.55</td><td class="right">-3.696204</td></tr>
<tr><td class="right">3.6</td><td class="right">-3.719946</td></tr>
<tr><td class="right">3.65</td><td class="right">-3.723951</td></tr>
<tr><td class="right">3.7</td><td class="right">-3.711284</td></tr>
<tr><td class="right">3.75</td><td class="right">-3.68426</td></tr>
</tbody>
</table>




<div class="exercise">
<p>Use the data in the table above to plot the total energy as a function of the lattice constant. Fit a cubic polynomial to the data, and find the volume that minimizes the total energy.
</p>
</div>


<div class="figure">
<p><img src="./images/Cu-fcc.png"  alt="./images/Cu-fcc.png" /></p>
<p>Total energy vs. fcc lattice contant for Cu. It appears the minimum is near 3.65 &Aring;.</p>
</div>

<p>
If you want to know the lattice constant that gives the lowest energy, you would fit an <a href="#sec-9-3">equation of state</a> to the data. Here is an example using <TT>ase.utils.eos</TT>.  See also the appendix <a href="#sec-9-3">equations of state</a>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.utils.eos <span style="color: #cd0000; font-weight: bold;">import</span> EquationOfState
LC = [3.5, 3.55, 3.6, 3.65, 3.7, 3.75]
energies = []
volumes = []
<span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> LC:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu-{0}'</span>.format(a)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        volumes.append(atoms.get_volume())
        energies.append(atoms.get_potential_energy())

eos = EquationOfState(volumes,energies)
v0, e0, B = eos.fit()

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">v0 = {0} A^3</span>
<span style="color: #00cd00;">E0 = {1} eV</span>
<span style="color: #00cd00;">B  = {2} eV/A^3'''</span>.format(v0, e0, B)

eos.plot(<span style="color: #00cd00;">'images/Cu-fcc-eos.png'</span>)
</pre>



<pre class="example">

v0 = 12.0167118546 A^3
E0 = -3.7246811445 eV
B  = 0.859009528171 eV/A^3
</pre>





<div class="figure">
<p><img src="./images/Cu-fcc-eos.png"  alt="./images/Cu-fcc-eos.png" /></p>
<p>Total energy vs. volume for fcc Cu with  fitted cubic polynomial equation of state.</p>
</div>


<p>
Before we jump into the bcc calculations, let us consider what range of lattice constants we should choose. The fcc lattice is close-packed, and the volume of the primitive cell is <img src="ltxpng/dft_d7e95b62de875ce212dc4c22c34cecbd21dff0ce.png" alt="$V = 1/4 a^3$"/> or about 11.8 &Aring;<sup>3</sup>/atom. The volume of the equilibrium bcc primitive cell will probably be similar to that. The question is: what bcc lattice constant gives that volume? The simplest way to answer this is to compute the answer. We will make a bcc crystal at the fcc lattice constant, and then compute the scaling factor needed to make it the right volume.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
a = 3.61 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">lattice constant</span>

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>, [0,0,0])],
              cell=0.5 * a*np.array([[ 1.0,  1.0, -1.0],
                                     [-1.0,  1.0,  1.0],
                                     [ 1.0, -1.0,  1.0]]))

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'BCC lattice constant = {0} Ang'</span>.format(a*(11.8/atoms.get_volume())**(1./3.))
</pre>


<pre class="example">
BCC lattice constant = 2.86838428403 Ang
</pre>


<p>
Now we run the equation of state calculations.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

LC = [2.75, 2.8, 2.85, 2.9, 2.95, 3.0]

<span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> LC:
    atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>, [0,0,0])],
                  cell=0.5 * a * np.array([[ 1.0,  1.0, -1.0],
                                           [-1.0,  1.0,  1.0],
                                           [ 1.0, -1.0,  1.0]]))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu-bcc-{0}'</span>.format(a),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=350,
              kpts=(8,8,8),
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        calc.calculate()
</pre>



<p>
Finally, we will compare the two crystal structures.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">bcc energies and volumes</span>
bcc_LC = [2.75, 2.8, 2.85, 2.9, 2.95, 3.0]
bcc_volumes = []
bcc_energies = []
<span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> bcc_LC:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu-bcc-{0}'</span>.format(a)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        bcc_volumes.append(atoms.get_volume())
        bcc_energies.append(atoms.get_potential_energy())

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">fcc energies and volumes</span>
fcc_LC = [3.5, 3.55, 3.6, 3.65, 3.7, 3.75]
fcc_volumes = []
fcc_energies =[]
<span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> fcc_LC:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu-{0}'</span>.format(a)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        fcc_volumes.append(atoms.get_volume())
        fcc_energies.append(atoms.get_potential_energy())

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(fcc_volumes, fcc_energies, label=<span style="color: #00cd00;">'fcc'</span>)
plt.plot(bcc_volumes, bcc_energies, label=<span style="color: #00cd00;">'bcc'</span>)

plt.xlabel(<span style="color: #00cd00;">'Atomic volume ($\AA^3$/atom)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.legend()
plt.savefig(<span style="color: #00cd00;">'images/Cu-bcc-fcc.png'</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">print table of data</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+tblname: bcc-data'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+caption: Total energy vs. lattice constant for BCC Cu.'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'| Lattice constant (\AA$^3$) | Total energy (eV) |'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|-'</span>
<span style="color: #cd0000; font-weight: bold;">for</span> lc, e <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">zip</span>(bcc_LC, bcc_energies):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'| {0} | {1} |'</span>.format(lc, e)
</pre>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>Total energy vs. lattice constant for BCC Cu.</caption>
<colgroup><col class="right" /><col class="right" />
</colgroup>
<thead>
<tr><th scope="col" class="right">Lattice constant (&Aring;<img src="ltxpng/dft_9071f2898b6ffee184f67645b3a4056228337421.png" alt="$^3$"/>)</th><th scope="col" class="right">Total energy (eV)</th></tr>
</thead>
<tbody>
<tr><td class="right">2.75</td><td class="right">-3.587523</td></tr>
<tr><td class="right">2.8</td><td class="right">-3.668112</td></tr>
<tr><td class="right">2.85</td><td class="right">-3.708699</td></tr>
<tr><td class="right">2.9</td><td class="right">-3.716496</td></tr>
<tr><td class="right">2.95</td><td class="right">-3.697781</td></tr>
<tr><td class="right">3.0</td><td class="right">-3.657913</td></tr>
</tbody>
</table>




<div class="exercise">
<p>Use the data for FCC and BCC Cu to plot the total energy as a function of the lattice constant.
</p>
</div>


<div class="figure">
<p><img src="./images/Cu-bcc-fcc.png"  alt="./images/Cu-bcc-fcc.png" /></p>
<p>Comparison of energies between fcc and bcc Cu. The fcc structure is lower in energy.</p>
</div>

<p>
Note we plot the energy vs. atomic volume. That is because the lattice constants of the two crystal structures are very different. It also shows that the atomic volumes in the two structures are similar.
</p>
<p>
What can we say here? The fcc structure has a lower energy than the bcc structure, so we can conclude the fcc structure is more favorable. In fact, the fcc structure is the experimentally found structure for Cu. Some caution is in order; if you run these calculations at a <img src="ltxpng/dft_8dbbec6cb9273542e6de6f91021491c53c7ea7e6.png" alt="$4 \times 4 \times 4$"/> <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-point grid, the bcc structure is more stable because the results are not converged!
</p>

<div class="exercise">
<p>Compute the energy vs. volume for fcc and bcc Cu for different <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-point grids. Determine when each result has converged, and which structure is more stable.
</p>
</div>

<p>
What can we say about the relative stability of fcc to hcp? Nothing, until we calculate the hcp equation of state.
</p>

</div>

</div>

<div id="outline-container-4-3-2" class="outline-4">
<h4 id="sec-4-3-2"><span class="section-number-4">4.3.2</span> Optimizing the hcp lattice constant</h4>
<div class="outline-text-4" id="text-4-3-2">

<p>The hcp lattice is more complicated than the fcc/bcc lattices because there are two lattice parameters: <img src="ltxpng/dft_20e82b912c183275371a300fccbc32d60c3f5260.png" alt="$a$"/> and <img src="ltxpng/dft_aa597181d84b76bed982262d8b326ae5d312b759.png" alt="$c$"/> or equivalently: <img src="ltxpng/dft_20e82b912c183275371a300fccbc32d60c3f5260.png" alt="$a$"/> and <img src="ltxpng/dft_351a06a77c7b3766a546ad12cdd02a7229fcbd92.png" alt="$c/a$"/>. We will start by making a grid of values and find the set of parameters that minimizes the energy. See Figure ref:ref:fig:ru-e-ca.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.hexagonal <span style="color: #cd0000; font-weight: bold;">import</span> HexagonalClosedPacked
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

atoms = HexagonalClosedPacked(symbol=<span style="color: #00cd00;">'Ru'</span>,
                              latticeconstant={<span style="color: #00cd00;">'a'</span>:2.7, <span style="color: #00cd00;">'c/a'</span>:1.584})

a_list = [2.5, 2.6, 2.7, 2.8, 2.9]
covera_list = [1.4, 1.5, 1.6, 1.7, 1.8]

<span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> a_list:
    energies = []
    <span style="color: #cd0000; font-weight: bold;">for</span> covera <span style="color: #cd0000; font-weight: bold;">in</span> covera_list:

        atoms = HexagonalClosedPacked(symbol=<span style="color: #00cd00;">'Ru'</span>,
                              latticeconstant={<span style="color: #00cd00;">'a'</span>:a, <span style="color: #00cd00;">'c/a'</span>:covera})

        wd = <span style="color: #00cd00;">'bulk/Ru/{0:1.2f}-{1:1.2f}'</span>.format(a,covera)

        <span style="color: #cd0000; font-weight: bold;">with</span> jasp(wd,
                  xc=<span style="color: #00cd00;">'PBE'</span>,
                  kpts=(6, 6, 4), <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">the c-axis is longer than the a-axis, so we use fewer kpoints.</span>
                  encut=350,
                  atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
            <span style="color: #cd0000; font-weight: bold;">try:</span>
                energies.append(atoms.get_potential_energy())
            <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
                <span style="color: #cd0000; font-weight: bold;">pass</span>
    plt.plot(covera_list, energies, label=<span style="color: #00cd00;">'a={0}'</span>.format(a))

plt.xlabel(<span style="color: #00cd00;">'$c/a$ ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Energy (eV)'</span>)
plt.legend()
plt.savefig(<span style="color: #00cd00;">'images/Ru-covera-scan.png'</span>)
plt.show()
</pre>




<div class="figure">
<p><img src="./images/Ru-covera-scan.png"  alt="./images/Ru-covera-scan.png" /></p>
<p>Total energy vs. $c/a$ for different values of $a$. \label{fig:ru-e-ca}</p>
</div>

<p>
It looks like there is a minimum in the a=2.7  &Aring;  curve, at a <img src="ltxpng/dft_351a06a77c7b3766a546ad12cdd02a7229fcbd92.png" alt="$c/a$"/> ratio of about 1.6. We can look at the same data in a contour plot which shows more clearly there is minimum in all directions near that point (Figure ref:ref:fig:ru-contourf).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

x = [2.5, 2.6, 2.7, 2.8, 2.9]
y = [1.4, 1.5, 1.6, 1.7, 1.8]

X,Y = np.meshgrid(x, y)
Z = np.zeros(X.shape)

<span style="color: #cd0000; font-weight: bold;">for</span> i,a <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(x):
    <span style="color: #cd0000; font-weight: bold;">for</span> j,covera <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(y):

        wd = <span style="color: #00cd00;">'bulk/Ru/{0:1.2f}-{1:1.2f}'</span>.format(a,covera)

        <span style="color: #cd0000; font-weight: bold;">with</span> jasp(wd) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
            atoms = calc.get_atoms()
            <span style="color: #cd0000; font-weight: bold;">try:</span>
                Z[i][j] = atoms.get_potential_energy()
            <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
                <span style="color: #cd0000; font-weight: bold;">pass</span>

cf = plt.contourf(X, Y, Z, 20,
                  cmap=plt.cm.jet)

cbar = plt.colorbar(cf)
cbar.ax.set_ylabel(<span style="color: #00cd00;">'Energy (eV)'</span>)

plt.xlabel(<span style="color: #00cd00;">'$a$ ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'$c/a$'</span>)

plt.legend()
plt.savefig(<span style="color: #00cd00;">'images/ru-contourf.png'</span>)
plt.show()
</pre>



<div class="figure">
<p><img src="./images/ru-contourf.png"  alt="./images/ru-contourf.png" /></p>
<p>Contour plot of the total energy of hcp Ru for different values of $a$ and $c/a$. \label{fig:ru-contourf}</p>
</div>


</div>

</div>

<div id="outline-container-4-3-3" class="outline-4">
<h4 id="sec-4-3-3"><span class="section-number-4">4.3.3</span> Complex structures with internal degrees of freedom</h4>
<div class="outline-text-4" id="text-4-3-3">

<p>A unit cell has six degrees of freedom: the lengths of each unit cell vector, and the angle between each vector. There may additionally be internal degrees of freedom for the atoms. It is impractical to try the approach used for the hcp Ru on anything complicated. Instead, we rely again on algorithms to optimize the unit cell shape, volume and internal degrees of freedom. It is usually not efficient to make a wild guess of the geometry and then turn VASP loose on to optimize it. Instead, the following algorithm works pretty well.
</p>
<ol>
<li>Find the volume (at constant shape, with relaxed ions) that minimizes the total energy (<a href=http://cms.mpi.univie.ac.at/wiki/index.php/ISIF>ISIF</a>=2). The goal here is to just get an idea of where the right volume is.
</li>
<li>Using the results from step 1 as a starting point, perform a set of calculations at constant volume around the minimum from step 1, but the shape and internal atom positions are allowed to change (<a href=http://cms.mpi.univie.ac.at/wiki/index.php/ISIF>ISIF</a>=4).
</li>
<li>Finally, do a final calculation near the minimum energy allowing the volume to also change. (<a href=http://cms.mpi.univie.ac.at/wiki/index.php/ISIF>ISIF</a>=3).
</li>
</ol>


<p>
This multistep process is pretty reasonable to get a converged structure pretty quickly. It is not foolproof, however, and if you have materials such as graphite it may not work well. The problem with graphite is that it is a layered compound that is held together by weak van der waal type forces which are not modeled well by typical GGA functionals. Thus the change in energy due to a volume change is larger in the plane of the graphite sheet than in the direction normal to the sheet. With a typical GGA, the sheets may just move apart until they do not interact any more.
</p>
<p>
We will illustrate the process on a well-behaved system (rutile TiO<sub>2</sub>) which has two lattice parameters and one internal degree of freedom. There are a few subtle points to mention in doing these calculations. The VASP <a href="http://cms.mpi.univie.ac.at/vasp/guide/node161.html">manual</a> recommends that you set <a href=http://cms.mpi.univie.ac.at/wiki/index.php/PREC>PREC</a> to 'high', and that ENCUT be set to 1.3*max(ENMAX) of the pseudopotentials. This is necessary to avoid problems caused by small basis sets when the volume changes, and Pulay stress. It is important to ensure that the energies are reasonably converged with respect to k-point grids. Hence, it can be a significant amount of work to do this right! Let us start with determining the ENCUT value that is appropriate for TiO<sub>2</sub>.
</p>



<pre class="src src-sh">grep ENMAX $<span style="color: #cd00cd;">VASP_PP_PATH</span>/POTPAW_PBE/Ti/POTCAR
grep ENMAX $<span style="color: #cd00cd;">VASP_PP_PATH</span>/POTPAW_PBE/O/POTCAR
</pre>


<pre class="example">
   ENMAX  =  178.330; ENMIN  =  133.747 eV
   ENMAX  =  400.000; ENMIN  =  300.000 eV
</pre>


<p>
According to the manual, we should use ENCUT = 1.3*400 = 520 eV for good results.
</p>
<p>
Now we consider the k-point convergence. The lattice vectors of the rutile TiO<sub>2</sub> structure are not all the same length, which means it is not essential that we use the same number of k-points in each direction. For simplicity, however, we do that here.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">step 1 frozen atoms and shape at different volumes</span>
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">create a TiO2 structure from the lattice vectors at</span>
<span style="color: #00cd00;">http://cst-www.nrl.navy.mil/lattice/struk/c4.html</span>
<span style="color: #00cd00;">'''</span>
a = 4.59 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">experimental degrees of freedom.</span>
c = 2.96
u = 0.3 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">internal degree of freedom!</span>

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">primitive vectors</span>
a1 = a*np.array([1.0, 0.0, 0.0])
a2 = a*np.array([0.0, 1.0, 0.0])
a3 = c*np.array([0.0, 0.0, 1.0])

atoms = Atoms([Atom(<span style="color: #00cd00;">'Ti'</span>, [0., 0., 0.]),
               Atom(<span style="color: #00cd00;">'Ti'</span>, 0.5 * a1 + 0.5 * a2 + 0.5 * a3),
               Atom(<span style="color: #00cd00;">'O'</span>, u * a1 + u * a2),
               Atom(<span style="color: #00cd00;">'O'</span>, -u * a1 - u * a2),
               Atom(<span style="color: #00cd00;">'O'</span>, (0.5 + u) * a1 + (0.5 - u) * a2 + 0.5 * a3),
               Atom(<span style="color: #00cd00;">'O'</span>, (0.5 - u) * a1 + (0.5 + u) * a2 + 0.5 * a3)],
              cell=[a1, a2, a3])

KPOINTS = [2, 3, 4, 5, 6, 7, 8]
energies = []

ready = <span style="color: #cd0000; font-weight: bold;">True</span>
<span style="color: #cd0000; font-weight: bold;">for</span> k <span style="color: #cd0000; font-weight: bold;">in</span> KPOINTS:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/tio2/kpts-{0}'</span>.format(k),
              encut=520,
              kpts=(k, k, k),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              sigma=0.05,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            energies.append(atoms.get_potential_energy())
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            ready = <span style="color: #cd0000; font-weight: bold;">False</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">not</span> ready:
    <span style="color: #cd0000; font-weight: bold;">import</span> sys; sys.exit()

plt.plot(KPOINTS, energies)
plt.xlabel(<span style="color: #00cd00;">'number of k-points in each vector'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/tio2-kpt-convergence.png'</span>)
plt.show()
</pre>




<div class="figure">
<p><img src="./images/tio2-kpt-convergence.png"  alt="./images/tio2-kpt-convergence.png" /></p>
<p>k-point convergence of rutile TiO<sub>2</sub>.</p>
</div>

<p>
A k-point grid of <img src="ltxpng/dft_8a130543db31be6e70a25774b3ec0c223f3266b4.png" alt="$5 \times 5 \times 5$"/> appears suitable for reasonably converged results. Now we proceed with step 1: Compute the total energy of the unit cell allowing internal degrees of freedom to relax, but keeping a constant cell shape.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">step 1 frozen atoms and shape at different volumes</span>
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">create a TiO2 structure from the lattice vectors at</span>
<span style="color: #00cd00;">http://cst-www.nrl.navy.mil/lattice/struk/c4.html</span>
<span style="color: #00cd00;">'''</span>
a = 4.59 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">experimental degrees of freedom.</span>
c = 2.96
u = 0.3 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">internal degree of freedom!</span>

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">primitive vectors</span>
a1 = a*np.array([1.0, 0.0, 0.0])
a2 = a*np.array([0.0, 1.0, 0.0])
a3 = c*np.array([0.0, 0.0, 1.0])

atoms = Atoms([Atom(<span style="color: #00cd00;">'Ti'</span>, [0., 0., 0.]),
               Atom(<span style="color: #00cd00;">'Ti'</span>, 0.5 * a1 + 0.5 * a2 + 0.5 * a3),
               Atom(<span style="color: #00cd00;">'O'</span>, u * a1 + u * a2),
               Atom(<span style="color: #00cd00;">'O'</span>, -u * a1 - u * a2),
               Atom(<span style="color: #00cd00;">'O'</span>, (0.5 + u) * a1 + (0.5 - u) * a2 + 0.5 * a3),
               Atom(<span style="color: #00cd00;">'O'</span>, (0.5 - u) * a1 + (0.5 + u) * a2 + 0.5 * a3)],
              cell=[a1, a2, a3])

v0 = atoms.get_volume()
cell0 = atoms.get_cell()

factors = [0.9, 0.95, 1.0, 1.05, 1.1] <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">to change volume by</span>

energies, volumes = [], []

ready = <span style="color: #cd0000; font-weight: bold;">True</span>
<span style="color: #cd0000; font-weight: bold;">for</span> f <span style="color: #cd0000; font-weight: bold;">in</span> factors:
    v1 = f*v0
    cell_factor = (v1 / v0)**(1. / 3.)

    atoms.set_cell(cell0 * cell_factor, scale_atoms=<span style="color: #cd0000; font-weight: bold;">True</span>)

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/tio2/step1-{0:1.2f}'</span>.format(f),
              encut=520,
              kpts=(5,5,5),
              isif=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">relax internal degrees of freedom</span>
              ibrion=1,
              nsw=50,
              xc=<span style="color: #00cd00;">'PBE'</span>,
              sigma=0.05,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            energies.append(atoms.get_potential_energy())
            volumes.append(atoms.get_volume())
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            ready = <span style="color: #cd0000; font-weight: bold;">False</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">not</span> ready:
    <span style="color: #cd0000; font-weight: bold;">import</span> sys; sys.exit()

plt.plot(volumes, energies)
plt.xlabel(<span style="color: #00cd00;">'Vol. ($\AA^3)$'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/tio2-step1.png'</span>)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+tblname: tio2-vol-ene'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+caption: Total energy of TiO_{2} vs. volume.'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'| Volume ($\AA^3$) | Energy (eV) |'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|-'</span>
<span style="color: #cd0000; font-weight: bold;">for</span> v, e <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">zip</span>(volumes, energies):
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'| {0} | {1} |'</span>.format(v, e)
</pre>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>Total energy of TiO<sub>2</sub> vs. volume.</caption>
<colgroup><col class="right" /><col class="right" />
</colgroup>
<thead>
<tr><th scope="col" class="right">Volume (<img src="ltxpng/dft_756a14f703128ead8c7d34fcab43f32afe7def47.png" alt="$\AA^3$"/>)</th><th scope="col" class="right">Energy (eV)</th></tr>
</thead>
<tbody>
<tr><td class="right">56.1254184</td><td class="right">-51.820427</td></tr>
<tr><td class="right">59.2434972</td><td class="right">-52.462241</td></tr>
<tr><td class="right">62.361576</td><td class="right">-52.761097</td></tr>
<tr><td class="right">65.4796548</td><td class="right">-52.801329</td></tr>
<tr><td class="right">68.5977336</td><td class="right">-52.64715</td></tr>
</tbody>
</table>




<div class="figure">
<p><img src="./images/tio2-step1.png"  alt="./images/tio2-step1.png" /></p>
<p>Total energy vs. volume for rutile TiO<sub>2</sub> in step 1 of the optimization.</p>
</div>

<p>
Now, we know the minimum volume is near 64 &Aring;^3. You could at this point fit an equation of state to find that minimum. However, we now want to use these initial starting points for a second round of optimization where we allow the unit cell shape to change, at constant volume: ISIF=4.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

factors = [0.9, 0.95, 1.0, 1.05, 1.1] <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">to change volume by</span>

energies1, volumes1 = [], [] <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">from step 1</span>
energies, volumes = [], [] <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">for step 2</span>
ready = <span style="color: #cd0000; font-weight: bold;">True</span>
<span style="color: #cd0000; font-weight: bold;">for</span> f <span style="color: #cd0000; font-weight: bold;">in</span> factors:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/tio2/step1-{0:1.2f}'</span>.format(f)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        energies1.append(atoms.get_potential_energy())
        volumes1.append(atoms.get_volume())
        calc.clone(<span style="color: #00cd00;">'bulk/tio2/step2-{0:1.2f}'</span>.format(f))

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now set ISIF=4 and run</span>
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/tio2/step2-{0:1.2f}'</span>.format(f),
              isif=4) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            energies.append(atoms.get_potential_energy())
            volumes.append(atoms.get_volume())
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            ready = <span style="color: #cd0000; font-weight: bold;">False</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">not</span> ready:
    <span style="color: #cd0000; font-weight: bold;">import</span> sys; sys.exit()

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(volumes1, energies1, volumes, energies)
plt.xlabel(<span style="color: #00cd00;">'Vol. ($\AA^3)$'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.legend([<span style="color: #00cd00;">'step 1'</span>, <span style="color: #00cd00;">'step 2'</span>], loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/tio2-step2.png'</span>)
plt.show()
</pre>




<div class="figure">
<p><img src="./images/tio2-step2.png"  alt="./images/tio2-step2.png" /></p>
<p>Total energy vs. volume for step 2 of the unit cell optimization.</p>
</div>

<p>
The take away message here is that the total energy slightly decreases when we allow the unit cell shape to change, especially for the larger unit cell deformation. This has little effect on the minimum volume, but would have an effect on the bulk modulus, which is related to the curvature of the equation of state. At this point, you could fit an equation of state to the step 2 data, and estimate the volume at the minimum volume, and recalculate the total energy at that volume.
</p>
<p>
An alternative is a final calculation with ISIF=3, which optimizes the unit cell volume, shape and internal coordinates.  It looks like the calculation at bulk/tio2/step2-1.05 is close to the minimum, so we will use that as a starting point for the final calculation.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/tio2/step2-1.05'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'bulk/tio2/step3'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/tio2/step3'</span>,
          isif=3) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
    atoms = calc.get_atoms()
    <span style="color: #cd0000; font-weight: bold;">print</span> calc

<span style="color: #cd0000; font-weight: bold;">from</span> pyspglib <span style="color: #cd0000; font-weight: bold;">import</span> spglib
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'\nThe spacegroup is {0}'</span>.format(spglib.get_spacegroup(atoms))
</pre>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/bulk/tio2/step3
  converged: True
  Energy = -52.818610 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 4.661  0.000  0.000] 4.661
  a1 [ 0.000  4.661  0.000] 4.661
  a2 [ 0.000  0.000  2.970] 2.970
  a,b,c,alpha,beta,gamma (deg): 4.661 4.661 2.970 90.0 90.0 90.0
  Unit cell volume = 64.515 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
            -0.000 -0.000 -0.000 -0.000 -0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    Ti  [0.000      0.000      0.000]   0   0.00      T T T
   1    Ti  [2.331      2.331      1.485]   0   0.00      T T T
   2    O   [1.420      1.420      0.000]   0   0.00      T T T
   3    O   [3.241      3.241      0.000]   0   0.00      T T T
   4    O   [3.751      0.910      1.485]   0   0.00      T T T
   5    O   [0.910      3.751      1.485]   0   0.00      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 20
           nsw: 50
        ibrion: 1
          isif: 3
         encut: 520.0
         sigma: 0.05
        magmom: None
          prec: Normal
          kpts: [5, 5, 5]
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
O: potpaw_PBE/O/POTCAR (git-hash: 9a0489b46120b0cad515d935f44b5fbe3a3b1dfa)
Ti: potpaw_PBE/Ti/POTCAR (git-hash: a29a4f0f14083cf90544a3cf1ae7fc220b31829c)

The spacegroup is P4_2/mnm   (136)
</pre>


<p>
This is the final result. You can see that the forces on all the atoms are less than 0.01 eV/&Aring;, and the stress is also very small. The final volume is close to where we expect it to be based on steps 1 and 2. The space group is still correct. The lattice vectors are close in length to the experimentally known values, and the angles between the vectors has not changed much. Looks good!
</p>
<p>
As a final note, the VASP <a href="http://cms.mpi.univie.ac.at/vasp/guide/node164.html">manual</a> recommends you do not use the final energy directly from the calculation, but rather run a final calculation with <a href=http://cms.mpi.univie.ac.at/wiki/index.php/ISMEAR>ISMEAR</a> set to -5. Here we examine the effect.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/tio2/step3'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'default ismear: '</span>,atoms.get_potential_energy()
    calc.clone(<span style="color: #00cd00;">'bulk/tio2/step4'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/tio2/step4'</span>,
          ismear=-5,
          nsw=0) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'ismear=-5:      '</span>,atoms.get_potential_energy()
</pre>


<pre class="example">
default ismear:  -52.81861
ismear=-5:       -52.817345
</pre>


<p>
The difference here is on the order of a meV. That does not seem significant here. I suspect the recommended practice stems from early days when much smaller ENCUT values were used and changes in the number of basis functions were more significant.
</p>
</div>

</div>

<div id="outline-container-4-3-4" class="outline-4">
<h4 id="sec-4-3-4"><span class="section-number-4">4.3.4</span> Effect of XC on bulk properties</h4>
<div class="outline-text-4" id="text-4-3-4">

<p>The exchange correlation functional can significantly affect computed bulk properties. Here, we examine the effect on the bulk lattice constant of Pd (exp. 3.881). An excellent review of this can be found in (<cite>mattsson-084714</cite>). We examine several functionals. The <code>xc</code> keyword in <code>jasp</code> is used to select the POTCARs. The value of xc can be 'LDA', 'PW91' or 'PBE'. Let us consider the LDA functional first.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">from</span> ase.utils.eos <span style="color: #cd0000; font-weight: bold;">import</span> EquationOfState

LC = [3.75, 3.80, 3.85, 3.90, 3.95, 4.0, 4.05, 4.1]

volumes, energies = [],[]
<span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> LC:
    atoms = Atoms([Atom(<span style="color: #00cd00;">'Pd'</span>, (0, 0, 0))],
                  cell=0.5 * a*np.array([[1.0, 1.0, 0.0],
                                         [0.0, 1.0, 1.0],
                                         [1.0, 0.0, 1.0]]))
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Pd-LDA-{0}'</span>.format(a),
              encut=350,
              kpts=(12,12,12),
              xc=<span style="color: #00cd00;">'LDA'</span>,
              atoms=atoms):
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            e = atoms.get_potential_energy()
            energies.append(e)
            volumes.append(atoms.get_volume())
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">len</span>(energies) == <span style="color: #cd0000; font-weight: bold;">len</span>(LC):
    eos = EquationOfState(volumes, energies)
    v0, e0, B = eos.fit()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'LDA lattice constant is {0:1.3f} Ang^3'</span>.format((4*v0)**(1./3.))
</pre>


<pre class="example">
LDA lattice constant is 3.855 Ang^3
</pre>


<p>
For a GGA calculation, it is possible to specify which functional you want via the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/GGA>GGA</a> tag. This tag was designed to use the LDA POTCAR files, but with a GGA functional. We will consider four different functionals here.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">from</span> ase.utils.eos <span style="color: #cd0000; font-weight: bold;">import</span> EquationOfState

LC = [3.75, 3.80, 3.85, 3.90, 3.95, 4.0, 4.05, 4.1]

GGA = {<span style="color: #00cd00;">'AM'</span>:<span style="color: #00cd00;">'AM05'</span>,
       <span style="color: #00cd00;">'PE'</span>:<span style="color: #00cd00;">'PBE'</span>,
       <span style="color: #00cd00;">'PS'</span>:<span style="color: #00cd00;">'PBEsol'</span>,
       <span style="color: #00cd00;">'RP'</span>:<span style="color: #00cd00;">'RPBE'</span>}

<span style="color: #cd0000; font-weight: bold;">for</span> key <span style="color: #cd0000; font-weight: bold;">in</span> GGA:
    volumes, energies = [],[]
    <span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> LC:
        atoms = Atoms([Atom(<span style="color: #00cd00;">'Pd'</span>, (0, 0, 0))],
                      cell=0.5 * a*np.array([[1.0, 1.0, 0.0],
                                             [0.0, 1.0, 1.0],
                                             [1.0, 0.0, 1.0]]))
        <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Pd-GGA-{1}-{0}'</span>.format(a,key),
                  encut=350,
                  kpts=(12,12,12),
                  xc=<span style="color: #00cd00;">'LDA'</span>,
                  gga=key,
                  atoms=atoms):
            <span style="color: #cd0000; font-weight: bold;">try:</span>
                e = atoms.get_potential_energy()
                energies.append(e)
                volumes.append(atoms.get_volume())
            <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
                <span style="color: #cd0000; font-weight: bold;">pass</span>

    <span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">len</span>(energies) == <span style="color: #cd0000; font-weight: bold;">len</span>(LC):
        eos = EquationOfState(volumes, energies)
        v0, e0, B = eos.fit()
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{1:6s} lattice constant is {0:1.3f} Ang^3'</span>.format((4*v0)**(1./3.),
                                                             GGA[key])
    <span style="color: #cd0000; font-weight: bold;">else:</span>
        <span style="color: #cd0000; font-weight: bold;">print</span> energies, LC
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0} is not ready'</span>.format(GGA[key])
</pre>


<pre class="example">
PBEsol lattice constant is 3.885 Ang^3
AM05   lattice constant is 3.882 Ang^3
RPBE   lattice constant is 3.990 Ang^3
PBE    lattice constant is 3.952 Ang^3
</pre>


<p>
These results compare very favorably to those in (<cite>mattsson-084714</cite>). It is typical that LDA functionals underestimate the lattice constants, and that GGAs tend to overestimate the lattice constants. PBEsol and AM05 were designed specifically for solids, and for Pd, these functionals do an exceptional job of reproducing the lattice constants. RPBE is particularly bad at the lattice constant, but it has been reported to be a superior functional for reactivity (<cite>hammer1999:improv-pbe</cite>).
</p>
</div>
</div>

</div>

<div id="outline-container-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> Cohesive energy</h3>
<div class="outline-text-3" id="text-4-4">


<p>
The cohesive energy is defined as the energy to separate neutral atoms in their ground electronic state from the solid at 0K at 1 atm. We will compute this for rhodium. Rh is normally an fcc metal, so we will use that structure and let VASP find the equilibrium volume for us.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">bulk system</span>
atoms = FaceCenteredCubic(directions=[[0,1,1],
                                      [1,0,1],
                                      [1,1,0]],
                                      size=(1,1,1),
                                      symbol=<span style="color: #00cd00;">'Rh'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/bulk-rh'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(4,4,4),
          isif=3,
          ibrion=2,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    bulk_energy = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">atomic system</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'Rh'</span>,[5, 5, 5])],
              cell=(7, 8, 9))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/atomic-rh'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(1, 1, 1),
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atomic_energy = atoms.get_potential_energy()

cohesive_energy = atomic_energy - bulk_energy
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The cohesive energy is {0:1.3f} eV'</span>.format(cohesive_energy)
</pre>


<pre class="example">
The cohesive energy is 6.187 eV
</pre>


<p>
According to Kittel, the cohesive energy of Rh is 5.75 eV. There are a few reasons we may have discrepancy here:
</p>
<ol>
<li>The k-point grid used in the bulk state is not very dense. However, you can see below that the total energy is pretty converged by a <img src="ltxpng/dft_e04ade3208624b1c1e96d7c060b43ad356fb4848.png" alt="$6 \times 6 \times 6$"/> <img src="ltxpng/dft_58e38fe3817a300ac6d1668e6ff004de7a10b3d1.png" alt="$k$"/>-point grid.
</li>
<li>We did not check for convergence with the planewave cutoff.
</li>
<li>We neglected spin on the atomic state. Rh in the atomic state has this electronic structure:   [Kr] 4d8 5s1 and is a doublet.
</li>
</ol>


<p>
First we consider the k-point convergence.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/atomic-rh'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    atomic_energy = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/bulk-rh'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()

kpts = [3, 4, 6, 9, 12, 15, 18]

<span style="color: #cd0000; font-weight: bold;">for</span> k <span style="color: #cd0000; font-weight: bold;">in</span> kpts:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/bulk-rh-kpts-{0}'</span>.format(k),
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(k,k,k),
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        e = atoms.get_potential_energy()

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'({0:2d}, {0:2d}, {0:2d}): cohesive energy = {1} eV'</span>.format(k,e-atomic_energy)
</pre>


<pre class="example">
( 3,  3,  3): cohesive energy = -4.837472 eV
( 4,  4,  4): cohesive energy = -6.189573 eV
( 6,  6,  6): cohesive energy = -6.210668 eV
( 9,  9,  9): cohesive energy = -6.208576 eV
(12, 12, 12): cohesive energy = -6.215367 eV
(15, 15, 15): cohesive energy = -6.215319 eV
(18, 18, 18): cohesive energy = -6.216032 eV
</pre>


<p>
Using only 1 k-point for the bulk energy is a terrible approximation! It takes at least a 6 &times; 6 &times; 6 grid to get the total energy converged to less than 10 meV. Note we do not need to check the k-point convergence of the atomic state because it is surrounded by vacuum on all sides, and so there should not be any dispersion in the bands.
</p>
<p>
We will examine the magnetic state next.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">bulk system</span>
atoms = FaceCenteredCubic(directions=[[0,1,1],
                                      [1,0,1],
                                      [1,1,0]],
                                      size=(1,1,1),
                                      symbol=<span style="color: #00cd00;">'Rh'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/bulk-rh'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(4,4,4),
          isif=3,
          ibrion=2,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    bulk_energy = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">atomic system</span>
atoms = Atoms([Atom(<span style="color: #00cd00;">'Rh'</span>,[5,5,5],magmom=1)],
              cell=(7,8,9))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/atomic-rh-sp'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(1,1,1),
          ispin=2,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atomic_energy = atoms.get_potential_energy()

cohesive_energy = atomic_energy - bulk_energy
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The cohesive energy is {0:1.3f} eV'</span>.format(cohesive_energy)
</pre>


<pre class="example">
The cohesive energy is 5.887 eV
</pre>


<p>
Again, the value in Kittel (<cite>kittel</cite>) is 5.75 eV which is very close to this value. Finally, it is also possible there is a lower energy non-spherical atom energy; we did not check that at all (see <a href="#sec-3-8-1-5">Estimating triplet oxygen dissociation energy with low symmetry</a>).
</p>
</div>

</div>

<div id="outline-container-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> <span class="todo TODO">TODO</span> Elastic properties</h3>
<div class="outline-text-3" id="text-4-5">

<p>See this reference (<cite>PhysRevB.65.104104</cite>).
</p></div>

</div>

<div id="outline-container-4-6" class="outline-3">
<h3 id="sec-4-6"><span class="section-number-3">4.6</span> Bulk thermodynamics</h3>
<div class="outline-text-3" id="text-4-6">

<p>We can predict temperature dependent thermodynamic properties of bulk materials without too much effort. As with the thermochemical properties of ideal gases, we must use some simple models that we parameterize by DFT. Here we follow the example in Reference (<cite>Shang20101040</cite>) for computing the thermal coefficient of expansion, heat capacity, enthalpy and entropy for Ni as a function of temperature.
</p>
<p>
We start by computing the equation of state for fcc Ni.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">fcc</span>
LC = [3.5, 3.55, 3.6, 3.65, 3.7, 3.75]
volumes, energies = [], []
<span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> LC:
    atoms = Atoms([Atom(<span style="color: #00cd00;">'Ni'</span>, (0, 0, 0), magmom=2.5)],
              cell=0.5 * a * np.array([[1.0, 1.0, 0.0],
                                       [0.0, 1.0, 1.0],
                                       [1.0, 0.0, 1.0]]))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Ni-{0}'</span>.format(a),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=350,
              kpts=(12,12,12),
              ispin=2,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            e = atoms.get_potential_energy()
            energies.append(e)
            volumes.append(atoms.get_volume())
        <span style="color: #cd0000; font-weight: bold;">except:</span>
            <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">len</span>(energies) != <span style="color: #cd0000; font-weight: bold;">len</span>(LC):
    <span style="color: #cd0000; font-weight: bold;">import</span> sys; sys.exit()

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(LC, fcc_energies)
plt.xlabel(<span style="color: #00cd00;">'Lattice constant ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/Ni-fcc.png'</span>)
</pre>

</div>

</div>

<div id="outline-container-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> Effect of pressure on phase stability</h3>
<div class="outline-text-3" id="text-4-7">

<p>So far we have only considered relative stability at a pressure of 0 Pa. We now consider the relative stability of two phases under pressure. We will consider TiO<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/> in the rutile and anatase phases.
</p>
<p>
The pressure is defined by: <img src="ltxpng/dft_d26b5448adcd69aa3cbeb7e286a8cb85aeb37723.png" alt="$P = -\left(\frac{\partial E}{\partial V}\right)_T$"/>. So if we have an equation of state <img src="ltxpng/dft_5ae06f5f856ef6e6cb08180a56f54a829f582e3f.png" alt="$E(V)$"/> we can calculate the pressure at any volume, or alternatively, given a pressure, compute the volume. Pressure can affect the energy of two phases differently, so that one may become stable under pressure. The condition where a phase transition occurs is when the pressure in the two phases is the same, which occurs at a common tangent.
</p>
<p>
To show this, we need <img src="ltxpng/dft_8418192b1048e647380bb2db3203b68833388f39.png" alt="$E_{rutile}(V)$"/> and <img src="ltxpng/dft_00acfb8cc8d0820e8e49dc98cfd1d20cb1fa4882.png" alt="$E_{anatase}(V)$"/>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">run the rutile calculations</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

B=<span style="color: #00cd00;">'Ti'</span>; X=<span style="color: #00cd00;">'O'</span>; a=4.59; c=2.958; u=0.305;
<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">create a rutile structure from the lattice vectors at</span>
<span style="color: #00cd00;">http://cst-www.nrl.navy.mil/lattice/struk/c4.html</span>

<span style="color: #00cd00;">spacegroup: 136 P4_2/mnm</span>
<span style="color: #00cd00;">'''</span>
a1 = a*np.array([1.0, 0.0, 0.0])
a2 = a*np.array([0.0, 1.0, 0.0])
a3 = c*np.array([0.0, 0.0, 1.0])

atoms = Atoms([Atom(B, [0., 0., 0.]),
               Atom(B, 0.5*a1 + 0.5*a2 + 0.5*a3),
               Atom(X,  u*a1 + u*a2),
               Atom(X, -u*a1 - u*a2),
               Atom(X, (0.5+u)*a1 + (0.5-u)*a2 + 0.5*a3),
               Atom(X, (0.5-u)*a1 + (0.5+u)*a2 + 0.5*a3)],
               cell=[a1, a2, a3])

nTiO2 = <span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/3.
v0 = atoms.get_volume()
cell0 = atoms.get_cell()

volumes = [28., 30., 32., 34., 36.]  <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">vol of one TiO2</span>

<span style="color: #cd0000; font-weight: bold;">for</span> v <span style="color: #cd0000; font-weight: bold;">in</span> volumes:
    atoms.set_cell(cell0*((nTiO2*v/v0)**(1./3.)), scale_atoms=<span style="color: #cd0000; font-weight: bold;">True</span>)

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/TiO2/rutile/rutile-{0}'</span>.format(v),
              encut=350,
              kpts=(6,6,6),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              ismear=0,
              sigma=0.001,
              isif=2,
              ibrion=2,
              nsw=20,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            calc.calculate()
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">pass</span>
</pre>





<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">run the anatase calculations</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">http://cst-www.nrl.navy.mil/lattice/struk/c5.html</span>

B=<span style="color: #00cd00;">'Ti'</span>; X=<span style="color: #00cd00;">'O'</span>; a=3.7842; c=2*4.7573; z=0.0831;

a1 = a*np.array([1.0, 0.0, 0.0])
a2 = a*np.array([0.0, 1.0, 0.0])
a3 = np.array([0.5*a, 0.5*a, 0.5*c])

atoms = Atoms([Atom(B, -0.125*a1 + 0.625*a2 + 0.25*a3),
               Atom(B,  0.125*a1 + 0.375*a2 + 0.75*a3),
               Atom(X, -z*a1 + (0.25-z)*a2 + 2.*z*a3),
               Atom(X, -(0.25+z)*a1 + (0.5-z)*a2 + (0.5+2*z)*a3),
               Atom(X, z*a1 - (0.25 - z)*a2 + (1-2*z)*a3),
               Atom(X, (0.25 + z)*a1 + (0.5 + z)*a2 + (0.5-2*z)*a3)],
               cell=[a1,a2,a3])

nTiO2 = <span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/3.
v0 = atoms.get_volume()
cell0 = atoms.get_cell()

volumes = [30., 33., 35., 37., 39.]  <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">vol of one TiO2</span>

<span style="color: #cd0000; font-weight: bold;">for</span> v <span style="color: #cd0000; font-weight: bold;">in</span> volumes:
    atoms.set_cell(cell0*((nTiO2*v/v0)**(1./3.)), scale_atoms=<span style="color: #cd0000; font-weight: bold;">True</span>)

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/TiO2/anatase/anatase-{0}'</span>.format(v),
              encut=350,
              kpts=(6,6,6),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              ismear=0,
              sigma=0.001,
              isif=2,
              ibrion=2,
              nsw=20,
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            calc.calculate()
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">pass</span>
</pre>



<p>
Now we will fit cubic polynomials to the data.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">fit cubic polynomials to E(V) for rutile and anatase</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
np.set_printoptions(precision=2)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">anatase equation of state</span>
volumes = [30., 33., 35., 37., 39.]  <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">vol of one TiO2 formula unit</span>
a_volumes, a_energies = [], []
<span style="color: #cd0000; font-weight: bold;">for</span> v <span style="color: #cd0000; font-weight: bold;">in</span> volumes:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/TiO2/anatase/anatase-{0}'</span>.format(v)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        nTiO2 = <span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/3.0
        a_volumes.append(atoms.get_volume()/nTiO2)
        a_energies.append(atoms.get_potential_energy()/nTiO2)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">rutile equation of state</span>
volumes = [28., 30., 32., 34., 36.]  <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">vol of one TiO2</span>
r_volumes, r_energies = [], []
<span style="color: #cd0000; font-weight: bold;">for</span> v <span style="color: #cd0000; font-weight: bold;">in</span> volumes:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/TiO2/rutile/rutile-{0}'</span>.format(v)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        nTiO2 = <span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/3.0
        r_volumes.append(atoms.get_volume()/nTiO2)
        r_energies.append(atoms.get_potential_energy()/nTiO2)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">cubic polynomial fit to equation of state E(V) = pars*[V^3 V^2 V^1 V^0]</span>
apars = np.polyfit(a_volumes, a_energies, 3)
rpars = np.polyfit(r_volumes, r_energies, 3)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'E_anatase(V) = {0:1.2f}*V^3 + {1:1.2f}*V^2 + {2:1.2f}*V + {3:1.2f}'</span>.format(*apars)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'E_rutile(V) =  {0:1.2f}*V^3 + {1:1.2f}*V^2 + {2:1.2f}*V + {3:1.2f}'</span>.format(*rpars)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'anatase epars: {0!r}'</span>.format(apars)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'rutile epars: {0!r}'</span>.format(rpars)
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get pressure parameters P(V) = -dE/dV</span>
dapars = -np.polyder(apars)
drpars = -np.polyder(rpars)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'anatase ppars: {0!r}'</span>.format(dapars)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'rutile ppars: {0!r}'</span>.format(drpars)

<span style="color: #cd0000; font-weight: bold;">print</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'P_anatase(V) = {0:1.2f}*V^2 + {1:1.2f}*V + {2:1.2f}'</span>.format(*dapars)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'P_rutile(V) =  {0:1.2f}*V^2 + {1:1.2f}*V + {2:1.2f}'</span>.format(*drpars)

vfit = np.linspace(28,40)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">plot the equations of state</span>
plt.plot(a_volumes, a_energies,<span style="color: #00cd00;">'bo '</span>, label=<span style="color: #00cd00;">'Anatase'</span>)
plt.plot(vfit, np.polyval(apars, vfit), <span style="color: #00cd00;">'b-'</span>)

plt.plot(r_volumes, r_energies,<span style="color: #00cd00;">'gs '</span>, label=<span style="color: #00cd00;">'Rutile'</span>)
plt.plot(vfit, np.polyval(rpars, vfit), <span style="color: #00cd00;">'g-'</span>)

plt.xlabel(<span style="color: #00cd00;">'Volume ($\AA^3$/f.u.)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV/f.u.)'</span>)
plt.legend()
plt.xlim([25,40])
plt.ylim([-27, -26])
plt.savefig(<span style="color: #00cd00;">'images/rutile-anatase-eos.png'</span>)
</pre>


<pre class="example">
E_anatase(V) = -0.00*V^3 + 0.13*V^2 + -5.23*V + 42.47
E_rutile(V) =  -0.00*V^3 + 0.14*V^2 + -5.33*V + 38.59
anatase epars: array([ -0.  ,   0.13,  -5.23,  42.47])
rutile epars: array([ -0.  ,   0.14,  -5.33,  38.59])
anatase ppars: array([ 0.  , -0.26,  5.23])
rutile ppars: array([ 0.  , -0.29,  5.33])

P_anatase(V) = 0.00*V^2 + -0.26*V + 5.23
P_rutile(V) =  0.00*V^2 + -0.29*V + 5.33
</pre>



<div class="figure">
<p><img src="./images/rutile-anatase-eos.png"  alt="./images/rutile-anatase-eos.png" /></p>
<p>Equations of state (E(V)) for anatase and rutile TiO$_2$.</p>
</div>

<p>
To find the conditions where a phase transition occurs, we have to find the common tangent line between the rutile and anatase phases. In other words we have to solve these two equations:
</p>
<p>
<img src="ltxpng/dft_023ee10b5358e7f74c41f25f219bf97fde8a98fe.png" alt="$(E_{anatase}(V1) - E_{rutile}(V2))/(V1-V2) = P_{anatase}(V1)$"/>
</p>
<p>
<img src="ltxpng/dft_9c017cafa32127409c029748bd2202529bbfa83c.png" alt="$(E_{anatase}(V1) - E_{rutile}(V2))/(V1-V2) = P_{rutile}(V2)$"/>
</p>
<p>
This is a nonlinear algebra problem. We use the <TT>scipy.optimize.fsolve</TT> to solve this problem.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> GPa
<span style="color: #cd0000; font-weight: bold;">from</span> numpy <span style="color: #cd0000; font-weight: bold;">import</span> array, linspace, polyval

anatase_epars = array([ -1.06049246e-03,   1.30279404e-01,  -5.23520055e+00,
         4.25202869e+01])
rutile_epars = array([ -1.24680208e-03,   1.42966536e-01,  -5.33239733e+00,
         3.85903670e+01])

anatase_ppars = array([  3.18147737e-03,  -2.60558808e-01,   5.23520055e+00])
rutile_ppars = array([  3.74040625e-03,  -2.85933071e-01,   5.33239733e+00])

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">func</span>(V):
    V1 = V[0] <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">rutile volume</span>
    V2 = V[1] <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">anatase volume</span>

    E_rutile = polyval(rutile_epars,V1)
    E_anatase = polyval(anatase_epars,V2)

    P_rutile =  polyval(rutile_ppars,V1)
    P_anatase = polyval(anatase_ppars,V2)

    <span style="color: #cd0000; font-weight: bold;">return</span> [(E_anatase - E_rutile)/(V1-V2) - P_anatase,
            (E_anatase - E_rutile)/(V1-V2) - P_rutile]

<span style="color: #cd0000; font-weight: bold;">from</span> scipy.optimize <span style="color: #cd0000; font-weight: bold;">import</span> fsolve
x0 = fsolve(func,[28,34])
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The solutions are at V = {0}'</span>.format(x0)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Anatase pressure: {0} GPa'</span>.format(polyval(anatase_ppars,x0[1])/GPa)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Rutile  pressure: {0} GPa'</span>.format(polyval(rutile_ppars,x0[0])/GPa)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">illustrate the common tangent</span>
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

vfit = linspace(28,40)
plt.plot(vfit, polyval(anatase_epars,vfit),label=<span style="color: #00cd00;">'anatase'</span>)
plt.plot(vfit, polyval(rutile_epars,vfit),label=<span style="color: #00cd00;">'rutile'</span>)
plt.plot(x0, [polyval(rutile_epars,x0[0]),
              polyval(anatase_epars,x0[1])], <span style="color: #00cd00;">'ko-'</span>, label=<span style="color: #00cd00;">'common tangent'</span>)
plt.legend()
plt.xlabel(<span style="color: #00cd00;">'Volume ($\AA^3$/f.u.)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV/f.u.)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/eos-common-tangent.png'</span>)
</pre>


<pre class="example">
The solutions are at V = [ 31.67490656  34.60893508]
Anatase pressure: 4.52495142656 GPa
Rutile  pressure: 4.5249514267 GPa
</pre>


<p>
At a pressure of 4.5 GPa, we expect that anatase will start converting into rutile. Along this common tangent, a mixture of the two phases will be more stable than either pure phase.
</p>

<div class="figure">
<p><img src="./images/eos-common-tangent.png"  alt="./images/eos-common-tangent.png" /></p>
<p>Illustration of the common tangent that shows the pressure where anatase and rutile coexist before anatase converts to rutile. \label{fig:tio2-cotangent}</p>
</div>

</div>

</div>

<div id="outline-container-4-8" class="outline-3">
<h3 id="sec-4-8"><span class="section-number-3">4.8</span> Bulk reaction energies</h3>
<div class="outline-text-3" id="text-4-8">


</div>

<div id="outline-container-4-8-1" class="outline-4">
<h4 id="sec-4-8-1"><span class="section-number-4">4.8.1</span> Alloy formation energies</h4>
<div class="outline-text-4" id="text-4-8-1">

<p>In this section we will consider how to calculate the formation energy of an fcc Cu-Pd alloy and how to use that information to discuss relative stabilities. The kinds of questions we can easily answer are:
</p>
<ol>
<li>Is the formation of an alloy at a particular composition and structure energetically favorable?
</li>
<li>Given two alloy structures at the same composition, which one is more stable?
</li>
<li>Given a set of alloy structures at different compositions, which ones are stable with respect to phase separation?
</li>
</ol>


<p>
Each of these questions is answered by calculating the formation energy of the alloy from the parent metals. Thus, we will need the total energies of fcc Cu and fcc Pd. To get started. We get those first. Rather than compute a full equation of state for these, we will rely on the built in unit cell optimization algorithm in VASP (ISIF=3).
</p>

</div>

<div id="outline-container-4-8-1-1" class="outline-5">
<h5 id="sec-4-8-1-1"><span class="section-number-5">4.8.1.1</span> Basic alloy formation energy</h5>
<div class="outline-text-5" id="text-4-8-1-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get bulk Cu and Pd energies.</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,  [0.000,      0.000,      0.000])],
              cell=  [[ 1.818,  0.000,  1.818],
                      [ 1.818,  1.818,  0.000],
                      [ 0.000,  1.818,  1.818]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(13,13,13),
          nbands=9,
          ibrion=2,
          isif=3,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    cu = atoms.get_potential_energy()

atoms = Atoms([Atom(<span style="color: #00cd00;">'Pd'</span>,  [0.000,      0.000,      0.000])],
              cell=[[ 1.978,  0.000,  1.978],
                    [ 1.978,  1.978,  0.000],
                    [0.000,  1.978,  1.978]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/pd'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(13,13,13),
          nbands=9,
          ibrion=2,
          isif=3,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    pd = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Cu energy = {0} eV'</span>.format(cu)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Pd energy = {0} eV'</span>.format(pd)
</pre>


<pre class="example">
Cu energy = -3.723305 eV
Pd energy = -5.18438 eV
</pre>


<p>
Note that the Pd energy is more negative than the Cu energy. This does not mean anything significant. We cannot say Pd is more stable than Cu; it is not like Cu could transmutate into Pd!
</p>
<p>
Next, we will consider a question like which of two structures with composition of CuPd is more stable. These coordinates for these structures came from research of the author. The approach is pretty general, you must identify the coordinates and unit cell of the candidate structure, and then run a calculation to find the optimized geometry and unit cell. This may take some work, as previously described in the multistep process for optimizing a bulk system. Here the geometry is pretty close to optimized, so we can use the VASP optimization routines. We consider two structures with composition CuPd.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,  [0.000,      0.000,      0.000]),
               Atom(<span style="color: #00cd00;">'Pd'</span>,  [-1.652,     0.000,      2.039])],
              cell=  [[ 0.000, -2.039,  2.039],
                      [ 0.000,  2.039,  2.039],
                      [ -3.303,  0.000,  0.000]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cupd-1'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(12,12,8),
          nbands=17,
          ibrion=2,
          isif=3,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    cupd1 = atoms.get_potential_energy()


atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,  [-0.049,     0.049,      0.049]),
               Atom(<span style="color: #00cd00;">'Cu'</span>,  [-11.170,   11.170,     11.170]),
               Atom(<span style="color: #00cd00;">'Pd'</span>,  [-7.415,     7.415,      7.415]),
               Atom(<span style="color: #00cd00;">'Pd'</span>,  [-3.804 ,    3.804,      3.804])],
              cell=[[-5.629,  3.701,  5.629 ],
                    [-3.701,  5.629,  5.629 ],
                    [-5.629,  5.629,  3.701 ]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cupd-2'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(8,8,8),
          nbands=34,
          ibrion=2,
          isif=3,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    cupd2 = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'cupd-1 = {0} eV'</span>.format(cupd1)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'cupd-2 = {0} eV'</span>.format(cupd2)
</pre>


<pre class="example">
cupd-1 = -9.148409 eV
cupd-2 = -17.979436 eV
</pre>


<p>
Looking at these energies, you could be tempted to say cupd-2 is more stable than cupd-1 because its energy is much lower. This is wrong, however, because cupd-2 has twice as many atoms as cupd-1. We should compare the normalized total energies, that is the energy normalized per CuPd formula unit, or as an alternative  the number of atoms in the unit cell. It does not matter which, as long as we normalize consistently. It is conventional in alloy calculation to normalize by the number of atoms in the unit cell.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cupd-1'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e1 = atoms.get_potential_energy()/<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cupd-2'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e2 = atoms.get_potential_energy()/<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'cupd-1: {0} eV/atom'</span>.format(e1)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'cupd-2: {0} eV/atom'</span>.format(e2)
</pre>


<pre class="example">
cupd-1: -4.5742045 eV/atom
cupd-2: -4.494859 eV/atom
</pre>


<p>
After normalizing by number of atoms, we can see that cupd-1 is a more stable structure. However, we are looking at total energies, and we might ask: is cupd-1 more stable than an unreacted mixture of the parent compounds, fcc Cu and Pd? In other words, is the following reaction exothermic:
</p>
<p>
Cu + Pd <img src="ltxpng/dft_afcd1ec2b9c0e6e652704c1b8acb812cc11941cc.png" alt="$\rightarrow$"/> CuPd for the two configurations we examined? Below, we show some pretty general code that computes these formation energies, and normalizes them by the number of atoms in the unit cell.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">bulk energy 1</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    cu = atoms.get_potential_energy()/<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">bulk energy 2</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/pd'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    pd = atoms.get_potential_energy()/<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cupd-1'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e1 = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">subtract bulk energies off of each atom in cell</span>
    <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms:
        <span style="color: #cd0000; font-weight: bold;">if</span> atom.symbol == <span style="color: #00cd00;">'Cu'</span>:
            e1 -= cu
        <span style="color: #cd0000; font-weight: bold;">else:</span>
            e1 -= pd
    e1 /= <span style="color: #cd0000; font-weight: bold;">len</span>(atoms)  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">normalize by number of atoms in cell</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cupd-2'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e2 = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms:
        <span style="color: #cd0000; font-weight: bold;">if</span> atom.symbol == <span style="color: #00cd00;">'Cu'</span>:
            e2 -= cu
        <span style="color: #cd0000; font-weight: bold;">else:</span>
            e2 -= pd
    e2 /= <span style="color: #cd0000; font-weight: bold;">len</span>(atoms)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Delta Hf cupd-1 = {0:1.2f} eV/atom'</span>.format(e1)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Delta Hf cupd-2 = {0:1.2f} eV/atom'</span>.format(e2)
</pre>


<pre class="example">
Delta Hf cupd-1 = -0.12 eV/atom
Delta Hf cupd-2 = -0.04 eV/atom
</pre>


<p>
The answer is yes. Both structures are energetically more favorable than an equal composition mixture of the parent metals. The heat of formation for both structures is exothermic, but the cupd-1 structure is more stable than the cupd-2 structure. This is shown conceptually in Figure ref:ref:fig:alloy1.
</p>

<div class="figure">
<p><img src="./images/alloy-stability.png"  alt="./images/alloy-stability.png" /></p>
<p>Conceptual picture of two alloys with exothermic formation energies. The dashed line represents a composition weighted average energy of the parent metals. E4 and E3 are energies associated with two different alloy structures at the same composition. Both structures are more stable than a mixture of pure metals with the same composition, but E3 is more stable than E4. \label{fig:alloy1}</p>
</div>

<p>
We will now examine another structure at another composition and its stability.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">parent metals</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    cu = atoms.get_potential_energy()/<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/pd'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    pd = atoms.get_potential_energy()/<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,  [-3.672,     3.672,      3.672]),
               Atom(<span style="color: #00cd00;">'Cu'</span>,  [0.000,     0.000,      0.000]),
               Atom(<span style="color: #00cd00;">'Cu'</span>,  [-10.821,   10.821,     10.821]),
               Atom(<span style="color: #00cd00;">'Pd'</span>,  [-7.246,     7.246,      7.246])],
               cell=[[-5.464,  3.565,  5.464],
                     [-3.565,  5.464,  5.464],
                     [-5.464,  5.464,  3.565]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu3pd-1'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(8,8,8),
          nbands=34,
          ibrion=2,
          isif=3,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    e3 = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms:
        <span style="color: #cd0000; font-weight: bold;">if</span> atom.symbol == <span style="color: #00cd00;">'Cu'</span>:
            e3 -= cu
        <span style="color: #cd0000; font-weight: bold;">else:</span>
            e3 -= pd
    e3 /= <span style="color: #cd0000; font-weight: bold;">len</span>(atoms)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Delta Hf cu3pd-1 = {0:1.2f} eV/atom'</span>.format(e3)
</pre>


<pre class="example">
Delta Hf cu3pd-1 = -0.02 eV/atom
</pre>


<p>
The formation energy is slightly exothermic, which means the structure is more stable than a mixture of the parent metals. However, let us consider whether the structure is stable with respect to phase separation into pure Cu and the cupd-1 structure. We define the following quantities:
</p>
<p>
<img src="ltxpng/dft_1952963304eae2af618f483b0b233b64170c4216.png" alt="$H_{f,Cu}$"/> = 0.0 eV/atom,    <img src="ltxpng/dft_cb7bd930180518386cf3d3a89bd86e0417662f6e.png" alt="$x_0$"/> = 0,
<img src="ltxpng/dft_d7b0ee77869109cfafbf4d33a5ad04bfab53f9e0.png" alt="$H_{f,cupd-1}$"/> = -0.12 eV/atom,   <img src="ltxpng/dft_a3baf7c889e60989e3772a12bab0ee942acd5dd2.png" alt="$x_3$"/> = 0.5.
</p>
<p>
The composition weighted average at <img src="ltxpng/dft_d18dcb054379cb74ac8cf9b95d5635d4b18d9e1d.png" alt="$x_{Pd}=0.25$"/> is:
</p>
<p>
<img src="ltxpng/dft_b4707daa85870191f941e40f5cacd45409ffe09d.png" alt="$H_f = H_{f,Cu} + \frac{x0-x}{x0-x3}(H_{f,cupd-1} - H_{f,Cu})$"/>
</p>



<pre class="src src-python">x0 = 0.0; x3 = 0.5; x = 0.25;
Hf1 = 0.0; Hf3 = -0.12;

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Composition weighted average  = {0} eV'</span>.format(Hf1 + (x0-x)/(x0-x3)*(Hf3 - Hf1))

</pre>


<pre class="example">
Composition weighted average  = -0.06 eV
</pre>


<p>
We find the weighted composition formation energy of pure Cu and cupd-1 is more favorable than the formation energy of cu3pd-1. Therefore, we could expect that structure to phase separate into a mixture of pure Cu and cupd-1. Schematically what we are seeing is shown in Figure \ref:ref:fig:alloy-phase-separation.
</p>

<div class="figure">
<p><img src="./images/alloy-phase-stability.png"  alt="./images/alloy-phase-stability.png" /></p>
<p>Illustration of of an alloy structure with an exothermic formation energy that is not stable with respect to phase separation. The solid line shows the composition weighted average energy of a mixture of Cu and cupd-2. Since the energy of cu3pd-1 is above the solid line, it is less favorable than a mixture of Cu and cupd-2 with the same composition. \label{fig:alloy-phase-separation}</p>
</div>

<p>
Finally, let us consider one more structure with the Cu<sub>3</sub>Pd stoichiometry.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">parent metals</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    cu = atoms.get_potential_energy()/<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/pd'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    pd = atoms.get_potential_energy()/<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,  [-1.867,     1.867,      0.000]),
               Atom(<span style="color: #00cd00;">'Cu'</span>,  [0.000,      0.000,      0.000]),
               Atom(<span style="color: #00cd00;">'Cu'</span>,  [0.000,      1.867,      1.867]),
               Atom(<span style="color: #00cd00;">'Pd'</span>,  [-1.867,     0.000,      1.86])],
               cell=[[-3.735,  0.000,  0.000],
                     [0.000,  0.000,  3.735],
                     [0.000,  3.735,  0.000]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu3pd-2'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(8,8,8),
          nbands=34,
          ibrion=2,
          isif=3,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    e4 = atoms.get_potential_energy()
    <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms:
        <span style="color: #cd0000; font-weight: bold;">if</span> atom.symbol == <span style="color: #00cd00;">'Cu'</span>:
            e4 -= cu
        <span style="color: #cd0000; font-weight: bold;">else:</span>
            e4 -= pd
    e4 /= <span style="color: #cd0000; font-weight: bold;">len</span>(atoms)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Delta Hf cu3pd-2 = {0:1.2f} eV/atom'</span>.format(e4)
</pre>


<pre class="example">
Delta Hf cu3pd-2 = -0.10 eV/atom
</pre>


<p>
This looks promising: the formation energy is much more favorable than cu3pd-1, and it is below the composition weighted formation energy of -0.06 eV/atom. Consequently, we conclude that this structure will not phase separate into a mixture of Cu and CuPd. We cannot say, however, if there is a more stable phase not yet considered, or if it might phase separate into two other phases. We also note here that we have ignored a few other contributions to alloy stability. We have only considered the electronic energy contributions to the formation energy. At temperatures above absolute zero there are additional contributions including configurational and vibrational entropy, which may stabilize some structures more than others. Finally, our analysis is limited to comparisons of the structures computed on the fcc lattice. In fact, it is known that the CuPd alloy forms a bcc structure. We did not calculate that structure, so we can not say if it is more or less stable than the obvious fcc structure we found.
</p>

<div class="figure">
<p><img src="./images/alloy-phase-stability-2.png"  alt="./images/alloy-phase-stability-2.png" /></p>
<p>Illustration that cu3pd-2 is more stable than cu3pd-1 and that is it is more stable than a composition weighted mixture of Cu and cupd-1. The dotted line shows the energy of a composition weighted average energy of a mixture of Cu and cupd-1. Since cu3pd-2 is below the dotted line, it is more stable than the phase-separated mixture. \label{fig:alloy-phase-separation-2}</p>
</div>

<p>
The construction of alloy phase diagrams is difficult. You are always faced with the possibility that there is a phase that you have not calculated that is more stable than the ones you did calculate. One approach is to use a tool that automates the discovery of relevant structures such as the Alloy Theoretic Automated Toolkit (<a href="http://www.its.caltech.edu/~avdw/atat/">ATAT</a>) (<cite>vandeWalle2002539,vandeWalle2009266</cite>) which uses a cluster expansion methodology.
</p>
</div>
</div>

</div>

<div id="outline-container-4-8-2" class="outline-4">
<h4 id="sec-4-8-2"><span class="section-number-4">4.8.2</span> Metal oxide oxidation energies</h4>
<div class="outline-text-4" id="text-4-8-2">

<p>We will consider here the reaction 2 Cu<sub>2</sub>O + O<sub>2</sub> <img src="ltxpng/dft_a04d4e16df2eebeec37ee6ab4db8b3daa47e1bf0.png" alt="$\rightleftharpoons$"/> 4 CuO. The reaction energy is:
</p>
<p>
<img src="ltxpng/dft_c2fd6a39eb1210c7429c0694911345d1a0582f5d.png" alt="$\Delta E = 4E_{CuO} - 2E_{Cu_2O} - E_{O_2}$"/>. We need to compute the energy of each species.
</p>

</div>

<div id="outline-container-4-8-2-1" class="outline-5">
<h5 id="sec-4-8-2-1"><span class="section-number-5">4.8.2.1</span> Cu<sub>2</sub>O calculation</h5>
<div class="outline-text-5" id="text-4-8-2-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">run Cu2O calculation</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">http://phycomp.technion.ac.il/~ira/types.html#Cu2O</span>
a = 4.27

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,[0,0,0]),
               Atom(<span style="color: #00cd00;">'Cu'</span>,[0.5, 0.5, 0.0]),
               Atom(<span style="color: #00cd00;">'Cu'</span>,[0.5, 0.0, 0.5]),
               Atom(<span style="color: #00cd00;">'Cu'</span>,[0.0, 0.5, 0.5]),
               Atom(<span style="color: #00cd00;">'O'</span>,[0.25, 0.25, 0.25]),
               Atom(<span style="color: #00cd00;">'O'</span>,[0.75, 0.75, 0.75])])

atoms.set_cell((a,a,a), scale_atoms=<span style="color: #cd0000; font-weight: bold;">True</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu2O'</span>,
          encut=400,
          kpts=(8,8,8),
          ibrion=2,
          isif=3,
          nsw=30,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set_nbands()
    calc.calculate()
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
</pre>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/bulk/Cu2O
  converged: True
  Energy = -27.204590 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 4.270  0.000  0.000] 4.270
  a1 [ 0.000  4.270  0.000] 4.270
  a2 [ 0.000  0.000  4.270] 4.270
  a,b,c,alpha,beta,gamma (deg): 4.270 4.270 4.270 90.0 90.0 90.0
  Unit cell volume = 77.854 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
             0.000  0.000  0.000 -0.000 -0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    Cu  [0.000      0.000      0.000]   0   0.00      T T T
   1    Cu  [2.135      2.135      0.000]   0   0.00      T T T
   2    Cu  [2.135      0.000      2.135]   0   0.00      T T T
   3    Cu  [0.000      2.135      2.135]   0   0.00      T T T
   4    O   [1.067      1.067      1.067]   0   0.00      T T T
   5    O   [3.202      3.202      3.202]   0   0.00      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 37
           nsw: 30
        ibrion: 2
          isif: 3
         encut: 400.0
        magmom: None
          prec: Normal
          kpts: (8, 8, 8)
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
O: potpaw_PBE/O/POTCAR (git-hash: 9a0489b46120b0cad515d935f44b5fbe3a3b1dfa)
Cu: potpaw_PBE/Cu/POTCAR (git-hash: a44c591415026f53deb16a99ca3f06b1e69be10b)
</pre>


</div>

</div>

<div id="outline-container-4-8-2-2" class="outline-5">
<h5 id="sec-4-8-2-2"><span class="section-number-5">4.8.2.2</span> CuO calculation</h5>
<div class="outline-text-5" id="text-4-8-2-2">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">run CuO calculation</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">CuO</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">http://cst-www.nrl.navy.mil/lattice/struk/b26.html</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">http://www.springermaterials.com/docs/info/10681727_51.html</span>
a = 4.6837
b = 3.4226
c = 5.1288
beta = 99.54/180*np.pi
y = 0.5819

a1 = np.array([0.5*a, -0.5*b, 0.0])
a2 = np.array([0.5*a, 0.5*b, 0.0])
a3 = np.array([c*np.cos(beta), 0.0, c*np.sin(beta)])

atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>, 0.5*a2),
               Atom(<span style="color: #00cd00;">'Cu'</span>, 0.5*a1 + 0.5*a3),
               Atom(<span style="color: #00cd00;">'O'</span>, -y*a1 + y*a2 + 0.25*a3),
               Atom(<span style="color: #00cd00;">'O'</span>,  y*a1 - y*a2 - 0.25*a3)],
               cell=(a1, a2, a3))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/CuO'</span>,
          encut=400,
          kpts=(8,8,8),
          ibrion=2,
          isif=3,
          nsw=30,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set_nbands()
    calc.calculate()
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
</pre>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/bulk/CuO
  converged: True
  Energy = -19.509498 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 2.302 -1.776  0.046] 2.908
  a1 [ 2.302  1.776  0.046] 2.908
  a2 [-0.762  0.000  5.087] 5.144
  a,b,c,alpha,beta,gamma (deg): 2.908 2.908 5.144 95.8 95.8 95.8
  Unit cell volume = 41.730 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
             0.008  0.013  0.009 -0.000  0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    Cu  [1.151      0.888      0.023]   0   0.00      T T T
   1    Cu  [0.770     -0.888      2.566]   0   0.00      T T T
   2    O   [2.111     -0.168      1.318]   0   0.03      T T T
   3    O   [1.730      0.168      3.861]   0   0.03      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 23
           nsw: 30
        ibrion: 2
          isif: 3
         encut: 400.0
        magmom: None
          prec: Normal
          kpts: (8, 8, 8)
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
O: potpaw_PBE/O/POTCAR (git-hash: 9a0489b46120b0cad515d935f44b5fbe3a3b1dfa)
Cu: potpaw_PBE/Cu/POTCAR (git-hash: a44c591415026f53deb16a99ca3f06b1e69be10b)
</pre>


</div>

</div>

<div id="outline-container-4-8-2-3" class="outline-5">
<h5 id="sec-4-8-2-3"><span class="section-number-5">4.8.2.3</span> Reaction energy calculation</h5>
<div class="outline-text-5" id="text-4-8-2-3">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">don't forget to normalize your total energy to a formula unit. Cu2O</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">has 3 atoms, so the number of formula units in an atoms is</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">len(atoms)/3.</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu2O'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    cu2o_energy = atoms.get_potential_energy()/(<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/3)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/CuO'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    cuo_energy = atoms.get_potential_energy()/(<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/2)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make sure to use the same cutoff energy for the O2 molecule!</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-400'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    o2_energy = atoms.get_potential_energy()

rxn_energy = 4.0*cuo_energy - o2_energy - 2.0*cu2o_energy
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Reaction energy = {0} eV'</span>.format(rxn_energy)
</pre>


<pre class="example">
Reaction energy = -1.966168 eV
</pre>


<p>
This is the reaction energy for 2 Cu<sub>2</sub>O <img src="ltxpng/dft_afcd1ec2b9c0e6e652704c1b8acb812cc11941cc.png" alt="$\rightarrow$"/> 4 CuO. In (<cite>PhysRevB.73.195107</cite>), the experimental reaction is estimated to be  about -3.14 eV.
</p>
<p>
There are a few reasons why our number does not agree with the experimental reaction energy. One reason is related to errors in the O<sub>2</sub> dissociation energy, and another reason is related to localization of electrons in the Cu 3<img src="ltxpng/dft_bc313c7761de36cde3cb106773f4c7c2740a8572.png" alt="\(d\)"/> orbitals (<cite>PhysRevB.73.195107</cite>). The first error of incorrect O<sub>2</sub> dissociation error is a systematic error that can be corrected empirically (<cite>PhysRevB.73.195107</cite>). Fixing the second error requires the application of DFT+U (see <a href="#sec-7-1">DFT+U</a>).
</p>
<p>
The heat of reaction is reported to be 1000 J/g product at <a href="http://onlinelibrary.wiley.com/doi/10.1002/er.4440130107/pdf">http://onlinelibrary.wiley.com/doi/10.1002/er.4440130107/pdf</a> for the reaction 2CuO <img src="ltxpng/dft_a04d4e16df2eebeec37ee6ab4db8b3daa47e1bf0.png" alt="$\rightleftharpoons$"/> Cu<sub>2</sub>O + 1/2 O<sub>2</sub>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms
atoms = Atoms(<span style="color: #00cd00;">'Cu2O'</span>)
MW = atoms.get_masses().sum()

H = 1. <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">kJ/g</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'rxn energy = {0:1.1f} eV'</span>.format(-2*H*MW/96.4)  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">convert to eV</span>
</pre>


<pre class="example">
rxn energy = -3.0 eV
</pre>


<p>
This is pretty close to the value in (<cite>PhysRevB.73.195107</cite>) and might need a temperature correction to get agreement at 298K.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-4-9" class="outline-3">
<h3 id="sec-4-9"><span class="section-number-3">4.9</span> Bulk density of states</h3>
<div class="outline-text-3" id="text-4-9">

<p>The density of states refers to the number of electronic states in a particular energy range.
</p>
<p>
The solution to Eq. \eqref{eq:KS} yields a set of Kohn-Sham (K-S) orbitals and an
associated set of eigenvalues that correspond to the energies of these
orbitals, neither of which have any known directly observable meaning
(<cite>RevModPhys.71.1253</cite>).  The sum of the squared K-S orbitals,
however, is equal to the electron density (Eq. \eqref{eq:density}),
and the sum of the eigenvalues is a significant part of the total
energy (Eq.  \eqref{eq:dftEnergy}). Thus, it seems reasonable to
suppose these quantities have other significant relationships to
physical observables. Perdew et al. showed that the highest occupied
eigenvalue is equal to the ionization energy of a system within an
exact density functional theory (<cite>perdew1982:elect-kohn-sham</cite>), but
their interpretation has been vigorously debated in the literature
(<cite>kleinman1997:signif-kohn-sham,perdew1997,kleinman1997:reply-commen-kohn-sham</cite>),
and is only true for the exact exchange/correlation functional, not
the approximate ones used in practice (<cite>koch2001</cite>).
Stowasser and Hoffmann discussed an approach to using the K-S orbitals
in more traditional molecular orbital interpretations, but the results
were primarily qualitative (<cite>stowasser1999:what-kohn-sham</cite>). More
recently, a DFT analog of Koopmans' theorem has been developed that
formally identifies the eigenvalues with vertical ionization
potentials, which can be measured with photoelectron spectroscopy
(<cite>gritsenko2002</cite>).
</p>
<p>
Despite the arguments against ascribing physical meaning to the K-S
orbitals and eigenvalues, it has become fairly standard, especially
for solids, to use them to calculate the density of states (DOS)
(<cite>jones1989</cite>) [Sec.  VI.  B].  This has been found to yield
reasonable results for the valence bands in metals, but poor results
for tightly bound orbitals and band gaps
(<cite>perdew1982:elect-kohn-sham</cite>). A highly technical discussion of
this issue can be found in Ref. (<cite>perdew1981:self</cite>).  The
density of states can be calculated by a sum over the k-points
(<cite>seitsonen2000:phd</cite>):
</p>


<p>
<img src="ltxpng/dft_1d3959b1debe52521bffb86e0e721188f949f941.png" alt="\begin{equation}\label{eq:dos}
\rho(\epsilon)=\sum_\mathbf{\mathrm{k}} \omega_\mathbf{\mathrm{k}} \sum_i \beta(\epsilon -\epsilon_{i\mathbf{\mathrm{k}}})
\end{equation}"/>
</p>


<p>
where <img src="ltxpng/dft_f8ed80ff9be7cb629ea8b4387dc026eb0cc7fcc9.png" alt="$\omega_\mathbf{\mathrm{k}}$"/> is the weight associated with the
k-point, and <img src="ltxpng/dft_dba0b1d476b75c222ecc7b0c9b8f267097b3cf5d.png" alt="$\beta$"/> is a broadening function, typically a gaussian
function, to account for the finite number of k-points used in the
calculations. The amount of broadening is arbitrary, and should tend
to zero as the number of k-points approaches infinity.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

npoints = 200
width = 0.1

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">delta</span>(energies, eik):
    <span style="color: #cd0000; font-weight: bold;">return</span> energies == eik

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">gaussian</span>(energies, eik):
    x = ((energies - eik)/width)
    <span style="color: #cd0000; font-weight: bold;">return</span> np.exp(-x**2)/np.sqrt(np.pi)/width

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/pd-dos'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">kpt weights</span>
    wk = calc.get_k_point_weights()

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">for each k-point there are a series of eigenvalues</span>
    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">here we get all the eigenvalues for each k-point</span>
    e_kn = []
    <span style="color: #cd0000; font-weight: bold;">for</span> i,k <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(wk):
        <span style="color: #cd0000; font-weight: bold;">print</span> i,k
        e_kn.append(calc.get_eigenvalues(kpt=i))

    e_kn = np.array(e_kn) - calc.get_fermi_level()

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">these are the energies we want to evaluate the dos at</span>
    energies = np.linspace(e_kn.min(), e_kn.max(), npoints)

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this is where we build up the dos</span>
    dos = np.zeros(npoints)

    <span style="color: #cd0000; font-weight: bold;">for</span> j <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(npoints):
        <span style="color: #cd0000; font-weight: bold;">for</span> k <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(len(wk)): <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">loop over all kpoints</span>
            <span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(len(e_kn[k])): <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">loop over eigenvalues in each k</span>
                dos[j] += wk[k] * gaussian(energies[j], e_kn[k][i])

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(energies, dos)
plt.show()
</pre>



<p>
Here is a more convenient way to compute the DOS using <TT>ase.dft</TT>.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> sys

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> ase.dft <span style="color: #cd0000; font-weight: bold;">import</span> DOS

a = 3.9  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">approximate lattice constant</span>
b = a / 2.
bulk = Atoms([Atom(<span style="color: #00cd00;">'Pd'</span>, (0.0, 0.0, 0.0))],
             cell=[(0, b, b),
                   (b, 0, b),
                   (b, b, 0)])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/pd-dos'</span>,
          encut=300,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          lreal=<span style="color: #cd0000; font-weight: bold;">False</span>,
          kpts=(8, 8, 8),  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this is too low for high quality DOS</span>
          atoms=bulk) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this runs the calculation</span>
    bulk.get_potential_energy()
    dos = DOS(calc, width=0.2)
    d = dos.get_dos()
    e = dos.get_energies()

<span style="color: #cd0000; font-weight: bold;">import</span> pylab <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(e,d)
plt.xlabel(<span style="color: #00cd00;">'energy (eV)'</span>)
plt.ylabel(<span style="color: #00cd00;">'DOS'</span>)
plt.savefig(<span style="color: #00cd00;">'images/pd-dos.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/pd-dos.png"  alt="./images/pd-dos.png" /></p>
<p>Total DOS for bulk Pd.</p>
</div>

<p>
This DOS looks roughly like you would expect. The peak between -5 to 0 eV is the Pd d-band.
</p>
<p>
The VASP manual <a href="http://cms.mpi.univie.ac.at/vasp/guide/node124.html#SECTION000933000000000000000">recommends</a> a final run be made with ISMEAR=-5, which uses the tetrahedron method with Bl\"ochl corrections.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.dft <span style="color: #cd0000; font-weight: bold;">import</span> DOS
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/pd-dos'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'bulk/pd-dos-ismear-5'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/pd-dos-ismear-5'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    bulk = calc.get_atoms()

    calc.set(ismear=-5)

    bulk.get_potential_energy()
    dos = DOS(calc, width=0.2)
    d = dos.get_dos()
    e = dos.get_energies()

<span style="color: #cd0000; font-weight: bold;">import</span> pylab <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(e, d)
plt.xlabel(<span style="color: #00cd00;">'energy [eV]'</span>)
plt.ylabel(<span style="color: #00cd00;">'DOS'</span>)
plt.savefig(<span style="color: #00cd00;">'images/pd-dos-ismear-5.png'</span>)
</pre>




<div class="figure">
<p><img src="./images/pd-dos-ismear-5.png"  alt="./images/pd-dos-ismear-5.png" /></p>
<p>Total DOS for Pd computed with ISMEAR=-5</p>
</div>




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> sys

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> ase.dft <span style="color: #cd0000; font-weight: bold;">import</span> DOS
<span style="color: #cd0000; font-weight: bold;">import</span> pylab <span style="color: #cd0000; font-weight: bold;">as</span> plt

a = 3.9  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">approximate lattice constant</span>
b = a / 2.
bulk = Atoms([Atom(<span style="color: #00cd00;">'Pd'</span>, (0.0, 0.0, 0.0))],
             cell=[(0, b, b),
                   (b, 0, b),
                   (b, b, 0)])

kpts = [8, 10, 12, 14, 16, 18, 20]

<span style="color: #cd0000; font-weight: bold;">for</span> k <span style="color: #cd0000; font-weight: bold;">in</span> kpts:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/pd-dos-k{0}-simear-5'</span>.format(k),
              encut=300,
              xc=<span style="color: #00cd00;">'PBE'</span>,
              lreal=<span style="color: #cd0000; font-weight: bold;">False</span>,
              kpts=(k,k,k),
              atoms=bulk) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

        <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this runs the calculation</span>
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            bulk.get_potential_energy()
            dos = DOS(calc, width=0.2)
            d = dos.get_dos() + k/4.0
            e = dos.get_energies()

            plt.plot(e,d, label=<span style="color: #00cd00;">'k={0}'</span>.format(k))
        <span style="color: #cd0000; font-weight: bold;">except:</span>
            <span style="color: #cd0000; font-weight: bold;">pass</span>
plt.xlabel(<span style="color: #00cd00;">'energy (eV)'</span>)
plt.ylabel(<span style="color: #00cd00;">'DOS'</span>)
plt.legend()
plt.savefig(<span style="color: #00cd00;">'images/pd-dos-k-convergence-ismear-5.png'</span>)
plt.show()
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/pd-dos-k-convergence-ismear-5.png"  alt="./images/pd-dos-k-convergence-ismear-5.png" /></p>
<p>Convergence of the total DOS with k-points</p>
</div>

</div>

</div>

<div id="outline-container-4-10" class="outline-3">
<h3 id="sec-4-10"><span class="section-number-3">4.10</span> Atom projected density of states</h3>
<div class="outline-text-3" id="text-4-10">

<p>One major disadvantage of a planewave basis set is that it is
difficult to relate the completely delocalized planewaves to
localized phenomena such as bonding. Much insight into bonding has
been gained by atomic/molecular orbital theory, which has carried over
to the solid-state arena (<cite>RevModPhys.60.601</cite>). Consequently, several
schemes have been developed to project the one-electron Kohn-Sham wave
functions onto atomic wave functions
(<cite>sanchez-portal1995:projec,segall1996:popul,segall1996:popul-mp</cite>).
In VASP, the one electron wave functions can be projected onto
spherical harmonic orbitals. The radial component of the atomic
orbitals extends to infinity. In a solid, this means that the
projection on one atom may overlap with the projection on a
neighboring atom, resulting in double counting of electrons.
Consequently, a cutoff radius was introduced, beyond which no
contributions are included.  It is not obvious what the best cutoff
radius is. If the radius is too small, it might not capture all of the
electrons associated with the atom. However, if it is too large, it
may include electrons from neighboring atoms.  One might want to use
different cutoff radii for different atoms, which have different
sizes.  Furthermore, the ideal cutoff radius for an atom may change in
different environments, thus it would require an iterative procedure
to determine it.  This difficulty arises because the orbital-band
occupations are not observable, thus how the electrons are divided up
between atoms is arbitrary and, as will be seen later, is sensitive to
the cutoff radius (and in other DFT implementations, the basis set).
However, Mulliken orbital populations have been used successfully for
many years to examine the qualitative differences between similar
systems, and that is precisely what these quantities are used for
here.  Thus, a discussion of the analysis and results is warranted.
</p>
<p>
The s and p states in a metal are typically delocalized in space and
more like free-electrons, whereas the d-orbitals are fairly localized
in space and have been treated successfully with tight-binding
theories such as extended H\"u ckel theory (<cite>RevModPhys.60.601</cite>), and
linear muffin tin orbital theory (<cite>ruban1997:surfac</cite>).
Consequently, the remaining discussion will be focused on the
properties of the projected d-states.
</p>
<p>
In this example, we consider how to get the atom-projected density of
states (ADOS). We are interested in properties of the <img src="ltxpng/dft_1c6f2a76b874bf4863cb2658638729dfb8a93e00.png" alt="$d$"/>-band on Pd,
such as the <img src="ltxpng/dft_1c6f2a76b874bf4863cb2658638729dfb8a93e00.png" alt="$d$"/>-band center and <img src="ltxpng/dft_1c6f2a76b874bf4863cb2658638729dfb8a93e00.png" alt="$d$"/>-band width. You must set the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/RWIGS>RWIGS</a>
tag to get ADOS, and these are the Wigner-Seitz radii for each atom.
By integrating the projected d-band up to the Fermi level, the d-band
filling can be determined.  It is not obvious what the electron count
in the d-band should be for an atom in a metal.  For a gas-phase,
neutral metal atom in the ground state, however, the d-orbital
electron count is well defined, so it will be used as an initial
reference point for comparison (<cite>kittel</cite>).
</p>
<p>
A powerful method for characterizing distributions is to examine
various moments of the distribution (see Chapter 4 in Ref.
(<cite>cottrell1988</cite>) and Chapter 6 in Refs. (<cite>ducastelle1991</cite>)
and (<cite>pettifor1992:elect-theor-alloy-desig</cite>)). The <img src="ltxpng/dft_4229f93ef1e0f8cc51206c3cc8438222da1f8a4a.png" alt="$n^{th}$"/>
order moment, <img src="ltxpng/dft_641eb494557e1723e56a97d8fdc8efc6a5201233.png" alt="$\mu_n$"/>, of a distribution of states <img src="ltxpng/dft_a43718d7f6a121dd01824b4b2cb717438b00623e.png" alt="$\rho(\epsilon)$"/>
with respect to a reference <img src="ltxpng/dft_45d115acd0884881094b41b73a07b77ee422d9a0.png" alt="$\epsilon_o$"/> is defined by
</p>

<p>
<img src="ltxpng/dft_6b3a68a137ce6797be7b7c49e7ac6a8b7b53be7f.png" alt="\begin{equation}
\mu_n = \frac{\int_{-\infty}^\infty \epsilon^n \rho(\epsilon-\epsilon_o)d\epsilon}
{\int_{-\infty}^\infty \rho(\epsilon-\epsilon_o)d\epsilon}
\end{equation}"/>
</p>

<p>
In this work, the reference energy is always the Fermi level.  The
zeroth moment is just the total number of states, in this case it will
be normalized to unity. The first moment is the average energy of
distribution, analogous to the center of mass for a mass density
distribution. The second moment is the mean squared width of the
distribution. The third moment is a measure of skewness and the fourth
moment is related to kurtosis, but these moments are rarely used, and
only the first and second moments are considered in this work.
</p>
<p>
It is important to note that these projected density of states are not physical observables. They are the wavefunctions projected onto atomic orbitals. For some situations this makes sense, e.g. the <img src="ltxpng/dft_1c6f2a76b874bf4863cb2658638729dfb8a93e00.png" alt="$d$"/> orbitals are fairly localized and reasonably approximated by atomic orbitals. The <img src="ltxpng/dft_fa772b0e1d1b97e293f3daf123bce4d25f789dcc.png" alt="$s$"/> valence orbitals in a metal, in contrast, are almost totally delocalized. Depending on the cutoff radius (RWIGS) you choose, you can see very different ADOS.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.calculators.vasp <span style="color: #cd0000; font-weight: bold;">import</span> VaspDos
<span style="color: #cd0000; font-weight: bold;">import</span> sys

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

a = 3.9  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">approximate lattice constant</span>
b = a / 2.
bulk = Atoms([Atom(<span style="color: #00cd00;">'Pd'</span>, (0.0, 0.0, 0.0))],
             cell=[(0, b, b),
                   (b, 0, b),
                   (b, b, 0)])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/pd-ados'</span>,
          encut=300,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          lreal=<span style="color: #cd0000; font-weight: bold;">False</span>,
          rwigs=[1.5],  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">wigner-seitz radii for ados</span>
          kpts=(8, 8, 8),
          atoms=bulk) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this runs the calculation</span>
    bulk.get_potential_energy()

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now get results</span>
    ados = VaspDos(efermi=calc.get_fermi_level())

    energies = ados.energy
    dos = ados.site_dos(0, <span style="color: #00cd00;">'d'</span>)

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we will select energies in the range of -10, 5</span>
    ind = (energies &lt; 5) &amp; (energies &gt; -10)

    energies = energies[ind]
    dos = dos[ind]

    Nstates = np.trapz(dos, energies)
    occupied = energies &lt;= 0.0
    N_occupied_states = np.trapz(dos[occupied], energies[occupied])
    ed = np.trapz(energies * dos, energies) / np.trapz(dos, energies)
    wd2 = np.trapz(energies**2 * dos, energies) / np.trapz(dos, energies)

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Total # states = {0:1.2f}'</span>.format(Nstates)
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'number of occupied states = {0:1.2f}'</span>.format(N_occupied_states)
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'d-band center = {0:1.2f} eV'</span>.format(ed)
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'d-band width  = {0:1.2f} eV'</span>.format(np.sqrt(wd2))

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">plot the d-band</span>
    plt.plot(energies, dos, label=<span style="color: #00cd00;">'$d$-orbitals'</span>)

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">plot the occupied states in shaded gray</span>
    plt.fill_between(x=energies[occupied],
                 y1=dos[occupied],
                 y2=np.zeros(dos[occupied].shape),
                 color=<span style="color: #00cd00;">'gray'</span>)

    plt.xlabel(<span style="color: #00cd00;">'$E - E_f$ (eV)'</span>)
    plt.ylabel(<span style="color: #00cd00;">'DOS (arbitrary units)'</span>)

plt.savefig(<span style="color: #00cd00;">'images/pd-ados.png'</span>)
plt.show()
</pre>


<pre class="example">
Total # states = 9.29
number of occupied states = 8.18
d-band center = -2.00 eV
d-band width  = 2.72 eV
</pre>



<div class="figure">
<p><img src="./images/pd-ados.png"  alt="./images/pd-ados.png" /></p>
<p>Atom projected $d$-band for bulk Pd. The shaded area corresponds to the occupied states below the Fermi level.</p>
</div>

</div>

<div id="outline-container-4-10-1" class="outline-4">
<h4 id="sec-4-10-1"><span class="section-number-4">4.10.1</span> Effect of RWIGS on ADOS</h4>
<div class="outline-text-4" id="text-4-10-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.calculators.vasp <span style="color: #cd0000; font-weight: bold;">import</span> VaspDos
<span style="color: #cd0000; font-weight: bold;">import</span> sys

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

a = 3.9  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">approximate lattice constant</span>
b = a / 2.
bulk = Atoms([Atom(<span style="color: #00cd00;">'Pd'</span>, (0.0, 0.0, 0.0))],
             cell=[(0, b, b),
                   (b, 0, b),
                   (b, b, 0)])

RWIGS = [1.0, 1.1, 1.25, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0 ]

ED, WD, N = [], [], []

<span style="color: #cd0000; font-weight: bold;">for</span> rwigs <span style="color: #cd0000; font-weight: bold;">in</span> RWIGS:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/pd-ados'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        calc.clone(<span style="color: #00cd00;">'bulk/pd-ados-rwigs-{0}'</span>.format(rwigs))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/pd-ados-rwigs-{0}'</span>.format(rwigs)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        calc.set(rwigs=[rwigs])

        <span style="color: #cd0000; font-weight: bold;">try:</span>
            calc.calculate()
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">continue</span>

        <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now get results</span>
        ados = VaspDos(efermi=calc.get_fermi_level())

        energies = ados.energy
        dos = ados.site_dos(0, <span style="color: #00cd00;">'d'</span>)

        <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we will select energies in the range of -10, 5</span>
        ind = (energies &lt; 5) &amp; (energies &gt; -10)

        energies = energies[ind]
        dos = dos[ind]

        Nstates = np.trapz(dos, energies)
        occupied = energies &lt;= 0.0
        N_occupied_states = np.trapz(dos[occupied], energies[occupied])
        ed = np.trapz(energies * dos, energies) / np.trapz(dos, energies)
        wd2 = np.trapz(energies**2 * dos, energies) / np.trapz(dos, energies)

        N.append(N_occupied_states)
        ED.append(ed)
        WD.append(wd2**0.5)

plt.plot(RWIGS, N, <span style="color: #00cd00;">'bo'</span>, label=<span style="color: #00cd00;">'N. occupied states'</span>)
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)
plt.xlabel(<span style="color: #00cd00;">'RWIGS ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'# occupied states'</span>)
plt.savefig(<span style="color: #00cd00;">'images/ados-rwigs-occupation.png'</span>)

plt.figure()
plt.plot(RWIGS, ED, <span style="color: #00cd00;">'bo'</span>, label=<span style="color: #00cd00;">'d-band center (eV)'</span>)
plt.plot(RWIGS, WD, <span style="color: #00cd00;">'gs'</span>, label=<span style="color: #00cd00;">'d-band width (eV)'</span>)
plt.xlabel(<span style="color: #00cd00;">'RWIGS ($\AA$)'</span>)
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/ados-rwigs-moments.png'</span>)
</pre>




<div class="figure">
<p><img src="./images/ados-rwigs-occupation.png"  alt="./images/ados-rwigs-occupation.png" /></p>
<p>Effect of the RWIGS on the number of occupied \(d\)-states.</p>
</div>


<div class="figure">
<p><img src="./images/ados-rwigs-moments.png"  alt="./images/ados-rwigs-moments.png" /></p>
<p>Effect of the RWIGS on the \(d\)-band center and width.</p>
</div>

</div>
</div>

</div>

<div id="outline-container-4-11" class="outline-3">
<h3 id="sec-4-11"><span class="section-number-3">4.11</span> Band structures</h3>
<div class="outline-text-3" id="text-4-11">


<p>
To compute a band structure we do two things. First, we compute the self-consistent band structure. Then we compute the band structure at the desired <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-points. We will use Si as an example (adapted from <a href="http://bbs.sciencenet.cn/bbs/upload/20083418325986.pdf">http://bbs.sciencenet.cn/bbs/upload/20083418325986.pdf</a>).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">from</span> ase.visualize <span style="color: #cd0000; font-weight: bold;">import</span> view

a = 5.38936
atoms = Atoms([Atom(<span style="color: #00cd00;">'Si'</span>,[0,0,0]),
               Atom(<span style="color: #00cd00;">'Si'</span>,[0.25, 0.25, 0.25])])

atoms.set_cell([[a/2., a/2., 0.0],
                [0.0,  a/2., a/2.],
                [a/2., 0.0, a/2.]],scale_atoms=<span style="color: #cd0000; font-weight: bold;">True</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Si-selfconsistent'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          prec=<span style="color: #00cd00;">'Medium'</span>,
          istart=0,
          icharg=2,
          ediff=0.1e-03,
          kpts=(4,4,4),
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>



<p>
Now, we run a new calculation along the k-point path desired. The standard VASP way of doing this is to modify the INCAR and KPOINTS file and rerun VASP. We will not do that. Doing that results in some lost information if you overwrite the old files. We will copy the old directory to a new directory, using code to ensure this only happens one time.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

wd = <span style="color: #00cd00;">'bulk/Si-bandstructure'</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Si-selfconsistent'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(wd)

kpts = [[0.5,0.5,0.0],   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">L</span>
        [0,0,0],         <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Gamma</span>
        [0,0,0],
        [0.5, 0.5, 0.5]] <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">X</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(wd,
          kpts=kpts,
          reciprocal=<span style="color: #cd0000; font-weight: bold;">True</span>,
          kpts_nintersections=10,
          icharg=11) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>



<p>
We will learn how to manually parse the EIGENVAL file here to generate the band structure. The structure of the EIGENVAL file looks like this:
</p>



<pre class="src src-sh">head -n 20 bulk/Si-bandstructure/EIGENVAL
</pre>



<pre class="example">    2    2    1    1
  0.1956688E+02  0.3810853E-09  0.3810853E-09  0.3810853E-09  0.5000000E-15
  1.000000000000000E-004
  CAR
 unknown system
    8   20    8

  0.5000000E+00  0.5000000E+00  0.0000000E+00  0.5000000E-01
   1       -1.826311
   2       -1.826306
   3        3.153690
   4        3.153716
   5        6.744294
   6        6.744321
   7       16.392989
   8       16.405965

  0.4444444E+00  0.4444444E+00  0.0000000E+00  0.5000000E-01
   1       -2.669062
   2       -0.918013
</pre>


<p>
We can ignore the first five lines.
</p>



<pre class="src src-python">f = <span style="color: #cd0000; font-weight: bold;">open</span>(<span style="color: #00cd00;">'bulk/Si-bandstructure/EIGENVAL'</span>, <span style="color: #00cd00;">'r'</span>)

line1 = f.readline()
line2 = f.readline()
line3 = f.readline()
line4 = f.readline()
comment = f.readline()
unknown, nkpoints, nbands = [<span style="color: #cd0000; font-weight: bold;">int</span>(x) <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> f.readline().split()]

blankline = f.readline()

band_energies = [[] <span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(nbands)]

<span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(nkpoints):
    x,y,z, weight = [<span style="color: #cd0000; font-weight: bold;">float</span>(x) <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> f.readline().split()]

    <span style="color: #cd0000; font-weight: bold;">for</span> j <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(nbands):
        fields = f.readline().split()
        id, energy = <span style="color: #cd0000; font-weight: bold;">int</span>(fields[0]), <span style="color: #cd0000; font-weight: bold;">float</span>(fields[1])
        band_energies[id-1].append(energy)
    blankline = f.readline()
f.close()

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

<span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(nbands):
    plt.plot(<span style="color: #cd0000; font-weight: bold;">range</span>(nkpoints), band_energies[i])

ax = plt.gca()
ax.set_xticks([]) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">no tick marks</span>
plt.xlabel(<span style="color: #00cd00;">'k-vector'</span>)
plt.ylabel(<span style="color: #00cd00;">'Energy (eV)'</span>)
ax.set_xticks([0,10,19])
ax.set_xticklabels([<span style="color: #00cd00;">'$L$'</span>, <span style="color: #00cd00;">'$\Gamma$'</span>, <span style="color: #00cd00;">'$X$'</span>])
plt.savefig(<span style="color: #00cd00;">'images/Si-bandstructure.png'</span>)
</pre>




<div class="figure">
<p><img src="./images/Si-bandstructure.png"  alt="./images/Si-bandstructure.png" /></p>
<p>Calculated band-structure for Si.</p>
</div>


<p>
Next we will examine the connection between band structures and density of states. In this example, we will compute the band structure of TiO<sub>2</sub> using a function built into <TT>jasp</TT> to do the analysis described above.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> jasp.jasp_bandstructure <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/tio2/step3'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    n,bands,p = calc.get_bandstructure(kpts_path=[(<span style="color: #00cd00;">'$\Gamma$'</span>,[0.0, 0.0, 0.0]),
                                                  (<span style="color: #00cd00;">'X'</span>,[0.5, 0.5, 0.0]),
                                                  (<span style="color: #00cd00;">'X'</span>,[0.5, 0.5, 0.0]),
                                                  (<span style="color: #00cd00;">'M'</span>,[0.0, 0.5, 0.5]),
                                                  (<span style="color: #00cd00;">'M'</span>,[0.0, 0.5, 0.5]),
                                                  (<span style="color: #00cd00;">'$\Gamma$'</span>,[0.0, 0.0, 0.0])])

p.savefig(<span style="color: #00cd00;">'images/tio2-bandstructure-dos.png'</span>)
</pre>




<div class="figure">
<p><img src="./images/tio2-bandstructure-dos.png"  alt="./images/tio2-bandstructure-dos.png" /></p>
<p>Band structure and total density of states for TiO<sub>2</sub>.</p>
</div>


</div>

<div id="outline-container-4-11-1" class="outline-4">
<h4 id="sec-4-11-1"><span class="section-number-4">4.11.1</span> <span class="todo TODO">TODO</span> create example showing band dispersion with lattice constant</h4>
<div class="outline-text-4" id="text-4-11-1">






<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> jasp.jasp_bandstructure <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
JASPRC[<span style="color: #00cd00;">'mode'</span>]=<span style="color: #00cd00;">'run'</span>
ready = <span style="color: #cd0000; font-weight: bold;">True</span>
<span style="color: #cd0000; font-weight: bold;">for</span> i,a <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>([4.7, 5.38936, 6.0]):

    atoms = Atoms([Atom(<span style="color: #00cd00;">'Si'</span>,[0,0,0]),
                   Atom(<span style="color: #00cd00;">'Si'</span>,[0.25, 0.25, 0.25])])

    atoms.set_cell([[a/2., a/2., 0.0],
                    [0.0,  a/2., a/2.],
                    [a/2., 0.0, a/2.]],scale_atoms=<span style="color: #cd0000; font-weight: bold;">True</span>)

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Si-bs-{0}'</span>.format(i),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              prec=<span style="color: #00cd00;">'Medium'</span>,
              istart=0,
              icharg=2,
              ediff=0.1e-03,
              kpts=(4,4,4),
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            n,bands,p  = calc.get_bandstructure(kpts_path=[(<span style="color: #00cd00;">'L'</span>, [0.5,0.5,0.0]),
                                                       (<span style="color: #00cd00;">'$\Gamma$'</span>, [0,0,0]),
                                                       (<span style="color: #00cd00;">'$\Gamma$'</span>, [0,0,0]),
                                                       (<span style="color: #00cd00;">'X'</span>, [0.5,0.5,0.5])],
                                            kpts_nintersections=10)
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'not ready {0}'</span>.format(i)
            ready = <span style="color: #cd0000; font-weight: bold;">False</span>

    <span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">not</span> ready:
        <span style="color: #cd0000; font-weight: bold;">import</span> sys; sys.exit()


    p.savefig(<span style="color: #00cd00;">'images/Si-bs-{0}.png'</span>.format(i))
    p.show()
</pre>


<pre class="example">
None
</pre>


<p>
<img src="./images/Si-bs-0.png"  alt="./images/Si-bs-0.png" />
</p>
<p>
<img src="./images/Si-bs-1.png"  alt="./images/Si-bs-1.png" />
</p>
<p>
<img src="./images/Si-bs-2.png"  alt="./images/Si-bs-2.png" />
</p>
</div>
</div>

</div>

<div id="outline-container-4-12" class="outline-3">
<h3 id="sec-4-12"><span class="section-number-3">4.12</span> Magnetism</h3>
<div class="outline-text-3" id="text-4-12">


</div>

<div id="outline-container-4-12-1" class="outline-4">
<h4 id="sec-4-12-1"><span class="section-number-4">4.12.1</span> Determining if a magnetic solution is energetically favorable</h4>
<div class="outline-text-4" id="text-4-12-1">

<p>We can force a total magnetic moment onto a unit cell and compute the total energy as function of the total magnetic moment. If there is a minimum in the energy, then we know there is a lower energy magnetic solution than a non-magnetic solution. We use <a href=http://cms.mpi.univie.ac.at/wiki/index.php/NUPDOWN>NUPDOWN</a> to enforce the magnetic moment in the cell. Note that NUPDOWN can only be an integer. You cannot set it to be an arbitrary float.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> BodyCenteredCubic

atoms = BodyCenteredCubic(directions=[[1,0,0],
                                      [0,1,0],
                                      [0,0,1]],
                                      size=(1,1,1),
                                      symbol=<span style="color: #00cd00;">'Fe'</span>)

NUPDOWNS = [0.0, 2.0, 4.0, 5.0, 6.0, 8.0]
energies = []
<span style="color: #cd0000; font-weight: bold;">for</span> B <span style="color: #cd0000; font-weight: bold;">in</span> NUPDOWNS:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Fe-bcc-fixedmagmom-{0:1.2f}'</span>.format(B),
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=300,
          kpts=(4,4,4),
          ispin=2,
          nupdown=B,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            e = atoms.get_potential_energy()
            energies.append(e)
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(NUPDOWNS, energies)
plt.xlabel(<span style="color: #00cd00;">'Total Magnetic Moment'</span>)
plt.ylabel(<span style="color: #00cd00;">'Energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/Fe-fixedmagmom.png'</span>)
</pre>




<div class="figure">
<p><img src="./images/Fe-fixedmagmom.png"  alt="./images/Fe-fixedmagmom.png" /></p>
<p>Total energy vs. total magnetic moment for bcc Fe.</p>
</div>

<p>
You can see here there is a minimum in energy at a total magnetic moment somewhere between 4 and 5. There are two Fe atoms in the unit cell, which means the magnetic moment on each atom must be about 2.5 Bohr-magnetons. This is a good guess for a real calculation. Note that VASP <a href="http://cms.mpi.univie.ac.at/vasp/guide/node100.html#SECTION00099000000000000000">recommends</a> you overestimate the magnetic moment guesses if you are looking for ferromagnetic solutions.
</p>
<p>
To run a spin-polarized calculation with initial guesses on each atom, we must set the magnetic moment on the atoms. Here we set it through the <code>magmom</code> attribute on the atom. In the example after this, we set it in the <code>Atoms</code> object.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> BodyCenteredCubic

atoms = BodyCenteredCubic(directions=[[1,0,0],
                                      [0,1,0],
                                      [0,0,1]],
                                      size=(1,1,1),
                                      symbol=<span style="color: #00cd00;">'Fe'</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">set magnetic moments on each atom</span>
<span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms:
    atom.magmom = 2.5

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Fe-bcc-sp-1'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=300,
          kpts=(4,4,4),
          ispin=2,
          lorbit=11, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">you need this for individual magnetic moments</span>
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            e = atoms.get_potential_energy()
            B = atoms.get_magnetic_moment()
            magmoms = atoms.get_magnetic_moments()
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Total magnetic moment is {0:1.2f} Bohr-magnetons'</span>.format(B)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Individual moments are {0} Bohr-magnetons'</span>.format(magmoms)
</pre>


<pre class="example">
Total magnetic moment is 4.25 Bohr-magnetons
Individual moments are [ 2.134  2.134] Bohr-magnetons
</pre>


</div>

</div>

<div id="outline-container-4-12-2" class="outline-4">
<h4 id="sec-4-12-2"><span class="section-number-4">4.12.2</span> Antiferromagnetic spin states</h4>
<div class="outline-text-4" id="text-4-12-2">

<p>In an antiferromagnetic material, there are equal numbers of spin up and down electrons that align in a regular pattern, but pointing in opposite directions so that there is no net magnetism. It is possible to model this by setting the magnetic moments on each <TT>ase.Atom</TT> object.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

atoms = Atoms([Atom(<span style="color: #00cd00;">'Fe'</span>,[0.00,  0.00,  0.00], magmom=5),
               Atom(<span style="color: #00cd00;">'Fe'</span>,[4.3,   4.3,   4.3],  magmom=-5),
               Atom(<span style="color: #00cd00;">'O'</span>, [2.15,  2.15,  2.15], magmom=0),
               Atom(<span style="color: #00cd00;">'O'</span>, [6.45,  6.45,  6.45], magmom=0)],
               cell=[[4.3,    2.15,    2.15],
                     [2.15,    4.3,     2.15],
                     [2.15,    2.15,    4.3]])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/afm-feo'</span>,
          encut=350,
          prec=<span style="color: #00cd00;">'Normal'</span>,
          ispin=2,
          nupdown=0, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this forces a non-magnetic solution</span>
          lorbit=11, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">to get individual moments</span>
          lreal=<span style="color: #cd0000; font-weight: bold;">False</span>,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Magnetic moments = '</span>,atoms.get_magnetic_moments()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Total magnetic moment = '</span>,atoms.get_magnetic_moment()

</pre>


<pre class="example">
Magnetic moments =  [ 2.652 -2.652  0.     0.   ]
Total magnetic moment =  0.0
</pre>


<p>
You can see that even though the total magnetic moment is 0, there is a spin on both Fe atoms, and they are pointing in opposite directions. Hence, the sum of spins is zero, and this arrangement is called anti-ferromagnetic.
</p>
</div>

</div>

<div id="outline-container-4-12-3" class="outline-4">
<h4 id="sec-4-12-3"><span class="section-number-4">4.12.3</span> <span class="todo TODO">TODO</span> NiO-FeO formation energies with magnetism</h4>
<div class="outline-text-4" id="text-4-12-3">

</div>
</div>

</div>

<div id="outline-container-4-13" class="outline-3">
<h3 id="sec-4-13"><span class="section-number-3">4.13</span> <span class="todo TODO">TODO</span> phonons</h3>
<div class="outline-text-3" id="text-4-13">

<p>(<cite>RevModPhys.73.515</cite>)
</p>
</div>

</div>

<div id="outline-container-4-14" class="outline-3">
<h3 id="sec-4-14"><span class="section-number-3">4.14</span> <span class="todo TODO">TODO</span> solid state NEB</h3>
<div class="outline-text-3" id="text-4-14">

<p>(<cite>Caspersen10052005</cite>) Carter paper
(<cite>sheppard:074103</cite>) recent Henkelman paper
</p></div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Surfaces</h2>
<div class="outline-text-2" id="text-5">


</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Surface structures</h3>
<div class="outline-text-3" id="text-5-1">

<p>As with molecules and bulk systems <TT>ase</TT> provides several convenience functions for making surfaces.
</p>
</div>

<div id="outline-container-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><span class="section-number-4">5.1.1</span> Simple surfaces</h4>
<div class="outline-text-4" id="text-5-1-1">

<p>ase provides many <a href="https://wiki.fysik.dtu.dk/ase/ase/surface.html#module-ase.lattice.surface">utility functions</a> to setup surfaces. Here is a simple example of an fcc111 Al surface. There are built in functions for fcc111, bcc110, bcc111, hcp001 and diamond111.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

slab = fcc111(<span style="color: #00cd00;">'Al'</span>, size=(2,2,3), vacuum=10.0)

write(<span style="color: #00cd00;">'images/Al-slab.png'</span>, slab, rotation=<span style="color: #00cd00;">'90x'</span>,show_unit_cell=2)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/Al-slab.png"  alt="./images/Al-slab.png" /></p>
<p>An Al(111) slab with three layers and 20 &Aring; of vacuum.</p>
</div>

</div>

</div>

<div id="outline-container-5-1-2" class="outline-4">
<h4 id="sec-5-1-2"><span class="section-number-4">5.1.2</span> Vicinal surfaces</h4>
<div class="outline-text-4" id="text-5-1-2">


<p>
The vast majority of surface calculations are performed on flat surfaces. This is partially because these surfaces tend to have the lowest surface energies, and thus are likely to be experimentally observed. The flat surfaces, also known as low Miller index surfaces, also have small unit cells, which tends to make them computationally affordable. There are, however, many reasons to model the properties of surfaces that are not flat. You may be interested in the reactivity of a step edge, for example, or you may use the lower cooridnation of steps as a proxy for nanoparticle reactivity.  Many stepped surfaces are not that difficult to make now. The main idea in generating them is described <a href="https://wiki.fysik.dtu.dk/ase/_downloads/general_surface.pdf">here</a>. <TT>ase</TT> provides a general function for making vicinal surfaces. Here is an example of a (211) surface.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> surface
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Au(211) with 9 layers</span>
s1 = surface(<span style="color: #00cd00;">'Au'</span>, (2, 1, 1), 9)
s1.center(vacuum=10, axis=2)

write(<span style="color: #00cd00;">'images/Au-211.png'</span>,
      s1.repeat((3,3,1)),
      rotation=<span style="color: #00cd00;">'-30z,90x'</span>, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">change the orientation for viewing</span>
      show_unit_cell=2)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/Au-211.png"  alt="./images/Au-211.png" /></p>
<p>An Au(211) surface constructed with <code>ase</code>.</p>
</div>

</div>
</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Surface calculation parameters</h3>
<div class="outline-text-3" id="text-5-2">

<p>There is one important parameter that is different for surfaces than for bulk calculations, the k-point grid. Assuming you have followed the convention that the z-axis is normal to the surface, the k-point grids for slab calculations always have the form of <img src="ltxpng/dft_2134204b35645dd575bfdc3ffbb889dcedcfa882.png" alt="$M \times N \times 1$"/>. To illustrate why, consider this example:
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> jasp.jasp_bandstructure <span style="color: #cd0000; font-weight: bold;">import</span> *
JASPRC[<span style="color: #00cd00;">'mode'</span>]=<span style="color: #00cd00;">'run'</span>
slab = fcc111(<span style="color: #00cd00;">'Al'</span>, size=(1,1,4), vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surface/Al-bandstructure'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=300,
          kpts=(6,6,6),
          atoms=slab) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    n,bands,p  = calc.get_bandstructure(kpts_path=[(<span style="color: #00cd00;">'$\Gamma$'</span>, [0,0,0]),
                                                   (<span style="color: #00cd00;">'$K1$'</span>, [0.5, 0.0, 0.0]),
                                                   (<span style="color: #00cd00;">'$K1$'</span>, [0.5,0.0,0.0]),
                                                   (<span style="color: #00cd00;">'$K2$'</span>, [0.5,0.5,0.0]),
                                                   (<span style="color: #00cd00;">'$K2$'</span>, [0.5,0.5,0.0]),
                                                   (<span style="color: #00cd00;">'$\Gamma$'</span>, [0,0,0]),
                                                   (<span style="color: #00cd00;">'$\Gamma$'</span>, [0,0,0]),
                                                   (<span style="color: #00cd00;">'$K3$'</span>, [0.0, 0.0, 1.0])],
                                                   kpts_nintersections=10)

p.savefig(<span style="color: #00cd00;">'images/Al-slab-bandstructure.png'</span>)
p.show()
</pre>




<div class="figure">
<p><img src="./images/Al-slab-bandstructure.png"  alt="./images/Al-slab-bandstructure.png" /></p>
<p>Band structure of an Al slab in the plane (path from Gamma to K1 to K2 to Gamma) and normal to the surface (Gamma to K3). Note the bands are flat in the direction normal to the surface, hence only one k-point is needed in this direction.</p>
</div>

</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Surface relaxation</h3>
<div class="outline-text-3" id="text-5-3">

<p>When a surface is created, the bulk symmetry is broken and consequently there will be forces on the surface atoms. We will examine some consequences of this with a simple Al slab. First, we show there are forces on the slab atoms.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111

atoms = fcc111(<span style="color: #00cd00;">'Al'</span>, size=(1,1,4), vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-slab-unrelaxed'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(6,6,1),
          encut=350,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms.get_forces()
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
</pre>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/surfaces/Al-slab-unrelaxed
  converged: True
  Energy = -14.177069 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 2.864  0.000  0.000] 2.864
  a1 [ 1.432  2.480  0.000] 2.864
  a2 [ 0.000  0.000  27.015] 27.015
  a,b,c,alpha,beta,gamma (deg): 2.864 2.864 27.015 90.0 90.0 90.0
  Unit cell volume = 191.872 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
             0.007  0.007  0.002 -0.000 -0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce
   0    Al  [0.000      0.000     10.000]   4   0.01
   1    Al  [1.432      0.827     12.338]   3   0.18
   2    Al  [2.864      1.653     14.677]   2   0.18
   3    Al  [0.000      0.000     17.015]   1   0.01
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 10
         encut: 350.0
          prec: Normal
          kpts: [6 6 1]
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
Al: potpaw_PBE/Al/POTCAR (git-hash: c8d9ecb0b6ebec0256c5f5072cee4de6a046dac2)
</pre>


<p>
Some points to note. The forces on the atoms have symmetry to them. That is because the slab is centered. Had the slab had an odd number of atoms, it is likely the center atom would have no forces on it. Next we consider the spacing between each layer in the slab. We do this for comparison later.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111

atoms = fcc111(<span style="color: #00cd00;">'Al'</span>, size=(1,1,4), vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-slab-unrelaxed'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Total energy: {0:1.3f} eV'</span>.format(atoms.get_potential_energy())

    <span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(1,<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0}  deltaz = {1:1.3f} angstroms'</span>.format(i,atoms[i].z - atoms[i-1].z)
</pre>


<pre class="example">
Total energy: -14.177 eV
1  deltaz = 2.338 angstroms
2  deltaz = 2.338 angstroms
3  deltaz = 2.338 angstroms
</pre>


<p>
To reduce the forces, we can let VASP relax the geometry. We have to make some decisions about how to relax the slab. One choice would be to relax all the atoms in the slab. If we do that, then there will be no atoms with bulk like spacing unless we increase the slab thickness pretty dramatically. It is pretty common to freeze some atoms at the bulk coordinates, and let the others relax. We will freeze the bottom two layers (defined by tags 3 and 4) and let the first two layers relax. To do that we add constraints to the slab.
</p>
<p>
Note: the <a href="https://wiki.fysik.dtu.dk/ase/ase/constraints.html">ase constraints</a> are only partially used by <code>jasp</code>. The <TT>ase.constraints.FixAtoms</TT> constraint gets written to the POSCAR file, and is then used internally in VASP. The only other constraint that VASP can use internally is <TT>ase.constraints.FixScaled</TT>. The other constraints are not written to the POSCAR and are not used by VASP.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Al'</span>, size=(1,1,4), vacuum=10.0)

constraint = FixAtoms(mask=[atom.tag &gt;= 3 <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-slab-relaxed'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(6,6,1),
          encut=350,
          ibrion=2,
          isif=2,
          nsw=10, debug=logging.DEBUG,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
</pre>



<pre class="example">[4 3 2 1]
[4 3 2 1]
: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/surfaces/Al-slab-relaxed
  converged: True
  Energy = -14.181617 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 2.864  0.000  0.000] 2.864
  a1 [ 1.432  2.480  0.000] 2.864
  a2 [ 0.000  0.000  27.015] 27.015
  a,b,c,alpha,beta,gamma (deg): 2.864 2.864 27.015 90.0 90.0 90.0
  Unit cell volume = 191.872 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
            -9.293 -9.293 -1.593  0.000  0.000  0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    Al  [0.000      0.000     10.000]   4   0.00      F F F
   1    Al  [1.432      0.827     12.338]   3   0.00      F F F
   2    Al  [2.864      1.653     14.627]   2   0.00      T T T
   3    Al  [0.000      0.000     16.979]   1   0.04      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 10
           nsw: 10
        ibrion: 2
          isif: 2
         encut: 350.0
        magmom: None
          prec: Normal
          kpts: (6, 6, 1)
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
Al: potpaw_PBE/Al/POTCAR (git-hash: c8d9ecb0b6ebec0256c5f5072cee4de6a046dac2)
</pre>


<p>
You can see that atoms 2 and 3 (the ones we relaxed, because the have tags of 1 and 2, which are less than 3) now have very low forces on them and it appears that atoms 0 and 1 have no forces on them. That is because the FixAtoms constraint works by setting the forces on those atoms to zero. We can see in the next example that the z-positions of the relaxed atoms have indeed relaxed and changed, while the position of the frozen atoms did not change.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111

atoms = fcc111(<span style="color: #00cd00;">'Al'</span>, size=(1,1,4), vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-slab-relaxed'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Total energy: {0:1.3f}'</span>.format(atoms.get_potential_energy())

    <span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(1,<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)):
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'d_({0},{1}) = {2:1.3f} angstroms'</span>.format(i,i-1,
                                                   atoms[i].z - atoms[i-1].z)

</pre>


<pre class="example">
Total energy: -14.182
d_(1,0) = 2.338 angstroms
d_(2,1) = 2.289 angstroms
d_(3,2) = 2.352 angstroms
</pre>


<p>
Depending on the layer there is either slight contraction or expansion. These quantities are small, and careful convergence studies should be performed. Note the total energy change from unrelaxed to relaxed is not that large in this case (e.g., it is about 5 meV). This is usually the case for metals, where the relaxation effects are relatively small. In oxides and semiconductors, the effects can be large, and when there are adsorbates, the effects can be large also.
</p>
</div>

</div>

<div id="outline-container-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Surface reconstruction</h3>
<div class="outline-text-3" id="text-5-4">



<p>
We previously considered how relaxation can lower the surface energy. For some surfaces, a more extreme effect can reduce the surface energy: reconstruction. In a simple surface relaxation, the basic structure of a surface is preserved. However, sometimes there is a different surface structure that may have a lower surface energy. Some famous reconstructions include: Si-<img src="ltxpng/dft_408220c15464e96b9d4c3a1ce8199215d7d1270a.png" alt="\(\sqrt{7}\times\sqrt{7}\)"/>, Pt(100) hex reconstruction (<cite>PhysRevB.56.10518,PhysRevB.82.161418</cite>), and the Au(111) herringbone reconstruction.
</p>
<p>
We will consider the (110) missing row reconstruction (<cite>PhysRevB.83.075415</cite>). For some metals, especially Pt and Au, it is energetically favorable to form the so-called missing row reconstruction where every other row in the surface is "missing". It is favorable because it lowers the surface energy. Let us consider how we might calculate and predict that. It is straightforward to compute the energy of a (110) slab, and of a (110) slab with one row missing. However, these slabs contain different numbers of atoms, so we cannot directly compare the total energies to determine which energy is lower.
</p>
<p>
We have to consider where the missing row atoms have gone, so we can account for their energy. We will consider that they have gone into the bulk, and so we to consider the energy associated with the following transformation:
</p>
<p>
slab<sub>110</sub> <img src="ltxpng/dft_afcd1ec2b9c0e6e652704c1b8acb812cc11941cc.png" alt="$\rightarrow$"/> slab<sub>missing row</sub> + bulk
</p>
<p>
Thus, if this change in energy: <img src="ltxpng/dft_3249ae5202526decba816d72d5ddec74cf387f05.png" alt="\(E_{bulk} + E_{slab_{missing row}} - E_{slab_{110}} \)"/> is negative, then the formation of the missing row is expected to be favorable.
</p>

</div>

<div id="outline-container-5-4-1" class="outline-4">
<h4 id="sec-5-4-1"><span class="section-number-4">5.4.1</span> Au(110) missing row reconstruction</h4>
<div class="outline-text-4" id="text-5-4-1">

<p>We first consider the Au(110) case, where the reconstruction is known to be favorable.
</p>
</div>

<div id="outline-container-5-4-1-1" class="outline-5">
<h5 id="sec-5-4-1-1"><span class="section-number-5">5.4.1.1</span> Clean Au(110) slab</h5>
<div class="outline-text-5" id="text-5-4-1-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc110
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc110(<span style="color: #00cd00;">'Au'</span>, size=(2,1,6), vacuum=10.0)
constraint = FixAtoms(mask=[atom.tag &gt; 2 <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

write(<span style="color: #00cd00;">'images/Au-110.png'</span>, atoms.repeat((2,2,1)), rotation=<span style="color: #00cd00;">'-90x'</span>, show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Au-110'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(6,6,1),
          encut=350,
          ibrion=2,
          isif=2,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>




<div class="figure">
<p><img src="./images/Au-110.png"  alt="./images/Au-110.png" /></p>
<p>The unreconstructed Au(110) surface viewed from the side.</p>
</div>

</div>

</div>

<div id="outline-container-5-4-1-2" class="outline-5">
<h5 id="sec-5-4-1-2"><span class="section-number-5">5.4.1.2</span> Missing row in Au(110)</h5>
<div class="outline-text-5" id="text-5-4-1-2">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc110
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc110(<span style="color: #00cd00;">'Au'</span>, size=(2,1,6), vacuum=10.0)
<span style="color: #cd0000; font-weight: bold;">del</span> atoms[11] <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">delete surface row</span>

constraint = FixAtoms(mask=[atom.tag &gt; 2 <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

write(<span style="color: #00cd00;">'images/Au-110-missing-row.png'</span>, atoms.repeat((2,2,1)), rotation=<span style="color: #00cd00;">'-90x'</span>, show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Au-110-missing-row'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(6,6,1),
          encut=350,
          ibrion=2,
          isif=2,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>




<div class="figure">
<p><img src="./images/Au-110-missing-row.png"  alt="./images/Au-110-missing-row.png" /></p>
<p>Au(110) with the missing row reconstruction.</p>
</div>

</div>

</div>

<div id="outline-container-5-4-1-3" class="outline-5">
<h5 id="sec-5-4-1-3"><span class="section-number-5">5.4.1.3</span> Bulk Au</h5>
<div class="outline-text-5" id="text-5-4-1-3">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.visualize <span style="color: #cd0000; font-weight: bold;">import</span> view
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic

atoms = FaceCenteredCubic(directions=[[0,1,1],
                                      [1,0,1],
                                      [1,1,0]],
                                      size=(1,1,1),
                                      symbol=<span style="color: #00cd00;">'Au'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Au-fcc'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(12,12,12),
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>



</div>

</div>

<div id="outline-container-5-4-1-4" class="outline-5">
<h5 id="sec-5-4-1-4"><span class="section-number-5">5.4.1.4</span> Analysis of energies</h5>
<div class="outline-text-5" id="text-5-4-1-4">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Au-110'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    slab = calc.get_atoms()
    eslab = slab.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Au-110-missing-row'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    missingrow = calc.get_atoms()
    emissingrow = missingrow.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Au-fcc'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    bulk = calc.get_atoms()
    ebulk = bulk.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'natoms slab        = {0}'</span>.format(<span style="color: #cd0000; font-weight: bold;">len</span>(slab))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'natoms missing row = {0}'</span>.format(<span style="color: #cd0000; font-weight: bold;">len</span>(missingrow))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'natoms bulk        = {0}'</span>.format(<span style="color: #cd0000; font-weight: bold;">len</span>(bulk))

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'dE = {0:1.3f} eV'</span>.format(emissingrow + ebulk - eslab)
</pre>


<pre class="example">
natoms slab        = 12
natoms missing row = 11
natoms bulk        = 1
dE = -0.070 eV
</pre>


<p>
The missing row formation energy is slightly negative. The magnitude of the formation energy is pretty small, but just slightly bigger than the typical convergence errors observed, so we should cautiously conclude that the reconstruction if favorable for Au(110). We made a lot of shortcuts in computing this quantity, including using the experimental lattice constant of Au, not checking for convergence in k-points or planewave cutoff, and not checking for convergence with respect to slab thickness or number of relaxed layers.
</p>
</div>
</div>

</div>

<div id="outline-container-5-4-2" class="outline-4">
<h4 id="sec-5-4-2"><span class="section-number-4">5.4.2</span> Ag(110) missing row reconstruction</h4>
<div class="outline-text-4" id="text-5-4-2">


</div>

<div id="outline-container-5-4-2-1" class="outline-5">
<h5 id="sec-5-4-2-1"><span class="section-number-5">5.4.2.1</span> Clean Ag(110) slab</h5>
<div class="outline-text-5" id="text-5-4-2-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc110
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc110(<span style="color: #00cd00;">'Ag'</span>, size=(2,1,6), vacuum=10.0)
constraint = FixAtoms(mask=[atom.tag &gt; 2 <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Ag-110'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(6,6,1),
          encut=350,
          ibrion=2,
          isif=2,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>



</div>

</div>

<div id="outline-container-5-4-2-2" class="outline-5">
<h5 id="sec-5-4-2-2"><span class="section-number-5">5.4.2.2</span> Missing row in Ag(110)</h5>
<div class="outline-text-5" id="text-5-4-2-2">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc110
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc110(<span style="color: #00cd00;">'Ag'</span>, size=(2,1,6), vacuum=10.0)
<span style="color: #cd0000; font-weight: bold;">del</span> atoms[11] <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">delete surface row</span>

constraint = FixAtoms(mask=[atom.tag &gt; 2 <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Ag-110-missing-row'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(6,6,1),
          encut=350,
          ibrion=2,
          isif=2,
          nsw=10,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>



</div>

</div>

<div id="outline-container-5-4-2-3" class="outline-5">
<h5 id="sec-5-4-2-3"><span class="section-number-5">5.4.2.3</span> Bulk Ag</h5>
<div class="outline-text-5" id="text-5-4-2-3">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.visualize <span style="color: #cd0000; font-weight: bold;">import</span> view
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic

atoms = FaceCenteredCubic(directions=[[0,1,1],
                                      [1,0,1],
                                      [1,1,0]],
                                      size=(1,1,1),
                                      symbol=<span style="color: #00cd00;">'Ag'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Ag-fcc'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(12,12,12),
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>



</div>

</div>

<div id="outline-container-5-4-2-4" class="outline-5">
<h5 id="sec-5-4-2-4"><span class="section-number-5">5.4.2.4</span> Analysis of energies</h5>
<div class="outline-text-5" id="text-5-4-2-4">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Ag-110'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    slab = calc.get_atoms()
    eslab = slab.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Ag-110-missing-row'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    missingrow = calc.get_atoms()
    emissingrow = missingrow.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Ag-fcc'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    bulk = calc.get_atoms()
    ebulk = bulk.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'natoms slab        = {0}'</span>.format(<span style="color: #cd0000; font-weight: bold;">len</span>(slab))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'natoms missing row = {0}'</span>.format(<span style="color: #cd0000; font-weight: bold;">len</span>(missingrow))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'natoms bulk        = {0}'</span>.format(<span style="color: #cd0000; font-weight: bold;">len</span>(bulk))

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'dE = {0:1.3f} eV'</span>.format(emissingrow + ebulk - eslab)
</pre>


<pre class="example">
natoms slab        = 12
natoms missing row = 11
natoms bulk        = 1
dE = -0.008 eV
</pre>


<p>
For Ag(110), the missing row formation energy is practically thermoneutral, i.e. not that favorable. This energy is so close to 0eV, that we cannot confidently say whether the reconstruction is favorable or not. Experimentally, the reconstruction is not seen on very clean Ag(110) although it is reported that some adsorbates may induce the reconstruction (<cite>PhysRevLett.59.2307</cite>).
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Work function</h3>
<div class="outline-text-3" id="text-5-5">


<p>
To get the work function, we need to have the local potential. This is not written by default in VASP, and we have to tell it to do that with the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/LVTOT>LVTOT</a> and <a href=http://cms.mpi.univie.ac.at/wiki/index.php/LVHAR>LVHAR</a> keywords.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-slab-relaxed'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-slab-locpot'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(6,6,1),
          encut=350,
          lvtot=<span style="color: #cd0000; font-weight: bold;">True</span>, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">write out local potential</span>
          lvhar=<span style="color: #cd0000; font-weight: bold;">True</span>, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">write out only electrostatic potential, not xc pot</span>
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    calc.calculate()
    ef = calc.get_fermi_level()

    atoms = calc.get_atoms()

    x,y,z,lp = calc.get_local_potential()

nx, ny, nz = lp.shape

axy = np.array([np.average(lp[:,:,z]) <span style="color: #cd0000; font-weight: bold;">for</span> z <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(nz)])
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">setup the x-axis in realspace</span>
uc = atoms.get_cell()
xaxis = np.linspace(0, uc[2][2], nz)

plt.plot(xaxis, axy)
plt.plot([<span style="color: #cd0000; font-weight: bold;">min</span>(xaxis), <span style="color: #cd0000; font-weight: bold;">max</span>(xaxis)], [ef, ef],<span style="color: #00cd00;">'k:'</span>)
plt.xlabel(<span style="color: #00cd00;">'Position along z-axis'</span>)
plt.ylabel(<span style="color: #00cd00;">'x-y averaged electrostatic potential'</span>)
plt.savefig(<span style="color: #00cd00;">'images/Al-wf.png'</span>)

ind = (xaxis &gt; 0) &amp; (xaxis &lt; 5)
wf = np.average(axy[ind]) - ef
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">' The workfunction is {0:1.2f} eV'</span>.format(wf)
</pre>


<pre class="example">
 The workfunction is 4.04 eV
</pre>


<p>
The workfunction of Al is listed as 4.08 at <a href="http://hyperphysics.phy-astr.gsu.edu/hbase/tables/photoelec.html">http://hyperphysics.phy-astr.gsu.edu/hbase/tables/photoelec.html</a>.
</p>

<div class="figure">
<p><img src="./images/Al-wf.png"  alt="./images/Al-wf.png" /></p>
<p>$xy$ averaged local electrostatic potential of an Al(111) slab.</p>
</div>

</div>

</div>

<div id="outline-container-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> Surface energy</h3>
<div class="outline-text-3" id="text-5-6">

<p>The easiest way to calculate surface energies is from this equation:
</p>
<p>
<img src="ltxpng/dft_21ce6982948af4a761b2f7ed2336e21676f307ba.png" alt="$\sigma = \frac{1}{2}(E_{slab} - \frac{N_{slab}}{N_{bulk}} E_{bulk})$"/>
</p>
<p>
where <img src="ltxpng/dft_59f2ab2bb3384821c52527057365e115b236b6a9.png" alt="$E_{slab}$"/> is the total energy of a symmetric slab (i.e. one with inversion symmetry, and where both sides of the slab have been relaxed), <img src="ltxpng/dft_ad69ca6f751709168564a7e39c608b35835374d6.png" alt="$E_{bulk}$"/> is the total energy of a bulk unit cell, <img src="ltxpng/dft_607a14487e9dc41b64c52bbdfd4d62c01c11e91a.png" alt="$N_{slab}$"/> is the number of atoms in the slab, and <img src="ltxpng/dft_968249fd045e9f7ccc2eb4137378db02afcf48f1.png" alt="$N_{bulk}$"/> is the number of atoms in the bulk unit cell. One should be sure that the bulk energy is fully converged with respect to <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-points, and that the slab energy is also converged with respect to <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-points. The energies should be compared at the same cutoff energies. The idea is then to increase the thickness of the slab until the surface energy <img src="ltxpng/dft_0976930bde4c8ad09a7c0783711fa2654ab5bce7.png" alt="$\sigma$"/> converges.
</p>


<div class="figure">
<p><img src="./images/surface-construction.png"  alt="./images/surface-construction.png" /></p>
<p>Schematic figure illustrating the calculation of a surface energy.</p>
</div>

<p>
Unfortunately, this approach does not always work. The bulk system is treated subtly different than the slab system, particularly in the <img src="ltxpng/dft_e9250f6ac1fdc9d8c2aa68e27459d678b8ef389b.png" alt="$z$"/>-direction where the vacuum is (where typically only one <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-point is used in slabs). Consequently, the <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-point sampling is not equivalent in the two systems, and one can in general expect some errors due to this, with the best case being cancellation of the errors due to total <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-point convergence. In the worst case, one can get a linear divergence in the surface energy with slab thickness (<cite>PhysRevB.49.16798</cite>).
</p>
<p>
A variation of this method that usually results in better <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-point error cancellation is to calculate the bulk unit cell energy using the slab unit cell with no vacuum space, with the same <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-point mesh in the <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/> and <img src="ltxpng/dft_7caba42fa0145427d12beda30808356e5038ef71.png" alt="$y$"/> directions, but with increased <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-points in the <img src="ltxpng/dft_e9250f6ac1fdc9d8c2aa68e27459d678b8ef389b.png" alt="$z$"/>-direction. Thus, the bulk system and slab system have the same Brillouin zone in at least two dimensions. This maximizes the cancellation of <img src="ltxpng/dft_110e5d8e2ff17c1b5f1ee940957995f76c6a1ac4.png" alt="$k$"/>-point errors, but still does not guarantee convergence of the surface energy, as discussed in (<cite>PhysRevB.49.16798,0953-8984-10-4-017</cite>).
</p>
<p>
For quick estimates of the surface energy, one of the methods described above is likely sufficient. The advantage of these methods is the small number of calculations required to obtain the estimate, one needs only a bulk calculation (which must be done anyhow to get the bulk lattice constant to create the slab), and a slab calculation that is sufficiently thick to get the estimate. Additional calculations are only required to test the convergence of the surface energy.
</p>
<p>
An alternative method for calculating surface energies that does not involve an explicit bulk calculation follows Ref. (<cite>0953-8984-10-4-017</cite>). The method follows from equation (ref{eq:se}) where for a N-atom slab, in the limit of N &rarr; &infin;,
</p>
<p>
<img src="ltxpng/dft_b8e7155eb5ad46ed6825dad608415cee3c18ef3a.png" alt="$E_{slab} \approx 2\sigma + \frac{N_{slab}}{N_{bulk}} E_{bulk}$"/>
</p>
<p>
Then, we can estimate E<sub>bulk</sub> by plotting the total energy of the slab as a function of the slab thickness.
</p>
<p>
<img src="ltxpng/dft_0cccf4e527e5473032401605d50e78b7b92a17c2.png" alt="$\sigma = \lim_{N \rightarrow \infty} \frac{1}{2}(E_{slab}^N - N \Delta E_N)$"/>
</p>
<p>
where <img src="ltxpng/dft_15925924950d4448d5ad5b207d0c5e7c3dd729c7.png" alt="$\Delta E_N = E_{slab}^N - E_{slab}^{N-1}$"/>.
</p>
<p>
We will examine this approach here. We will use unrelaxed slabs for computational efficiency.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

Nlayers = [3, 4, 5, 6, 7, 8, 9, 10, 11]
energies = []
sigmas = []

<span style="color: #cd0000; font-weight: bold;">for</span> n <span style="color: #cd0000; font-weight: bold;">in</span> Nlayers:

    slab = fcc111(<span style="color: #00cd00;">'Cu'</span>, size=(1,1,n), vacuum=10.0)
    slab.center()

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu-layers/{0}'</span>.format(n),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=350,
              kpts=(8,8,1),
              atoms=slab) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        calc.set_nbands(f=2) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">the default nbands in VASP is too low for Al</span>
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            energies.append(slab.get_potential_energy())
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">pass</span>

<span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(len(Nlayers)-1):
    N = Nlayers[i]
    DeltaE_N = energies[i+1] - energies[i]
    sigma = 0.5*(-N*energies[i+1] + (N+1)*energies[i])
    sigmas.append(sigma)
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'nlayers = {1:2d} sigma = {0:1.3f} eV/atom'</span>.format(sigma, N)

plt.plot(Nlayers[0:-1], sigmas,<span style="color: #00cd00;">'bo-'</span>)
plt.xlabel(<span style="color: #00cd00;">'Number of layers'</span>)
plt.ylabel(<span style="color: #00cd00;">'Surface energy (eV/atom)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/Cu-unrelaxed-surface-energy.png'</span>)
</pre>


<pre class="example">
nlayers =  3 sigma = 0.552 eV/atom
nlayers =  4 sigma = 0.398 eV/atom
nlayers =  5 sigma = 0.590 eV/atom
nlayers =  6 sigma = 0.318 eV/atom
nlayers =  7 sigma = 0.580 eV/atom
nlayers =  8 sigma = 0.321 eV/atom
nlayers =  9 sigma = 0.593 eV/atom
nlayers = 10 sigma = 0.402 eV/atom
</pre>



<div class="figure">
<p><img src="./images/Cu-unrelaxed-surface-energy.png"  alt="./images/Cu-unrelaxed-surface-energy.png" /></p>
<p>Surface energy of a Cu(111) slab as a function of thickness.</p>
</div>
<p>
One reason for the oscillations may be quantum size effects (<cite>Fiolhais2003209</cite>). In (<cite>PhysRevB.75.115131</cite>) the surface energy of Cu(111) is reported as 0.48 eV/atom, or 1.36 J/m<img src="ltxpng/dft_8a2dfedb9d49718e8566eb6410afaf75f4319d24.png" alt="$^2$"/>. Here is an example showing a conversion between these two units. We use ase to compute the area of the unit cell from the norm of the cross-product of the vectors defining the surface unit cell.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> J, m
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

slab = fcc111(<span style="color: #00cd00;">'Cu'</span>, size=(1,1,3), vacuum=10.0)
cell = slab.get_cell()

area = np.linalg.norm(np.cross(cell[0], cell[1]))

sigma = 0.48 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">eV/atom</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'sigma = {0} J/m^2'</span>.format(sigma/area/(J/m**2))
</pre>


<pre class="example">
sigma = 1.3628146074 J/m^2
</pre>



</div>

<div id="outline-container-5-6-1" class="outline-4">
<h4 id="sec-5-6-1"><span class="section-number-4">5.6.1</span> Advanced topics in surface energy</h4>
<div class="outline-text-4" id="text-5-6-1">

<p>The surface energies can be used to estimate the shapes of nanoparticles using a Wulff construction. See (<cite>doi.10.1021/jp200950a</cite>) for an example of computing Mo<sub>2</sub>C surface energies and particle shapes, and (<cite>Inoglu2009188</cite>) for an example of the influence of adsorbates on surface energies and particle shapes of Cu.
</p>
<p>
For a classic paper on trends in surface energies see (<cite>Vitos1998186</cite>).
</p>
</div>
</div>

</div>

<div id="outline-container-5-7" class="outline-3">
<h3 id="sec-5-7"><span class="section-number-3">5.7</span> Dipole correction</h3>
<div class="outline-text-3" id="text-5-7">



<p>
A subtle problem can arise when an adsorbate is placed on one side of
a slab with periodic boundary conditions, which is currently the
common practice.  The problem is that this gives the slab a dipole
moment. The array of dipole moments created by the periodic boundary
conditions generates an electric field that can distort the electron
density of the slab and change the energy. The existence of this field
in the vacuum also makes the zero-potential in the vacuum ill-defined,
thus the work function is not well-defined. One solution to this
problem is to use slabs with adsorbates on both sides, but then very
thick (eight to ten layers) slabs must be used to ensure the
adsorbates do not interact through the slab. An alternative solution,
the dipole correction scheme, was developed by Neugebauer and
Scheffler (<cite>PhysRevB.46.16067</cite>) and later corrected by Bengtsson
(<cite>PhysRevB.59.12301</cite>). In this technique, an external field is
imposed in the vacuum region that exactly cancels the artificial field
caused by the slab dipole moment. The advantage of this approach is
that thinner slabs with adsorbates on only one side can be used.
</p>
<p>
There are also literature reports that the correction is small
(<cite>morikawa2001:c2h2-si</cite>).  Nevertheless, in the literature the use
of this correction is fairly standard, and it is typical to at least
consider the correction.
</p>
<p>
Here we will just illustrate the effect.
</p>
</div>

<div id="outline-container-5-7-1" class="outline-4">
<h4 id="sec-5-7-1"><span class="section-number-4">5.7.1</span> Slab with no dipole correction</h4>
<div class="outline-text-4" id="text-5-7-1">

<p>We simply run the calculation here, and compare the results later.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">compute local potential of slab with no dipole</span>
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

slab = fcc111(<span style="color: #00cd00;">'Al'</span>, size=(2,2,2), vacuum=10.0)
add_adsorbate(slab, <span style="color: #00cd00;">'Na'</span>, height=1.2, position=<span style="color: #00cd00;">'fcc'</span>)

slab.center()
write(<span style="color: #00cd00;">'images/Na-Al-slab.png'</span>, slab, rotation=<span style="color: #00cd00;">'-90x'</span>, show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-Na-nodip'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=340,
          kpts=(2, 2, 1),
          lvtot=<span style="color: #cd0000; font-weight: bold;">True</span>, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">write out local potential</span>
          lvhar=<span style="color: #cd0000; font-weight: bold;">True</span>, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">write out only electrostatic potential, not xc pot</span>
          atoms=slab) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/Na-Al-slab.png"  alt="./images/Na-Al-slab.png" /></p>
<p>Example slab with a Na atom on it for illustrating the effects of dipole corrections.</p>
</div>

</div>

</div>

<div id="outline-container-5-7-2" class="outline-4">
<h4 id="sec-5-7-2"><span class="section-number-4">5.7.2</span> Slab with a dipole correction</h4>
<div class="outline-text-4" id="text-5-7-2">

<p>    Note this takes a considerably longer time to run than without a dipole correction! In VASP there are several levels of dipole correction to apply. You can use the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/IDIPOL>IDIPOL</a> tag to turn it on, and specify which direction to apply it in (1=<img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/>, 2=<img src="ltxpng/dft_7caba42fa0145427d12beda30808356e5038ef71.png" alt="$y$"/>, 3=<img src="ltxpng/dft_e9250f6ac1fdc9d8c2aa68e27459d678b8ef389b.png" alt="$z$"/>, 4=<img src="ltxpng/dft_9aac708762d70746720cd1e43eeddef178fd97bc.png" alt="$(x,y,z)$"/>). This simply corrects the total energy and forces. It does not change the contents of LOCPOT. For that, you have to also set the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/LDIPOL>LDIPOL</a> and <a href=http://cms.mpi.univie.ac.at/wiki/index.php/DIPOL>DIPOL</a> tags. It is not efficient to set all three at the same time for some reason. The VASP manual recommends you first set IDIPOL to get a converged electronic structure, and then set LDIPOL to True, and set the center of electron density in DIPOL. That makes these calculations a multistep process, because we must run a calculation, analyze the charge density to get the center of charge, and then run a second calculation.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">compute local potential with dipole calculation on</span>
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

slab = fcc111(<span style="color: #00cd00;">'Al'</span>, size=(2, 2, 2), vacuum=10.0)
add_adsorbate(slab, <span style="color: #00cd00;">'Na'</span>, height=1.2, position=<span style="color: #00cd00;">'fcc'</span>)

slab.center()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-Na-dip'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=340,
          kpts=(2, 2, 1),
          idipol=3,   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">only along z-axis</span>
          lvtot=<span style="color: #cd0000; font-weight: bold;">True</span>, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">write out local potential</span>
          lvhar=<span style="color: #cd0000; font-weight: bold;">True</span>, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">write out only electrostatic potential, not xc pot</span>
          atoms=slab) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    calc.calculate()

    x, y, z, cd = calc.get_charge_density()
    n0, n1, n2 = cd.shape
    nelements = n0 * n1 * n2
    voxel_volume = slab.get_volume() / nelements
    total_electron_charge = cd.sum() * voxel_volume

    electron_density_center = np.array([(cd * x).sum(),
                                        (cd * y).sum(),
                                        (cd * z).sum()])
    electron_density_center *= voxel_volume
    electron_density_center /= total_electron_charge

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'electron-density center = {0}'</span>.format(electron_density_center)
    uc = slab.get_cell()

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get scaled electron charge density center</span>
    sedc = np.dot(np.linalg.inv(uc.T),electron_density_center.T).T

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">we only write 4 decimal places out to the INCAR file, so we round here.</span>
    sedc = np.round(sedc,4)

    calc.clone(<span style="color: #00cd00;">'surfaces/Al-Na-dip-step2'</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now run step 2 with dipole set at scaled electron charge density center</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-Na-dip-step2'</span>,
           ldipol=<span style="color: #cd0000; font-weight: bold;">True</span>, dipol=sedc) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>


<pre class="example">
electron-density center = [  4.212   2.419  10.657]
</pre>


</div>

</div>

<div id="outline-container-5-7-3" class="outline-4">
<h4 id="sec-5-7-3"><span class="section-number-4">5.7.3</span> Comparing no dipole correction with a dipole correction</h4>
<div class="outline-text-4" id="text-5-7-3">

<p>To see the difference in what the dipole correction does, we now plot the potentials from each calculation.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-Na-nodip'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()

    x, y, z, lp = calc.get_local_potential()
    nx, ny, nz = lp.shape

    axy_1 = [np.average(lp[:,:,z]) <span style="color: #cd0000; font-weight: bold;">for</span> z <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(nz)]
    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">setup the x-axis in realspace</span>
    uc = atoms.get_cell()
    xaxis_1 = np.linspace(0,uc[2][2],nz)

    e1 = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Al-Na-dip-step2'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()

    x, y, z, lp = calc.get_local_potential()
    nx, ny, nz = lp.shape

    axy_2 = [np.average(lp[:,:,z]) <span style="color: #cd0000; font-weight: bold;">for</span> z <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(nz)]
    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">setup the x-axis in realspace</span>
    uc = atoms.get_cell()
    xaxis_2 = np.linspace(0,uc[2][2],nz)

    ef2 = calc.get_fermi_level()
    e2 = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'The difference in energy is {0} eV.'</span>.format(e2-e1)

plt.plot(xaxis_1, axy_1, label=<span style="color: #00cd00;">'no dipole correction'</span>)
plt.plot(xaxis_2, axy_2, label=<span style="color: #00cd00;">'dipole correction'</span>)
plt.plot([<span style="color: #cd0000; font-weight: bold;">min</span>(xaxis_2), <span style="color: #cd0000; font-weight: bold;">max</span>(xaxis_2)],[ef2,ef2], <span style="color: #00cd00;">'k:'</span>, label=<span style="color: #00cd00;">'Fermi level'</span>)
plt.xlabel(<span style="color: #00cd00;">'z ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'xy-averaged electrostatic potential'</span>)
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/dip-vs-nodip-esp.png'</span>)
</pre>


<pre class="example">
The difference in energy is 0.006391 eV.
</pre>



<div class="figure">
<p><img src="./images/dip-vs-nodip-esp.png"  alt="./images/dip-vs-nodip-esp.png" /></p>
<p>Comparison of the electrostatic potentials with a dipole correction and without it.</p>
</div>

<p>
The key points to notice in this figure are:
</p><ol>
<li>The two deep dips are where the atoms are.
</li>
<li>Without a dipole correction, the electrostatic potential never flattens out. there is near constant slope in the vacuum region, which means there is an electric field there.
</li>
<li>With a dipole moment the potential is flat in the vacuum region, except for the step jump near 23 &Aring;.
</li>
<li>The difference between the Fermi level and the flat vacuum potential is the work function.
</li>
<li>The difference in energy with and without the dipole correction here is small.
</li>
</ol>


</div>
</div>

</div>

<div id="outline-container-5-8" class="outline-3">
<h3 id="sec-5-8"><span class="section-number-3">5.8</span> Adsorption energies</h3>
<div class="outline-text-3" id="text-5-8">



</div>

<div id="outline-container-5-8-1" class="outline-4">
<h4 id="sec-5-8-1"><span class="section-number-4">5.8.1</span> Simple estimate of the adsorption energy</h4>
<div class="outline-text-4" id="text-5-8-1">

<p>Calculating an adsorption energy amounts to computing the energy of the following kind of reaction:
</p>
<p>
slab + gas-phase molecule <img src="ltxpng/dft_afcd1ec2b9c0e6e652704c1b8acb812cc11941cc.png" alt="$\rightarrow$"/> slab_adsorbate + products
</p>

<div class="figure">
<p><img src="./images/adsorbate-energy.png"  alt="./images/adsorbate-energy.png" /></p>
<p>Schematic of an adsorption process.</p>
</div>

<p>
There are many variations of this idea. The slab may already have some adsorbates on it, the slab may reconstruct on adsorption, the gas-phase molecule may or may not dissociate, and the products may or may not stick to the surface. We have to decide where to put the adsorbates, i.e. what site to put them on, and some sites will be more stable than others. We will consider the dissociative adsorption of O<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/> on three sites of a Pt(111) slab. We will assume the oxygen molecule has split in half, and that the atoms have moved far apart. We will model the oxygen coverage at 0.25 ML, which means we need to use a <img src="ltxpng/dft_f243901a53467af24730be0985e284ad434e57be.png" alt="$2 \times 2$"/> surface unit cell. For computational speed, we will freeze the slab, but allow the adsorbate to relax.
</p>
<p>
<img src="ltxpng/dft_bb7fd18945fdffe577721dc099b8c36f7b45110d.png" alt="$\Delta H_{ads} (eV/O) = E_{slab+O} - E_{slab} - 0.5*E_{O_2}$"/>
</p>
</div>

<div id="outline-container-5-8-1-1" class="outline-5">
<h5 id="sec-5-8-1-1"><span class="section-number-5">5.8.1.1</span> Calculations</h5>
<div class="outline-text-5" id="text-5-8-1-1">

<ul>
<li id="sec-5-8-1-1-1">clean slab calculation<br/>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Pt'</span>, size=(2,2,3), vacuum=10.0)
constraint = FixAtoms(mask=[<span style="color: #cd0000; font-weight: bold;">True</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(4,4,1),
          encut=350,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    slab_e = atoms.get_potential_energy()
</pre>


</li>
</ul>
<ul>
<li id="sec-5-8-1-1-2">fcc site<br/>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Pt'</span>, size=(2, 2, 3), vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">note this function only works when atoms are created by the surface module.</span>
add_adsorbate(atoms, <span style="color: #00cd00;">'O'</span>, height=1.2, position=<span style="color: #00cd00;">'fcc'</span>)

constraint = FixAtoms(mask=[atom.symbol != <span style="color: #00cd00;">'O'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-fcc'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=[4, 4, 1],
          encut=350,
          ibrion=2,
          nsw=25,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    calc.calculate()
</pre>



</li>
</ul>
<ul>
<li id="sec-5-8-1-1-3">O atom on the bridge site<br/>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Pt'</span>, size=(2, 2, 3), vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">note this function only works when atoms are created by the surface module.</span>
add_adsorbate(atoms, <span style="color: #00cd00;">'O'</span>, height=1.2, position=<span style="color: #00cd00;">'bridge'</span>)

constraint = FixAtoms(mask=[atom.symbol != <span style="color: #00cd00;">'O'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-bridge'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(4,4,1),
          encut=350,
          ibrion=2,
          nsw=25,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    calc.calculate()
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_potential_energy()
</pre>


<pre class="example">
-73.663615
</pre>


</li>
</ul>
<ul>
<li id="sec-5-8-1-1-4">hcp site<br/>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Pt'</span>, size=(2,2,3), vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">note this function only works when atoms are created by the surface module.</span>
add_adsorbate(atoms, <span style="color: #00cd00;">'O'</span>, height=1.2, position=<span style="color: #00cd00;">'hcp'</span>)

constraint = FixAtoms(mask=[atom.symbol != <span style="color: #00cd00;">'O'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-hcp'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(4,4,1),
          encut=350,
          ibrion=2,
          nsw=25,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>



</li>
</ul>
</div>

</div>

<div id="outline-container-5-8-1-2" class="outline-5">
<h5 id="sec-5-8-1-2"><span class="section-number-5">5.8.1.2</span> Analysis of adsorption energies</h5>
<div class="outline-text-5" id="text-5-8-1-2">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_slab = atoms.get_potential_energy()
write(<span style="color: #00cd00;">'images/pt-slab.png'</span>,atoms,show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-fcc'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_slab_o_fcc = atoms.get_potential_energy()
write(<span style="color: #00cd00;">'images/pt-slab-fcc-o.png'</span>,atoms,show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-hcp'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_slab_o_hcp = atoms.get_potential_energy()
write(<span style="color: #00cd00;">'images/pt-slab-hcp-o.png'</span>,atoms,show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-bridge'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_slab_o_bridge = atoms.get_potential_energy()
write(<span style="color: #00cd00;">'images/pt-slab-bridge-o.png'</span>,atoms,show_unit_cell=2)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-350'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_O2 = atoms.get_potential_energy()

Hads_fcc = e_slab_o_fcc - e_slab - 0.5*e_O2
Hads_hcp = e_slab_o_hcp - e_slab - 0.5*e_O2
Hads_bridge = e_slab_o_bridge - e_slab - 0.5*e_O2

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Hads (fcc)    = {0} eV/O'</span>.format(Hads_fcc)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Hads (hcp)    = {0} eV/O'</span>.format(Hads_hcp)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Hads (bridge) = {0} eV/O'</span>.format(Hads_bridge)
</pre>


<pre class="example">
Hads (fcc)    = -1.0384925 eV/O
Hads (hcp)    = -0.5986145 eV/O
Hads (bridge) = -1.0384575 eV/O
</pre>


<p>
You can see the hcp site is not as energetically favorable as the fcc site. Interestingly, the bridge site seems to be as favorable as the fcc site. This is not correct, and to see why, we have to look at the final geometries of each calculation. First the fcc (Figure ref:ref:fig:fcc and hcp (Figure ref:ref:fig:hcp sites, which look like we expect.
</p>

<div class="figure">
<p><img src="./images/pt-slab-fcc-o.png"  alt="./images/pt-slab-fcc-o.png" /></p>
<p>Final geometry of the fcc site. \label{fig:fcc}</p>
</div>



<div class="figure">
<p><img src="./images/pt-slab-hcp-o.png"  alt="./images/pt-slab-hcp-o.png" /></p>
<p>Final geometry of the hcp site. \label{fig:hcp}</p>
</div>

<p>
The bridge site (Figure ref:ref:fig:bridge, however, is clearly not at a bridge site!
</p>

<div class="figure">
<p><img src="./images/pt-slab-bridge-o.png"  alt="./images/pt-slab-bridge-o.png" /></p>
<p>Final geometry of the bridge site. You can see that the oxygen atom ended up in the fcc site. \label{fig:bridge}</p>
</div>

<p>
Let us see what the original geometry and final geometry for the bridge site were. The POSCAR contains the initial geometry (as long as you haven't copied CONTCAR to POSCAR), and the CONTCAR contains the final geometry.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> read, write

atoms = read(<span style="color: #00cd00;">'surfaces/Pt-slab-O-bridge/POSCAR'</span>)
write(<span style="color: #00cd00;">'images/Pt-o-brige-ori.png'</span>, atoms, show_unit_cell=2)

atoms = read(<span style="color: #00cd00;">'surfaces/Pt-slab-O-bridge/CONTCAR'</span>)
write(<span style="color: #00cd00;">'images/Pt-o-brige-final.png'</span>, atoms, show_unit_cell=2)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/Pt-o-brige-ori.png"  alt="./images/Pt-o-brige-ori.png" /></p>
<p>Initial geometry of the bridge site. It is definitely on the bridge.</p>
</div>


<div class="figure">
<p><img src="./images/Pt-o-brige-final.png"  alt="./images/Pt-o-brige-final.png" /></p>
<p>Final geometry of the bridge site. It has fallen into the fcc site.</p>
</div>

<p>
You can see the problem. We should not call the adsorption energy from this calculation a bridge site adsorption energy because the O atom is actually in an fcc site! This kind of result can happen with relaxation, and you should always check that the result you get makes sense. Next, we consider how to get a bridge site adsorption energy by using constraints.
</p>
<p>
Some final notes:
</p><ol>
<li>We did not let the slabs relax in these examples, and allowing them to relax is likely to have a big effect on the adsorption energies. You have to decide how many layers to relax, and check for convergence with respect to the number of layers.
</li>
<li>The slabs were pretty thin. It is typical these days to see slabs that are 4-5 or more layers thick.
</li>
<li>We did not consider how well converged the calculations were with respect to <img src="ltxpng/dft_65147b429956b865ec5fa4b0bdb63e67b7cfb42b.png" alt="$k$"/>-points or <a href=http://cms.mpi.univie.ac.at/wiki/index.php/ENCUT>ENCUT</a>.
</li>
<li>We did not consider the effect of the error in O<img src="ltxpng/dft_504368ca442b9f459bbfeb22f4eec5fc81888ca9.png" alt="$_2$"/> dissociation energy on the adsorption energies.
</li>
<li>We did not consider coverage effects (see <a href="#sec-5-8-2">Coverage dependence</a>).
</li>
</ol>


</div>

</div>

<div id="outline-container-5-8-1-3" class="outline-5">
<h5 id="sec-5-8-1-3"><span class="section-number-5">5.8.1.3</span> Adsorption on bridge site with constraints</h5>
<div class="outline-text-5" id="text-5-8-1-3">

<p>To prevent the oxygen atom from sliding down into the fcc site, we have to constrain it so that it only moves in the <img src="ltxpng/dft_e9250f6ac1fdc9d8c2aa68e27459d678b8ef389b.png" alt="$z$"/>-direction. This is an artificial constraint; the bridge site is only metastable. But there are lots of reasons you might want to do this anyway. One is the bridge site is a transition state for diffusion between the fcc and hcp sites. Another is to understand the role of coordination in the adsorption energies. We use a <TT>ase.constraints.FixScaled</TT> constraint in ase to constrain the O atom so it can only move in the <img src="ltxpng/dft_e9250f6ac1fdc9d8c2aa68e27459d678b8ef389b.png" alt="$z$"/>-direction (actually so it can only move in the direction of the third unit cell vector, which only has a <img src="ltxpng/dft_e9250f6ac1fdc9d8c2aa68e27459d678b8ef389b.png" alt="$z$"/>-component).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms, FixScaled
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write

atoms = fcc111(<span style="color: #00cd00;">'Pt'</span>, size=(2,2,3), vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">note this function only works when atoms are created by the surface module.</span>
add_adsorbate(atoms, <span style="color: #00cd00;">'O'</span>, height=1.2, position=<span style="color: #00cd00;">'bridge'</span>)
constraint1 = FixAtoms(mask=[atom.symbol != <span style="color: #00cd00;">'O'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">fix in xy-direction, free in z. actually, freeze movement in surface</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">unit cell, and free along 3rd lattice vector</span>
constraint2 = FixScaled(atoms.get_cell(), 12, [<span style="color: #cd0000; font-weight: bold;">True</span>, <span style="color: #cd0000; font-weight: bold;">True</span>, <span style="color: #cd0000; font-weight: bold;">False</span>])

atoms.set_constraint([constraint1, constraint2])
write(<span style="color: #00cd00;">'images/Pt-O-bridge-constrained-initial.png'</span>, atoms, show_unit_cell=2)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Initial O position: {0}'</span>.format(atoms.positions[-1])

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-bridge-xy-constrained'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(4,4,1),
          encut=350,
          ibrion=2,
          nsw=25,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    e_bridge = atoms.get_potential_energy()

write(<span style="color: #00cd00;">'images/Pt-O-bridge-constrained-final.png'</span>, atoms, show_unit_cell=2)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Final O position  : {0}'</span>.format(atoms.positions[-1])

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now compute Hads</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_slab = atoms.get_potential_energy()


<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-350'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_O2 = atoms.get_potential_energy()

Hads_bridge = e_bridge - e_slab - 0.5*e_O2

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Hads (bridge) = {0:1.3f} eV/O'</span>.format(Hads_bridge)
</pre>


<pre class="example">
Initial O position: [  1.386   0.     15.726]
Final O position  : [  1.386   0.     15.977]
Hads (bridge) = -0.488 eV/O
</pre>


<p>
You can see that only the <img src="ltxpng/dft_dcad23ba3232e192fde1f6fd68f0493b57a0d6fb.png" alt="\(z\)"/>-position of the O atom changed. Also, the adsorption energy of O on the bridge site is <b>much</b> less favorable than on the fcc or hcp sites.
</p>

<div class="figure">
<p><img src="./images/Pt-O-bridge-constrained-initial.png"  alt="./images/Pt-O-bridge-constrained-initial.png" /></p>
<p>Initial state of the O atom on the bridge site.</p>
</div>


<div class="figure">
<p><img src="./images/Pt-O-bridge-constrained-final.png"  alt="./images/Pt-O-bridge-constrained-final.png" /></p>
<p>Final state of the constrained O atom, still on the bridge site.</p>
</div>

</div>
</div>

</div>

<div id="outline-container-5-8-2" class="outline-4">
<h4 id="sec-5-8-2"><span class="section-number-4">5.8.2</span> Coverage dependence</h4>
<div class="outline-text-4" id="text-5-8-2">

<p>The adsorbates on the surface can interact with each other which results in coverage dependent adsorption energies (<cite>PhysRevB.82.045414</cite>). Coverage dependence is not difficult to model; we simply compute adsorption energies in different size unit cells, and/or with different adsorbate configurations. Here we consider dissociative oxygen adsorption at 1ML on Pt(111) in an fcc site, which is one oxygen atom in a <img src="ltxpng/dft_37f091a68035da3f57df8732cd53880aba4163b8.png" alt="$1\times 1$"/> unit cell.
</p>
<p>
For additional reading, see these references from our work:
</p><ul>
<li>Correlations of coverage dependence of oxygen adsorption on different metals (<cite>miller:104709,Miller2009794</cite>)
</li>
<li>Coverage effects of atomic adsorbates on Pd(111) (<cite>PhysRevB.79.205412</cite>)
</li>
<li>Simple model for estimating coverage dependence (<cite>PhysRevB.82.045414</cite>)
</li>
<li>Coverage effects on alloys (<cite>PhysRevB.77.075437</cite>)
</li>
</ul>



</div>

<div id="outline-container-5-8-2-1" class="outline-5">
<h5 id="sec-5-8-2-1"><span class="section-number-5">5.8.2.1</span> clean slab calculation</h5>
<div class="outline-text-5" id="text-5-8-2-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Pt'</span>, size=(1, 1, 3), vacuum=10.0)
constraint = FixAtoms(mask=[<span style="color: #cd0000; font-weight: bold;">True</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-1x1'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(8, 8, 1),
          encut=350,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    slab_e = atoms.get_potential_energy()
</pre>



</div>

</div>

<div id="outline-container-5-8-2-2" class="outline-5">
<h5 id="sec-5-8-2-2"><span class="section-number-5">5.8.2.2</span> fcc site at 1 ML coverage</h5>
<div class="outline-text-5" id="text-5-8-2-2">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Pt'</span>, size=(1, 1, 3), vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">note this function only works when atoms are created by the surface module.</span>
add_adsorbate(atoms, <span style="color: #00cd00;">'O'</span>, height=1.2, position=<span style="color: #00cd00;">'fcc'</span>)

constraint = FixAtoms(mask=[atom.symbol != <span style="color: #00cd00;">'O'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(constraint)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-1x1-O-fcc'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          kpts=(8, 8, 1),
          encut=350,
          ibrion=2,
          nsw=25,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()
</pre>



</div>

</div>

<div id="outline-container-5-8-2-3" class="outline-5">
<h5 id="sec-5-8-2-3"><span class="section-number-5">5.8.2.3</span> Adsorption energy at 1ML</h5>
<div class="outline-text-5" id="text-5-8-2-3">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-1x1-O-fcc'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_slab_o = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">clean slab</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-1x1'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_slab = atoms.get_potential_energy()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-350'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    e_O2 = atoms.get_potential_energy()

hads = e_slab_o - e_slab - 0.5*e_O2
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Hads (1ML) = {0:1.3f} eV'</span>.format(hads)
</pre>


<pre class="example">
Hads (1ML) = -0.099 eV
</pre>


<p>
The adsorption energy is <b>much</b> less favorable at 1ML coverage than at 0.25 ML coverage! We will return what this means in <a href="#sec-6-2">Atomistic thermodynamics effect on adsorption</a>.
</p></div>
</div>

</div>

<div id="outline-container-5-8-3" class="outline-4">
<h4 id="sec-5-8-3"><span class="section-number-4">5.8.3</span> Effect of adsorption on the surface energy</h4>
<div class="outline-text-4" id="text-5-8-3">

<p>There is a small point to make here about what adsorption does to surface energies. Let us define a general surface formation energy scheme like this:
</p>

<div class="figure">
<p><img src="./images/adsorbate-surface-energy.png"  alt="./images/adsorbate-surface-energy.png" /></p>
<p>Schematic of forming a surface with adsorbates. First we form two clean surfaces by cleaving the bulk, then allow adsorption to occur on the surfaces.</p>
</div>

<p>
Let us presume the surfaces are symmetric, and that each surface contributes half of the energy change. The overall change in energy:
</p>
<p>
<img src="ltxpng/dft_ebef3dfbad5e46b6478a14f7604f1cfdb04155af.png" alt="$\Delta E = E_{slab,ads} - E_{ads} - E_{bulk}$"/>
</p>
<p>
where the the energies are appropriately normalized for the stoichiometry. Let us rearrange the terms, and add and subtract a constant term <img src="ltxpng/dft_59f2ab2bb3384821c52527057365e115b236b6a9.png" alt="$E_{slab}$"/>.
</p>
<p>
<img src="ltxpng/dft_d3494a5d070a2a95b46a8d282fb0d04c751415ed.png" alt="$\Delta E = E_{slab,ads} - E_{slab} - E_{ads} - E_{bulk} + E_{slab}$"/>
</p>
<p>
We defined <img src="ltxpng/dft_57d12a0d1c4cfaa010163f9e1e714a8e7296b1d7.png" alt="$\gamma_{clean} = \frac{1}{2A}(E_{slab} - E_{bulk})$"/>, and we defined <img src="ltxpng/dft_c67d6f3ff10d703f25814658994bcf2cc044b734.png" alt="$H_{ads} = E_{slab,ads} - E_{slab} - E_{ads}$"/> for adsorption on a single side of a slab. In this case, there are adsorbates on both sides of the slab, so <img src="ltxpng/dft_52162880c510f7ec8b52416591f2486a75fb2ab3.png" alt="$E_{slab,ads} - E_{slab} - E_{ads} = 2 \Delta H_{ads}$"/>. If we normalize by <img src="ltxpng/dft_fd12f7bb2763afd5c3710833e37ce2eafa5c61e5.png" alt="$2A$"/>, the area for both sides of the slab, we get
</p>
<p>
<img src="ltxpng/dft_8c82beae67affeeedb8c79f4fa0e08acad27c0ac.png" alt="$\frac{\Delta E}{2A} = \gamma = \gamma_{clean} + \frac{H_{ads}}{A}$"/>
</p>
<p>
You can see here that the adsorption energy serves to stabilize, or reduce the surface energy, provided that the adsorption energy is negative.
</p>
<p>
Some final notes about the equations above:
</p>
<ul>
<li>We were not careful about stoichiometry. As written, it is assumed there are the same number of atoms (not including the adsorbates) in the slabs and bulk, and the same number of adsorbate atoms in the slab and <img src="ltxpng/dft_f45f14f36411d5e91cd808da7af38a8dec55fdf8.png" alt="$E_{ads}$"/>. Appropriate normalization factors must be included if that is not true.

</li>
<li>It is not necessary to perform a symmetric slab calculation to determine the effect of adsorption on the surface energy! You can examine <img src="ltxpng/dft_64caa5533f7089b6c5b7c651e6e38fca085d918b.png" alt="$\gamma - \gamma_{clean}$"/> with knowledge of only the adsorption energies!
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-5-9" class="outline-3">
<h3 id="sec-5-9"><span class="section-number-3">5.9</span> Adsorbate vibrations</h3>
<div class="outline-text-3" id="text-5-9">


<p>
Adsorbates also have vibrational modes. Unlike a free molecule, the translational and rotational modes of an adsorbate may actually have real frequencies. Sometimes they are called frustrated translations or rotations. For metal surfaces with adsorbates, it is common to only compute vibrational modes of the adsorbate on a frozen metal slab. The rationale is that the metal atoms are so much heavier than the adsorbate that there will be little coupling between the surface and adsorbates. You can limit the number of modes calculated with constraints (<TT>ase.constraints.FixAtoms</TT> or <TT>ase.constraints.FixScaled</TT>) if you use <a href=http://cms.mpi.univie.ac.at/wiki/index.php/IBRION>IBRION</a>=5. The other IBRION settings (6, 7, 8) do not respect the selective dynamics constraints. Below we consider the vibrational modes of an oxygen atom in an fcc site on Pt(111).
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-fcc'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'surfaces/Pt-slab-O-fcc-vib'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-fcc-vib'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set(ibrion=5,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">finite differences with selective dynamics</span>
             nfree=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">central differences (default)</span>
             potim=0.015,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">default as well</span>
             ediff=1e-8,
             nsw=1)
    atoms = calc.get_atoms()
    f,v = calc.get_vibrational_modes(0)
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Elapsed time = {0} seconds'</span>.format(calc.get_elapsed_time())
    allfreq = calc.get_vibrational_modes()[0]
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> meV
c = 3e10 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">cm/s</span>
h = 4.135667516e-15 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">eV*s</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational energy = {0} eV'</span>.format(f)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational energy = {0} meV'</span>.format(f/meV)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational freq   = {0} 1/s'</span>.format(f/h)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational freq   = {0} cm^{{-1}}'</span>.format(f/(h*c))
<span style="color: #cd0000; font-weight: bold;">print</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'All energies = '</span>,allfreq
</pre>


<p>
=Elapsed time = 14269.345 seconds
vibrational energy = 0.061606647 eV
vibrational energy = 61.606647 meV
vibrational freq   = 1.48964216204e+13 1/s
vibrational freq   = 496.547387346 cm<sup>-1</sup>
</p>
<p>
All energies =  [0.061606647, 0.044346362, 0.044344470000000004]
=:
</p><pre class="example">
All energies =  [0.061606647, 0.044346362, 0.044344470000000004]
</pre>


<p>
There are three modes for the free oxygen atom. One of them is a mode normal to the surface (the one with highest frequency. The other two are called frustrated translations. Note that we did not include the surface Pt atoms in the calculation, and this will have an effect on the result because the O atom could be coupled to the surface modes. It is typical to neglect this coupling because of the large difference in mass between O and Pt.  Next we look at the difference in results when we calculate all the modes.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-fcc'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'Pt-slab-O-fcc-vib-ibrion=6'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-fcc-vib-ibrion=6'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set(ibrion=6,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">finite differences with symmetry</span>
             nfree=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">central differences (default)</span>
             potim=0.015,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">default as well</span>
             ediff=1e-8,
             nsw=1)
    atoms = calc.get_atoms()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Elapsed time = {0} seconds'</span>.format(calc.get_elapsed_time())

    f,m = calc.get_vibrational_modes(0)
    allfreq = calc.get_vibrational_modes()[0]

<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> meV
c = 3e10 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">cm/s</span>
h = 4.135667516e-15 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">eV*s</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'For mode 0:'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational energy = {0} eV'</span>.format(f)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational energy = {0} meV'</span>.format(f/meV)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational freq   = {0} 1/s'</span>.format(f/h)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational freq   = {0} cm^{{-1}}'</span>.format(f/(h*c))
<span style="color: #cd0000; font-weight: bold;">print</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'All energies = '</span>,allfreq
</pre>


<p>
=Elapsed time = 77121.015 seconds
For mode 0:
vibrational energy = 0.063537929 eV
vibrational energy = 63.537929 meV
vibrational freq   = 1.53634035507e+13 1/s
vibrational freq   = 512.113451691 cm<sup>-1</sup>
</p>
<p>
All energies =  [0.06353792899999999, 0.045628623, 0.045628623, 0.023701702, 0.023701702, 0.023223747, 0.022978233, 0.022978233, 0.022190167, 0.021807461, 0.02040119, 0.02040119, 0.019677135000000002, 0.015452848, 0.015302098000000002, 0.015302098000000002, 0.0148412, 0.0148412, 0.014071851000000002, 0.012602063, 0.012602063, 0.012409611999999999, 0.012300973000000002, 0.011735683, 0.011735683, 0.011714521, 0.011482183, 0.011482183, 0.010824891, 0.010414177, 0.010414177, 0.009799697, 0.00932905, 0.00932905, 0.003859079, 0.003859079, (2.9894000000000002e-05+0j), (2.9894000000000002e-05+0j), (0.00012182999999999999+0j)]
=:
</p><pre class="example">
All energies =  [0.06353792899999999, 0.045628623, 0.045628623, 0.023701702, 0.023701702, 0.023223747, 0.022978233, 0.022978233, 0.022190167, 0.021807461, 0.02040119, 0.02040119, 0.019677135000000002, 0.015452848, 0.015302098000000002, 0.015302098000000002, 0.0148412, 0.0148412, 0.014071851000000002, 0.012602063, 0.012602063, 0.012409611999999999, 0.012300973000000002, 0.011735683, 0.011735683, 0.011714521, 0.011482183, 0.011482183, 0.010824891, 0.010414177, 0.010414177, 0.009799697, 0.00932905, 0.00932905, 0.003859079, 0.003859079, (2.9894000000000002e-05+0j), (2.9894000000000002e-05+0j), (0.00012182999999999999+0j)]
</pre>


<p>
Note that now there are 39 modes, which is 3*N where N=13 atoms in the unit cell. Many of the modes are low in frequency, which correspond to slab modes that are essentially phonons. The O frequencies are not that different from the previous calculation (497 vs 512 cm<img src="ltxpng/dft_11271b674b4cad9ea28701e09acf9e8c4b63d32d.png" alt="$^{-1}$"/>. This is why it is common to keep the slab atoms frozen.
</p>
<p>
Calculating these results took 39*2 finite differences. It took about a day to get these results on a single CPU. It pays to use constraints to minimize the number of these calculations.
</p>

</div>

<div id="outline-container-5-9-1" class="outline-4">
<h4 id="sec-5-9-1"><span class="section-number-4">5.9.1</span> Vibrations of the bridge site</h4>
<div class="outline-text-4" id="text-5-9-1">

<p>Here we consider the vibrations of an O atom in a bridge site, which we saw earlier is a metastable saddle point.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">clone calculation so we do not overwrite previous results</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-bridge-xy-constrained'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'surfaces/Pt-slab-O-bridge-vib'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-bridge-vib'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set(ibrion=5,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">finite differences with selective dynamics</span>
             nfree=2, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">central differences (default)</span>
             potim=0.015,<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">default as well</span>
             ediff=1e-8,
             nsw=1)
    atoms = calc.get_atoms()
    <span style="color: #cd0000; font-weight: bold;">del</span> atoms.constraints
    constraint = FixAtoms(mask=[atom.symbol != <span style="color: #00cd00;">'O'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
    atoms.set_constraint([constraint])

    f,v = calc.get_vibrational_modes(2)
    <span style="color: #cd0000; font-weight: bold;">print</span> calc.get_vibrational_modes()[0]

<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> meV
c = 3e10 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">cm/s</span>
h = 4.135667516e-15 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">eV*s</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational energy = {0} eV'</span>.format(f)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational energy = {0} meV'</span>.format(f/meV)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational freq   = {0} 1/s'</span>.format(f/h)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'vibrational freq   = {0} cm^(-1)'</span>.format(f/(h*c))
</pre>


<pre class="example">
[0.06691932, 0.047345270999999994, (0.020649715000000003+0j)]
vibrational energy = (0.020649715+0j) eV
vibrational energy = (20.649715+0j) meV
vibrational freq   = (4.99307909065e+12+0j) 1/s
vibrational freq   = (166.435969688+0j) cm^(-1)
</pre>


<p>
Note that we have one imaginary mode. This corresponds to the motion of the O atom falling into one of the neighboring 3-fold sites. It also indicates this position is not a stable minimum, but rather a saddle point. This position is a transition state for hopping between the fcc and hcp sites.
</p>
</div>
</div>

</div>

<div id="outline-container-5-10" class="outline-3">
<h3 id="sec-5-10"><span class="section-number-3">5.10</span> Surface Diffusion barrier</h3>
<div class="outline-text-3" id="text-5-10">


<p>
See this review (<cite>ANIE.ANIE200602223</cite>) of diffusion on transition metal surfaces.
</p>

</div>

<div id="outline-container-5-10-1" class="outline-4">
<h4 id="sec-5-10-1"><span class="section-number-4">5.10.1</span> Standard nudged elastic band method</h4>
<div class="outline-text-4" id="text-5-10-1">

<p>Here we illustrate a standard NEB method. You need an initial and final state to start with. We will use the results from previous calculations of oxygen atoms in an fcc and hcp site. then we will construct a band of images connecting these two sites. Finally, we let VASP optimize the band and analyze the results to get the barrier.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.neb <span style="color: #cd0000; font-weight: bold;">import</span> NEB
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">from</span> scipy <span style="color: #cd0000; font-weight: bold;">import</span> interpolate
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-fcc'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    initial_atoms = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-slab-O-hcp'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    final_atoms = calc.get_atoms()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">here is our estimated transition state. we use vector geometry to</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">define the bridge position, and add 1.451 Ang to z based on our</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">previous bridge calculation. The bridge position is half way between</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">atoms 9 and 10.</span>
ts = initial_atoms.copy()
ts.positions[-1] = 0.5*(ts.positions[9] + ts.positions[10]) + [0,0,1.451]

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">construct the band</span>
images = [initial_atoms]
images += [initial_atoms.copy()]
images += [ts.copy()]  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this is the TS</span>

neb = NEB(images)
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Interpolate linearly the positions of these images:</span>
neb.interpolate()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now add the second half</span>
images2 = [ts.copy()]
images2 += [ts.copy()]
images2 += [final_atoms]

neb2 = NEB(images2)
neb2.interpolate()

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">collect final band. Note we do not repeat the TS in the second half</span>
final_images = images + images2[1:]

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-O-fcc-hcp-neb'</span>,
          ibrion=1,
          nsw=90,
          spring=-5,
          atoms=final_images) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    <span style="color: #cd0000; font-weight: bold;">try:</span>
        images, energies = calc.get_neb()
        p = calc.plot_neb(show=<span style="color: #cd0000; font-weight: bold;">False</span>)

        <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">remember you are in surfaces/Pt-O-fcc-hcp-neb, so to save in</span>
        <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">the images directory you need ../../ in the path to get you</span>
        <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">back up.</span>
        plt.savefig(<span style="color: #00cd00;">'../../images/pt-o-fcc-hcp-neb.png'</span>)
    <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
        <span style="color: #cd0000; font-weight: bold;">pass</span>
</pre>


<pre class="example">
Optimization terminated successfully.
         Current function value: -0.575224
         Iterations: 12
         Function evaluations: 24
</pre>



<div class="figure">
<p><img src="./images/pt-o-fcc-hcp-neb.png"  alt="./images/pt-o-fcc-hcp-neb.png" /></p>
<p>Energy pathway for O diffusion from an fcc to hcp site with a spline fit to determine the barrier.</p>
</div>

<p>
We should compare this barrier to what we could estimate from the simple adsorption energies in the fcc and bridge sites. The adsorption energy in the fcc site was -1.04 eV, and in the bridge site was -0.49 eV. The difference between these two is 0.55 eV, which is very close to the calculated barrier from the NEB calculation. In cases where you can determine what the transition state is, e.g. by symmetry, or other means, it is much faster to directly compute the energy of the initial and transition states for barrier determinations. This is not usually possible though.
</p>
</div>

</div>

<div id="outline-container-5-10-2" class="outline-4">
<h4 id="sec-5-10-2"><span class="section-number-4">5.10.2</span> Climbing image NEB</h4>
<div class="outline-text-4" id="text-5-10-2">

<p>One issue with the standard NEB method is there is no image that is exactly at the transition state. That means there is some uncertainty of the true energy of the transition state, and there is no way to verify the transition state by vibrational analysis. The climbing image NEB method (<cite>henkelman:9901</cite>) solves that problem by making one image climb to the top. You set <a href=http://cms.mpi.univie.ac.at/wiki/index.php/LCLIMB>LCLIMB</a>==True= in <code>jasp</code> to turn on the climbing image method. Here we use the previous calculation as a starting point and turn on the climbing image method.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">perform a climbing image NEB calculation</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-O-fcc-hcp-neb'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'surfaces/Pt-O-fcc-hcp-cineb'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-O-fcc-hcp-cineb'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set(ichain=0, lclimb=<span style="color: #cd0000; font-weight: bold;">True</span>)

    images, energies = calc.get_neb(npi=4)
    calc.plot_neb(show=<span style="color: #cd0000; font-weight: bold;">False</span>)
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.savefig(<span style="color: #00cd00;">'images/pt-o-cineb.svg'</span>)
plt.show()
</pre>


<pre class="example">
Optimization terminated successfully.
         Current function value: -0.575288
         Iterations: 12
         Function evaluations: 24
</pre>


<p>
<a href="#figure-.-images-pt-o-cineb.svg">Climbing image NEB.</a>
</p>
<p>
This did not do exactly what I expected. I thought there would be an image that had climbed to the top. Maybe this is an artifact of the spline fitting, or the top is within the tolerance of the top two points. More band points would probably clarify that.
</p>
</div>

</div>

<div id="outline-container-5-10-3" class="outline-4">
<h4 id="sec-5-10-3"><span class="section-number-4">5.10.3</span> Using vibrations to confirm a transition state</h4>
<div class="outline-text-4" id="text-5-10-3">

<p>A transition state should have exactly one imaginary degree of freedom which corresponds to the mode that takes reactants to products. See <a href="#sec-5-9-1">Vibrations of the bridge site</a> for an example.
</p>
</div>
</div>

</div>

<div id="outline-container-5-11" class="outline-3">
<h3 id="sec-5-11"><span class="section-number-3">5.11</span> <span class="todo TODO">TODO</span> Diffusion rates with transition state theory</h3>
<div class="outline-text-3" id="text-5-11">


</div>

</div>

<div id="outline-container-5-12" class="outline-3">
<h3 id="sec-5-12"><span class="section-number-3">5.12</span> <span class="todo TODO">TODO</span> Effects of electric fields on adsorbates</h3>
<div class="outline-text-3" id="text-5-12">

<p>Electric fields can polarize adsorbates, i.e. shift their electron density around, which changes their stability . We can model this to some extent in VASP. We have to set the <a href=http://cms.mpi.univie.ac.at/wiki/index.php/EFIELD>EFIELD</a> parameter to specify the field strength (in V/&Aring;), and <a href=http://cms.mpi.univie.ac.at/wiki/index.php/LDIPOL>LDIPOL</a> to <code>True</code>, and finally specify which lattice vector the field should be applied to with <a href=http://cms.mpi.univie.ac.at/wiki/index.php/IDIPOL>IDIPOL</a>. Usually, <a href=http://cms.mpi.univie.ac.at/wiki/index.php/IDIPOL>IDIPOL</a> will be set to 3 for surfaces so it points in the direction of the third lattice vector, which is conventionally in the z-direction and normal to the surface.
</p>
<p>
We will illustrate the effect using an example from (<cite>doi-10.1021/jp810518x</cite>) for the effect of electric field on the adsorption energy of a CO molecule on Pt(111) at 0.25 ML. For simplicity, we will use a frozen slab, with the CO molecule in the geometry reported in that reference.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111

atoms = fcc111(<span style="color: #00cd00;">'Pt'</span>, size=(2, 2, 4), vacuum=10.0, a=3.986)
atoms.append(Atom(<span style="color: #00cd00;">'C'</span>, [atoms[12].x, atoms[12].y, atoms[12].z + 1.851]))
atoms.append(Atom(<span style="color: #00cd00;">'O'</span>, [atoms[-1].x, atoms[-1].y, atoms[-1].z + 1.157]))

<span style="color: #cd0000; font-weight: bold;">for</span> field <span style="color: #cd0000; font-weight: bold;">in</span> [-0.5, 0.0, 0.5]:
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Pt-co-field-{0}'</span>.format(field),
              xc=<span style="color: #00cd00;">'PBE'</span>,
              encut=350,
              kpts=(6,6,1),
              efield=field,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">set the field</span>
              ldipol=<span style="color: #cd0000; font-weight: bold;">True</span>,   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn dipole correction on</span>
              idipol=3,      <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">set field in z-direction</span>
              atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        <span style="color: #cd0000; font-weight: bold;">try:</span>
            <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0}: {1:1.3f}'</span>.format(field, atoms.get_potential_energy())
        <span style="color: #cd0000; font-weight: bold;">except</span> (VaspSubmitted, VaspQueued):
            <span style="color: #cd0000; font-weight: bold;">pass</span>
</pre>


<pre class="example">
-0.5: -4361.271
0.0: -108.077
0.5: -1612.879
</pre>


<p>
These energies are crazy different, and the forces on the atoms with the field on are insanely high. This section is on hold until I figure that out.
</p>
</div>

</div>

<div id="outline-container-5-13" class="outline-3">
<h3 id="sec-5-13"><span class="section-number-3">5.13</span> <span class="todo TODO">TODO</span> Simulating STM images</h3>
<div class="outline-text-3" id="text-5-13">

<p><a href="http://cst-www.nrl.navy.mil/users/sullivan/stm_backup/stm2.html">http://cst-www.nrl.navy.mil/users/sullivan/stm_backup/stm2.html</a>
</p></div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Atomistic thermodynamics</h2>
<div class="outline-text-2" id="text-6">


<p>
Let us consider how much the Gibbs free energy of an O<sub>2</sub> molecule changes as a function of temperature, at 1 atm. We use the Shomate polynomials to approximate the temperature dependent entropy and enthalpy, and use the parameters from the <a href="http://webbook.nist.gov/cgi/cbook.cgi?ID=C7782447&amp;Units=SI&amp;Mask=1#Thermo-Gas">NIST Webbook</a> for O<sub>2</sub>.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> *
K = 1. <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">not defined in ase.units!</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Shomate parameters</span>
A = 31.32234; B = -20.23531; C = 57.86644
D = -36.50624; E = -0.007374; F = -8.903471
G = 246.7945; H = 0.0

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">entropy</span>(T):
    <span style="color: #00cd00;">'''entropy returned as eV/K</span>
<span style="color: #00cd00;">    T in K</span>
<span style="color: #00cd00;">    '''</span>
    t = T/1000.
    s = A*np.log(t) + B*t + C*(t**2)/2. + D*(t**3)/3. - E/(2.*t**2) + G
    <span style="color: #cd0000; font-weight: bold;">return</span> s*J/mol/K

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">enthalpy</span>(T):
    <span style="color: #00cd00;">''' H - H(298.15) returned as eV/molecule'''</span>
    t = T/1000.
    h = A*t + B*(t**2)/2. + C*(t**3)/3. + D*(t**4)/4. - E/t + F - H
    <span style="color: #cd0000; font-weight: bold;">return</span> h*kJ/mol

T = np.linspace(100,700)

G = enthalpy(T) - T*entropy(T)

plt.plot(T,G)
plt.xlabel(<span style="color: #00cd00;">'Temperature (K)'</span>)
plt.ylabel(<span style="color: #00cd00;">'$\Delta G^\circ$ (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/O2-mu.png'</span>)
</pre>




<div class="figure">
<p><img src="./images/O2-mu.png"  alt="./images/O2-mu.png" /></p>
<p>Effect of temperature on the Gibbs free energy of an O$_2$ molecule at 1 atm.</p>
</div>

<p>
This is clearly a big effect! Between 500-600K, the energy has dropped by nearly 1 eV.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> *

atm = 101325*Pascal <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">atm is not defined in units</span>
K = 1

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">examine range over 10^-10 to 10^10 atm</span>
P = np.logspace(-10,10)*atm

plt.semilogx(P/atm, kB*(300*K)*np.log(P/(1*atm)),label=<span style="color: #00cd00;">'300K'</span>)
plt.semilogx(P/atm, kB*(600*K)*np.log(P/(1*atm)),label=<span style="color: #00cd00;">'600K'</span>)
plt.xlabel(<span style="color: #00cd00;">'Pressure (atm)'</span>)
plt.ylabel(<span style="color: #00cd00;">'$\Delta G$ (eV)'</span>)
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/O2-g-p.png'</span>)

</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/O2-g-p.png"  alt="./images/O2-g-p.png" /></p>
<p>Effects of pressure on the ideal gas Gibbs free energy of O$_2$.</p>
</div>

<p>
Similarly, you can see that simply changing the pressure has a large effect on the Gibbs free energy of an ideal gas through the term: <img src="ltxpng/dft_ce2be8140e066451c53352782bf5c6a48b371e48.png" alt="$kT\ln(P/P_0)$"/>, and that this effect is also temperature dependent. This leads us to the final formula we will use for the chemical potential of oxgyen:
</p>
<p>
<img src="ltxpng/dft_dcfb57354008e4518e69dd0ba1d0dc3e328c180f.png" alt="$\mu_{O_2} = E_{O_2}^{DFT} + E_{O_2}^{ZPE} + \Delta \mu (T) + kT \ln(P/P_0)$"/>
</p>

</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Bulk phase stability of oxides</h3>
<div class="outline-text-3" id="text-6-1">

<p>We will  consider the effects of oxygen pressure and temperature on the formation energy of Ag<sub>2</sub>O and Cu<sub>2</sub>O.
</p>
<p>
<img src="ltxpng/dft_d2f791e9fcbd65aca1778ec900daafeb65c0faf6.png" alt="$2Cu + 1/2 O_2 \rightarrow Cu_2O$"/>
</p>
<p>
In atomistic thermodynamics, we define the free energy of formation as:
</p>
<p>
<img src="ltxpng/dft_03c8d8c47d2435f80b07389f2a84220e13e9cbf5.png" alt="$G_f = G_{Cu_2O} -2G_{Cu} - 0.5 G_{O_2}$"/>
</p>
<p>
We will at this point assume that the solids are incompressible so that <img src="ltxpng/dft_b12eef6aa839578816a7498ba64dba6c6dd03280.png" alt="$p\Delta V \approx 0$"/>, and that <img src="ltxpng/dft_a97ed11233749422010335f2c9d7a784464de1d4.png" alt="$S_{Cu_2O} -2S_{Cu} \approx 0$"/>, which leads to <img src="ltxpng/dft_f54d9f9cd33b8d9c096a160eb84ddf8880aba65a.png" alt="$G_{Cu_2O} -2G_{Cu} \approx E_{Cu_2O} -2E_{Cu}$"/>, which we directly compute from DFT. We express <img src="ltxpng/dft_608f894d111adeaa81727df3ff582ac828b8acb1.png" alt="$G_{O_2} = \mu_{O_2} = E_{O_2}^{DFT} + E_{O_2}^{ZPE} + \Delta \mu (T) + kT \ln(P/P_0)$"/>. In this example we neglect the zero-point energy of the oxygen molecule, and finally arrive at:
</p>
<p>
<img src="ltxpng/dft_1a01fc12392fa905fcc34cf688af5a3ee6fb2eec.png" alt="$G_f \approx E_{Cu_2O} -2E_{Cu} - 0.5 (E_{O_2}^{DFT} + \delta \mu (T) + kT \ln(P/P_0))$"/>
</p>
<p>
Which, after grouping terms is:
</p>
<p>
<img src="ltxpng/dft_c57faf8a099105f764e28d39c7412fc97b0bb687.png" alt="$G_f \approx E_{Cu_2O} -2E_{Cu} - 0.5 (E_{O_2}^{DFT}) - 0.5*\Delta \mu_{O_2}(P,T)$"/>
</p>
<p>
with <img src="ltxpng/dft_59f4c57e4a03a606d542b2cba3a8e4046ebd934b.png" alt="$\Delta \mu_{O_2}(P,T) = \delta \mu (T) + kT \ln(P/P_0)$"/>. We get <img src="ltxpng/dft_60b7174a4c5fe120277f18e19492bedf03ac592e.png" alt="$\delta \mu (T)$"/> from the Janaf Tables, or the NIST Webbook.
</p>
<p>
You will recognize in this equation the standard formation energy we calculated in <a href="#sec-4-8-2">Metal oxide oxidation energies </a>plus a correction for the non standard state pressure and temperature (<img src="ltxpng/dft_962e55f40bcbc62bb273d7211e11b2943fe3d9d4.png" alt="$\Delta \mu_{O_2}(P,T) = 0$"/> at standard state).
</p>

<p>
<img src="ltxpng/dft_2c4cb195b70af9e4889c34922e87938e2d17f4be.png" alt="$G_f \approx H_f - 0.5*\Delta \mu_{O_2}(P,T)$"/>
</p>

<p>
The <a href="http://materialsproject.org/materials/361/">formation energy</a> of Cu<sub>2</sub>O is -1.9521 eV/formula unit. The <a href="http://materialsproject.org/materials/353/">formation energy</a> for Ag<sub>2</sub>O is -0.99 eV/formula unit. Let us consider what temperature the oxides decompose at a fixed oxygen pressure of 1<img src="ltxpng/dft_48c2be38e7e2852dc148e8e0673e1f218e154436.png" alt="$\times 10^{-10}$"/> atm. We need to find the temperature where:
</p>
<p>
<img src="ltxpng/dft_e9fd591560b789459098dd63d1b50bbdbefd1d08.png" alt="$H_f = 0.5*\Delta \mu_{O_2}(P,T)$"/>
</p>
<p>
which will make the formation energy be 0.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> scipy.optimize <span style="color: #cd0000; font-weight: bold;">import</span> fsolve

K = 1. <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">not defined in ase.units!</span>
atm = 101325*Pascal

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Shomate parameters valid from 100-700K</span>
A = 31.32234; B = -20.23531; C = 57.86644
D = -36.50624; E = -0.007374; F = -8.903471
G = 246.7945; H = 0.0

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">entropy</span>(T):
    <span style="color: #00cd00;">'''entropy returned as eV/K</span>
<span style="color: #00cd00;">    T in K</span>
<span style="color: #00cd00;">    '''</span>
    t = T/1000.
    s = A*np.log(t) + B*t + C*(t**2)/2. + D*(t**3)/3. - E/(2.*t**2) + G
    <span style="color: #cd0000; font-weight: bold;">return</span> s*J/mol/K

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">enthalpy</span>(T):
    <span style="color: #00cd00;">''' H - H(298.15) returned as eV/molecule'''</span>
    t = T/1000.
    h = A*t + B*(t**2)/2. + C*(t**3)/3. + D*(t**4)/4. - E/t + F - H
    <span style="color: #cd0000; font-weight: bold;">return</span> h*kJ/mol

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">DeltaMu</span>(T,P):
    <span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">    T in K</span>
<span style="color: #00cd00;">    P in atm</span>
<span style="color: #00cd00;">    '''</span>
    <span style="color: #cd0000; font-weight: bold;">return</span> enthalpy(T) - T*entropy(T) + kB*T*np.log(P/atm)

T = np.linspace(100,1000)
P = 1e-10*atm

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">func</span>(T):
    <span style="color: #00cd00;">'Cu2O'</span>
    <span style="color: #cd0000; font-weight: bold;">return</span> -1.95 - 0.5*DeltaMu(T,P)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Cu2O decomposition temperature is {0:1.0f} K'</span>.format(fsolve(func, 900)[0])

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">func</span>(T):
    <span style="color: #00cd00;">'Ag2O'</span>
    <span style="color: #cd0000; font-weight: bold;">return</span> -0.99 - 0.5*DeltaMu(T,P)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Ag2O decomposition temperature is {0:1.0f} K'</span>.format(fsolve(func, 470)[0])

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">you have use \\times to escape the first \ in pyplot</span>
plt.plot(T, DeltaMu(T,1e10*atm),label=<span style="color: #00cd00;">'1$\\times 10^{10}$ atm'</span>)
plt.plot(T, DeltaMu(T,1e5*atm),label=<span style="color: #00cd00;">'1$\\times 10^5$ atm'</span>)
plt.plot(T, DeltaMu(T,1*atm),label=<span style="color: #00cd00;">'1 atm'</span>)
plt.plot(T, DeltaMu(T,1e-5*atm),label=<span style="color: #00cd00;">'1$\\times 10^{-5}$ atm'</span>)
plt.plot(T, DeltaMu(T,1e-10*atm),label=<span style="color: #00cd00;">'1$\\times 10^{-10}$ atm'</span>)

plt.xlabel(<span style="color: #00cd00;">'Temperature (K)'</span>)
plt.ylabel(<span style="color: #00cd00;">'$\Delta \mu_{O_2}(T,p)$ (eV)'</span>)
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/O2-mu.png'</span>)
</pre>


<pre class="example">
Cu2O decomposition temperature is 917 K
Ag2O decomposition temperature is 478 K
</pre>



<div class="figure">
<p><img src="./images/O2-mu.png"  alt="./images/O2-mu.png" /></p>
<p>&Delta; \(&mu;<sub>O_2</sub>\)(T,p) at different pressures and temperatures. \label{fig:mu-o2}</p>
</div>




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> scipy.optimize <span style="color: #cd0000; font-weight: bold;">import</span> fsolve

K = 1. <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">not defined in ase.units!</span>
atm = 101325*Pascal

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Shomate parameters valid from 100-700K</span>
A = 31.32234; B = -20.23531; C = 57.86644
D = -36.50624; E = -0.007374; F = -8.903471
G = 246.7945; H = 0.0

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">entropy</span>(T):
    <span style="color: #00cd00;">'''entropy returned as eV/K</span>
<span style="color: #00cd00;">    T in K</span>
<span style="color: #00cd00;">    '''</span>
    t = T/1000.
    s = A*np.log(t) + B*t + C*(t**2)/2. + D*(t**3)/3. - E/(2.*t**2) + G
    <span style="color: #cd0000; font-weight: bold;">return</span> s*J/mol/K

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">enthalpy</span>(T):
    <span style="color: #00cd00;">''' H - H(298.15) returned as eV/molecule'''</span>
    t = T/1000.
    h = A*t + B*(t**2)/2. + C*(t**3)/3. + D*(t**4)/4. - E/t + F - H
    <span style="color: #cd0000; font-weight: bold;">return</span> h*kJ/mol

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">DeltaMu</span>(T,P):
    <span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">    T in K</span>
<span style="color: #00cd00;">    P in atm</span>
<span style="color: #00cd00;">    '''</span>
    <span style="color: #cd0000; font-weight: bold;">return</span> enthalpy(T) - T*entropy(T) + kB*T*np.log(P/atm)

P = np.logspace(-11,1,10)*atm
T = []
<span style="color: #cd0000; font-weight: bold;">for</span> p <span style="color: #cd0000; font-weight: bold;">in</span> P:

    <span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">func</span>(T):
        <span style="color: #cd0000; font-weight: bold;">return</span> -0.99 - 0.5*DeltaMu(T,p)
    T.append(fsolve(func, 450)[0])

plt.semilogy(T,P/atm)
plt.xlabel(<span style="color: #00cd00;">'Temperature (K)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Pressure (atm)'</span>)
plt.text(800,1e-7,<span style="color: #00cd00;">'Ag'</span>)
plt.text(600,1e-3,<span style="color: #00cd00;">'Ag$_2$O'</span>)
plt.savefig(<span style="color: #00cd00;">'images/Ag2O-decomposition.png'</span>)
</pre>




<div class="figure">
<p><img src="./images/Ag2O-decomposition.png"  alt="./images/Ag2O-decomposition.png" /></p>
<p>Temperature dependent decomposition pressure for Ag<sub>2</sub>O.</p>
</div>

<p>
This shows that at high temperature and low p<sub>O<sub>2</sub></sub> metallic silver is stable, but if the p<sub>O<sub>2</sub></sub> gets high enough, the oxide becomes thermodynamically favorable. Here is another way to look at it.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> *

K = 1. <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">not defined in ase.units!</span>
atm = 101325*Pascal
Hf = -0.99

P = 1*atm

Dmu = np.linspace(-4,0)

Hf = -0.99 - 0.5*Dmu

plt.plot(Dmu, Hf, label=<span style="color: #00cd00;">'Ag$_2$O'</span>)
plt.plot(Dmu, np.zeros(Hf.shape), label=<span style="color: #00cd00;">'Ag'</span>)
plt.xlabel(<span style="color: #00cd00;">'$\Delta \mu_{O_2}$ (eV)'</span>)
plt.ylabel(<span style="color: #00cd00;">'$H_f$ (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/atomistic-thermo-hf-mu.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/atomistic-thermo-hf-mu.png"  alt="./images/atomistic-thermo-hf-mu.png" /></p>
<p>Dependence of the formation energy on the oxygen chemical potential.</p>
</div>

<p>
This graph shows graphically the <img src="ltxpng/dft_a8a7b0972d653056578916e2b555b881eafc07b2.png" alt="$\Delta \mu_{O_2}$"/> required to make the metal more stable than the oxide. Anything less than about -2 eV will have the metal more stable. That can be achieved by any one of the following combinations (graphically estimated from Figure ref:ref:fig:mu-o2):
About 500K at 1<img src="ltxpng/dft_48c2be38e7e2852dc148e8e0673e1f218e154436.png" alt="$\times 10^{-10}$"/> atm, 600K at 1<img src="ltxpng/dft_587bf5217a4373ef99dd75e9e4cb2926c628b25d.png" alt="$\times 10^{-5}$"/> atm, 900K at 1atm, etc&hellip;
</p>
</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Effect on adsorption</h3>
<div class="outline-text-3" id="text-6-2">

<p>We now consider the question: Given a pressure and temperature, what coverage would you expect on a surface? We saw earlier that adsorption energies depend on the site and coverage. We lso know the coverage depends on the pressure and temperature. Above some temperature, desorption occurs, and below some pressure adsorption will not be favorable. We seek to develop a quantitative method to determine those conditions.
</p>
<p>
We redefine the adsorption energy as:
</p>
<p>
<img src="ltxpng/dft_134432ecc1ed0986314e2bf6e243da3c93d93787.png" alt="$\Delta G_{ads} \approx E_{slab, ads} - E_{slab} - \mu_{ads}$"/>
</p>
<p>
where again we neglect all contributions to the free energy of the slabs from vibrational energy and entropy, as well as configurational entropy if that is relevant. That leaves only the pressure and temperature dependence of the adsorbate, which we treat in the ideal gas limit.
</p>
<p>
We expand <img src="ltxpng/dft_2a0af0df711e31b6df7559e8b4cbce5c9f39927c.png" alt="$\mu_{ads}$"/> as <img src="ltxpng/dft_86fef7a7ff52ff453c42d52cd070df61bbd4c185.png" alt="$E_{ads}+\Delta \mu(T,p)$"/>, and thus:
</p>
<p>
<img src="ltxpng/dft_78460c591abeb8b86f237fc18d42aa1334e10911.png" alt="$\Delta G_{ads} \approx E_{slab, ads} - E_{slab} - E_{ads} -\Delta \mu(T,p)$"/>
</p>
<p>
or
</p>
<p>
<img src="ltxpng/dft_93deaf1d58ba2423f6eeaeec3b815255a6f91697.png" alt="$\Delta G_{ads} \approx \Delta H_{ads} -\Delta \mu(T,p)$"/>
</p>
<p>
where <img src="ltxpng/dft_3c1a4611a7126067417f9c8dd053f3257b79db1e.png" alt="$\Delta H_{ads}$"/> is the adsorption energy we defined earlier. Now we can examine the effect of <img src="ltxpng/dft_9246925ab305f362318cf66843c9896508dc89d7.png" alt="$\Delta \mu(T,p)$"/> on the adsorption energies. We will use the adsorption energies for the oxygen on Pt(111) system we computed earlier:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>Adsorption site dependence of adsorption energies of oxygen on Pt(111).</caption>
<colgroup><col class="left" /><col class="right" />
</colgroup>
<thead>
<tr><th scope="col" class="left">system</th><th scope="col" class="right"><img src="ltxpng/dft_42f6ac3cc732a0a8cfb31a48faa43ed81ff331a4.png" alt="$\Delta H (eV/O)$"/></th></tr>
</thead>
<tbody>
<tr><td class="left">fcc (0.25 ML)</td><td class="right">-1.04</td></tr>
<tr><td class="left">hcp (0.25 ML)</td><td class="right">-0.60</td></tr>
<tr><td class="left">bridge (0.25 ML)</td><td class="right">-0.49</td></tr>
<tr><td class="left">fcc(1ML)</td><td class="right">-0.10</td></tr>
</tbody>
</table>





<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

fcc25 = -1.04
hcp25 = -0.60
bridge25 = -0.49
fcc1 = -0.10

Dmu = np.linspace(-4,0)

plt.plot(Dmu, np.zeros(Dmu.shape), label=<span style="color: #00cd00;">'Pt(111)'</span>)
plt.plot(Dmu, fcc25 - 0.5*Dmu, label=<span style="color: #00cd00;">'fcc - 0.25 ML'</span>)
plt.plot(Dmu, hcp25 - 0.5*Dmu, label=<span style="color: #00cd00;">'hcp - 0.25 ML'</span>)
plt.plot(Dmu, bridge25 - 0.5*Dmu, label=<span style="color: #00cd00;">'bridge - 0.25 ML'</span>)
plt.plot(Dmu, fcc1 - 0.5*Dmu, label=<span style="color: #00cd00;">'fcc - 1.0 ML'</span>)

plt.xlabel(<span style="color: #00cd00;">'$\Delta \mu O_2$ (eV)'</span>)
plt.ylabel(<span style="color: #00cd00;">'$\Delta G_{ads}$ (eV/O)'</span>)
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/atomistic-thermo-adsorption.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/atomistic-thermo-adsorption.png"  alt="./images/atomistic-thermo-adsorption.png" /></p>
<p>Effect of oxygen chemical potential on the adsorption energy.</p>
</div>
</div>

</div>

<div id="outline-container-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Atomistic therodynamics and multiple reactions</h3>
<div class="outline-text-3" id="text-6-3">


<p>
In (<cite>Inoglu2009188</cite>) we considered multiple reactions in an atomistic thermodynamic framework. Let us consider these three reactions of dissociative adsorption of hydrogen and hydrogen disulfide, and consider how to compute the reaction energy for the third reaction.
</p>
<ol>
<li><img src="ltxpng/dft_d125a6978e7681f467096f686a462a822e1aa5b4.png" alt="$H_2 + 2* \leftrightharpoons 2H*$"/>

</li>
<li><img src="ltxpng/dft_b1e58c506cdec4144a9136a2f7cbb932cd132131.png" alt="$H_2S + 2* \leftrightharpoons H* + SH*$"/>

</li>
<li><img src="ltxpng/dft_b7d42a21cad75d8455e6a82a1fad2e1af9b4e2bc.png" alt="$SH* + * \leftrightharpoons S* + H*$"/>
</li>
</ol>


<p>
The reaction energy of interest is <img src="ltxpng/dft_cbd1622dfb78ca1b4f117b7d8fe46ce1cc2cff30.png" alt="$E_{rxn} = \mu_{S*} + \mu{H*} - \mu{SH*}$"/> The question is, what are these chemical potentials? We would like them in terms of pressures and temperature, preferrably of molecules that can be approximated as ideal gases. By equilibrium arguments we can say that <img src="ltxpng/dft_71076a915bb29611ef03e27afdd9d44800f6c588.png" alt="$\mu_{H*} = \frac{1}{2} \mu_{H_2}$"/>. It follows that at equilibrium:
</p>
<p>
<img src="ltxpng/dft_6e595b5d9d0b05e0f332737b04eef723d172f397.png" alt="$\mu_{H*} + \mu_{SH*} = \mu_{H_2S}$"/> and <img src="ltxpng/dft_7614fcca7fd85ac810f9c8b82f905bbb4ba72572.png" alt="$\mu_{S*} + \mu_{S*} = \mu_{SH*}$"/>.
</p>
<p>
From the first equation we have:
</p>
<p>
<img src="ltxpng/dft_c5600d7b1315169ca1245c408b4adeac86f4cfaa.png" alt="$\mu_{SH*} = \mu_{H_2S} - \frac{1}{2}\mu_{H_2}$"/>
</p>
<p>
and from the second equation we have:
</p>
<p>
<img src="ltxpng/dft_8c478d59ef6cf81542b9a11b70099cd4b0ab2728.png" alt="$\mu_{S*} = \mu_{SH*} - \mu_{H*} = \mu_{H_2S} - \mu_{H_2}$"/>.
</p>
<p>
Thus, the chemical potentials of all these three adsorbed species depend on the chemical potentials of two gas-phase species. The chemical potentials of each of these gases can be defined as:
</p>
<p>
<img src="ltxpng/dft_2a578f29362e20b533492eaab30bd84269065bc6.png" alt="$\mu_{gas}(T,p) = E_{gas}(0K) + \delta \mu + kT\ln\left (p/p^0\right )$"/>, as we have defined before, so that only simple DFT calculations are needed to estimate them.
</p>
</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Advanced electronic structure methods</h2>
<div class="outline-text-2" id="text-7">


</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> DFT+U</h3>
<div class="outline-text-3" id="text-7-1">



<p>
<a href="http://cms.mpi.univie.ac.at/vasp/vasp/On_site_Coulomb_interaction_L_S_DA_U.html">VASP manual on DFT+U</a>
</p>
<p>
It can be difficult to find the lowest energy solutions with DFT+U. Some strategies for improving this are discussed in (<cite>PhysRevB.82.195128</cite>).
</p>
</div>

<div id="outline-container-7-1-1" class="outline-4">
<h4 id="sec-7-1-1"><span class="section-number-4">7.1.1</span> Metal oxide oxidation energies with DFT+U</h4>
<div class="outline-text-4" id="text-7-1-1">

<p>We will reconsider here the reaction (see <a href="#sec-4-8-2">Metal oxide oxidation energies</a>) 2 Cu<sub>2</sub>O + O<sub>2</sub> <img src="ltxpng/dft_a04d4e16df2eebeec37ee6ab4db8b3daa47e1bf0.png" alt="$\rightleftharpoons$"/> 4 CuO. We need to compute the energy of each species, now with DFT+U. In (<cite>PhysRevB.73.195107</cite>) they use a U parameter of 4 eV for Cu which gave the best agreement with the experimental value. We will also try that.
</p>

</div>

<div id="outline-container-7-1-1-1" class="outline-5">
<h5 id="sec-7-1-1-1"><span class="section-number-5">7.1.1.1</span> Cu<sub>2</sub>O calculation with U=4.0</h5>
<div class="outline-text-5" id="text-7-1-1-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu2O'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'bulk/Cu2O-U=4.0'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu2O-U=4.0'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set(ldau=<span style="color: #cd0000; font-weight: bold;">True</span>,   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn DFT+U on</span>
             ldautype=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">select simplified rotationally invariant option</span>
             ldau_luj={<span style="color: #00cd00;">'Cu'</span>:{<span style="color: #00cd00;">'L'</span>:2,  <span style="color: #00cd00;">'U'</span>:4.0, <span style="color: #00cd00;">'J'</span>:0.0},
                        <span style="color: #00cd00;">'O'</span>:{<span style="color: #00cd00;">'L'</span>:-1, <span style="color: #00cd00;">'U'</span>:0.0, <span style="color: #00cd00;">'J'</span>:0.0}},
             ldauprint=1,
             ibrion=-1,  <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">do not rerelax</span>
             nsw=0)
    calc.calculate()
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
</pre>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/bulk/Cu2O-U=4.0
  converged: True
  Energy = -22.228203 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 4.270  0.000  0.000] 4.270
  a1 [ 0.000  4.270  0.000] 4.270
  a2 [ 0.000  0.000  4.270] 4.270
  a,b,c,alpha,beta,gamma (deg): 4.270 4.270 4.270 90.0 90.0 90.0
  Unit cell volume = 77.854 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
             0.018  0.018  0.018 -0.000 -0.000 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    Cu  [0.000      0.000      0.000]   0   0.00      T T T
   1    Cu  [2.135      2.135      0.000]   0   0.00      T T T
   2    Cu  [2.135      0.000      2.135]   0   0.00      T T T
   3    Cu  [0.000      2.135      2.135]   0   0.00      T T T
   4    O   [1.067      1.067      1.067]   0   0.00      T T T
   5    O   [3.202      3.202      3.202]   0   0.00      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 37
           nsw: 0
        ibrion: -1
      ldautype: 2
          isif: 3
     ldauprint: 1
         encut: 400.0
          ldau: True
        magmom: None
         ldaul: [-1.0, 2.0]
         ldauj: [0.0, 0.0]
         ldauu: [0.0, 4.0]
      ldau_luj: {'O': {'J': 0.0, 'U': 0.0, 'L': -1}, 'Cu': {'J': 0.0,
                 'U': 4.0, 'L': 2}}
          prec: Normal
          kpts: [8, 8, 8]
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
O: potpaw_PBE/O/POTCAR (git-hash: 9a0489b46120b0cad515d935f44b5fbe3a3b1dfa)
Cu: potpaw_PBE/Cu/POTCAR (git-hash: a44c591415026f53deb16a99ca3f06b1e69be10b)
</pre>




<pre class="src src-sh">grep -A 3 <span style="color: #00cd00;">"LDA+U is selected, type is set to LDAUTYPE"</span> bulk/Cu2O-U=4.0/OUTCAR
</pre>


<pre class="example">
 LDA+U is selected, type is set to LDAUTYPE =  2
   angular momentum for each species LDAUL =    -1    2
   U (eV)           for each species LDAUU =   0.0  4.0
   J (eV)           for each species LDAUJ =   0.0  0.0
</pre>


</div>

</div>

<div id="outline-container-7-1-1-2" class="outline-5">
<h5 id="sec-7-1-1-2"><span class="section-number-5">7.1.1.2</span> CuO calculation with U=4.0</h5>
<div class="outline-text-5" id="text-7-1-1-2">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/CuO'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.clone(<span style="color: #00cd00;">'bulk/CuO-U=4.0'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/CuO-U=4.0'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.set(ldau=<span style="color: #cd0000; font-weight: bold;">True</span>,   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn DFT+U on</span>
             ldautype=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">select simplified rotationally invariant option</span>
             ldau_luj={<span style="color: #00cd00;">'Cu'</span>:{<span style="color: #00cd00;">'L'</span>:2,  <span style="color: #00cd00;">'U'</span>:4.0, <span style="color: #00cd00;">'J'</span>:0.0},
                        <span style="color: #00cd00;">'O'</span>:{<span style="color: #00cd00;">'L'</span>:-1, <span style="color: #00cd00;">'U'</span>:0.0, <span style="color: #00cd00;">'J'</span>:0.0}},
             ldauprint=1,
             ibrion=-1,  <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">do not rerelax</span>
             nsw=0)
    calc.calculate()
    <span style="color: #cd0000; font-weight: bold;">print</span> calc
</pre>



<pre class="example">: -----------------------------
  VASP calculation from /home/jkitchin/dft-org/bulk/CuO-U=4.0
  converged: True
  Energy = -16.870130 eV

  Unit cell vectors (angstroms)
        x       y     z      length
  a0 [ 2.302 -1.776  0.046] 2.908
  a1 [ 2.302  1.776  0.046] 2.908
  a2 [-0.762  0.000  5.087] 5.144
  a,b,c,alpha,beta,gamma (deg): 2.908 2.908 5.144 95.8 95.8 95.8
  Unit cell volume = 41.730 Ang^3
  Stress (GPa):xx,   yy,    zz,    yz,    xz,    xy
             0.030  0.018  0.027 -0.000 -0.007 -0.000
 Atom#  sym       position [x,y,z]         tag  rmsForce constraints
   0    Cu  [1.151      0.888      0.023]   0   0.00      T T T
   1    Cu  [0.770     -0.888      2.566]   0   0.00      T T T
   2    O   [2.111     -0.168      1.318]   0   0.04      T T T
   3    O   [1.730      0.168      3.861]   0   0.04      T T T
--------------------------------------------------

INCAR Parameters:
-----------------
        nbands: 23
           nsw: 0
        ibrion: -1
      ldautype: 2
          isif: 3
     ldauprint: 1
         encut: 400.0
          ldau: True
        magmom: None
         ldaul: [-1.0, 2.0]
         ldauj: [0.0, 0.0]
         ldauu: [0.0, 4.0]
      ldau_luj: {'O': {'J': 0.0, 'U': 0.0, 'L': -1}, 'Cu': {'J': 0.0,
                 'U': 4.0, 'L': 2}}
          prec: Normal
          kpts: [8, 8, 8]
    reciprocal: False
            xc: PBE
           txt: -
         gamma: False

Pseudopotentials used:
----------------------
O: potpaw_PBE/O/POTCAR (git-hash: 9a0489b46120b0cad515d935f44b5fbe3a3b1dfa)
Cu: potpaw_PBE/Cu/POTCAR (git-hash: a44c591415026f53deb16a99ca3f06b1e69be10b)
</pre>


</div>

</div>

<div id="outline-container-7-1-1-3" class="outline-5">
<h5 id="sec-7-1-1-3"><span class="section-number-5">7.1.1.3</span> Reaction energy calculation with DFT+U</h5>
<div class="outline-text-5" id="text-7-1-1-3">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">don't forget to normalize your total energy to a formula unit. Cu2O</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">has 3 atoms, so the number of formula units in an atoms is</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">len(atoms)/3.</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu2O-U=4.0'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    cu2o_energy = atoms.get_potential_energy()/(<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/3)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/CuO-U=4.0'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    cuo_energy = atoms.get_potential_energy()/(<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/2)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make sure to use the same cutoff energy for the O2 molecule!</span>
<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-400'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    o2_energy = atoms.get_potential_energy()

rxn_energy = 4.0*cuo_energy - o2_energy - 2.0*cu2o_energy
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Reaction energy  = {0} eV'</span>.format(rxn_energy)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Corrected energy = {0} eV'</span>.format(rxn_energy - 1.36)
</pre>


<pre class="example">
Reaction energy  = -1.663819 eV
Corrected energy = -3.023819 eV
</pre>


<p>
This is still not in quantitative agreement with the result in (<cite>PhysRevB.73.195107</cite>), which at U=4 eV is about -3.14 eV (estimated from a graph). We have not applied the O<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/> correction here yet. In that paper, they apply a constant shift of -1.36 eV per O<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/>. After we apply that correction, we agree within 0.12 eV, which is pretty good considering we have not checked for convergence.
</p>
</div>

</div>

<div id="outline-container-7-1-1-4" class="outline-5">
<h5 id="sec-7-1-1-4"><span class="section-number-5">7.1.1.4</span> How much does U affect the reaction energy?</h5>
<div class="outline-text-5" id="text-7-1-1-4">

<p>It is reasonable to consider how sensitive our results are to the U parameter. We do that here.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">for</span> U <span style="color: #cd0000; font-weight: bold;">in</span> [2.0, 4.0, 6.0]:
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;"># Cu2O ########################################</span>
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu2O'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        calc.clone(<span style="color: #00cd00;">'bulk/Cu2O-U={0}'</span>.format(U))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Cu2O-U={0}'</span>.format(U)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        calc.set(ldau=<span style="color: #cd0000; font-weight: bold;">True</span>,   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn DFT+U on</span>
                 ldautype=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">select simplified rotationally invariant option</span>
                 ldau_luj={<span style="color: #00cd00;">'Cu'</span>:{<span style="color: #00cd00;">'L'</span>:2,  <span style="color: #00cd00;">'U'</span>:U, <span style="color: #00cd00;">'J'</span>:0.0},
                           <span style="color: #00cd00;">'O'</span>:{<span style="color: #00cd00;">'L'</span>:-1, <span style="color: #00cd00;">'U'</span>:0.0, <span style="color: #00cd00;">'J'</span>:0.0}},
                ldauprint=1,
                ibrion=-1,  <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">do not rerelax</span>
                nsw=0)
        atoms = calc.get_atoms()
        cu2o_energy = atoms.get_potential_energy()/(<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/3)

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;"># CuO ########################################</span>
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/CuO'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        calc.clone(<span style="color: #00cd00;">'bulk/CuO-U={0}'</span>.format(U))

    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/CuO-U={0}'</span>.format(U)) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        calc.set(ldau=<span style="color: #cd0000; font-weight: bold;">True</span>,   <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">turn DFT+U on</span>
                 ldautype=2,  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">select simplified rotationally invariant option</span>
                 ldau_luj={<span style="color: #00cd00;">'Cu'</span>:{<span style="color: #00cd00;">'L'</span>:2,  <span style="color: #00cd00;">'U'</span>:U, <span style="color: #00cd00;">'J'</span>:0.0},
                           <span style="color: #00cd00;">'O'</span>:{<span style="color: #00cd00;">'L'</span>:-1, <span style="color: #00cd00;">'U'</span>:0.0, <span style="color: #00cd00;">'J'</span>:0.0}},
                ldauprint=1,
                ibrion=-1,  <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">do not rerelax</span>
                nsw=0)
        atoms = calc.get_atoms()
        cuo_energy = atoms.get_potential_energy()/(<span style="color: #cd0000; font-weight: bold;">len</span>(atoms)/2)

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;"># O2 ########################################</span>
    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">make sure to use the same cutoff energy for the O2 molecule!</span>
    <span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O2-sp-triplet-400'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        o2_energy = atoms.get_potential_energy()

    rxn_energy = 4.0*cuo_energy - o2_energy - 2.0*cu2o_energy
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'U = {0}  reaction energy = {1}'</span>.format(U,rxn_energy - 1.99)
</pre>


<pre class="example">
U = 2.0  reaction energy = -3.876906
U = 4.0  reaction energy = -3.653819
U = 6.0  reaction energy = -3.397605
</pre>


<p>
In (<cite>PhysRevB.73.195107</cite>), the difference in reaction energy from U=2 eV to U=4 eV was about 0.5 eV (estimated from graph). Here we see a range of 0.48 eV from U=2 eV to U=4 eV. Note that for U=0 eV, we had a (corrected reaction energy of -3.96 eV). Overall, the effect of adding U decreases this reaction energy.
</p>
<p>
This example highlights the challenge of using an approach like DFT+U. On one hand, U has a clear effect of changing the reaction energy. On the other hand, so does the correction factor for the O<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/> binding energy. In (<cite>PhysRevB.73.195107</cite>) the authors tried to get the O<img src="ltxpng/dft_d2203f7d7b0eb29899720beb797d47056bf8f8d8.png" alt="$_2$"/> binding energy correction from oxide calculations where U is not important, so that it is decoupled from the non-cancelling errors that U fixes. See (<cite>PhysRevB.84.045115</cite>) for additional discussion of how to mix GGA and GGA+U results.
</p>
<p>
In any case, you should be careful to use well converged results to avoid compensating for convergence errors with U.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Hybrid functionals</h3>
<div class="outline-text-3" id="text-7-2">


</div>

<div id="outline-container-7-2-1" class="outline-4">
<h4 id="sec-7-2-1"><span class="section-number-4">7.2.1</span> FCC Ni DOS</h4>
<div class="outline-text-4" id="text-7-2-1">

<p>This example is adapted from <a href="http://cms.mpi.univie.ac.at/wiki/index.php/FccNi_DOS">http://cms.mpi.univie.ac.at/wiki/index.php/FccNi_DOS</a>
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic
<span style="color: #cd0000; font-weight: bold;">from</span> ase.dft <span style="color: #cd0000; font-weight: bold;">import</span> DOS

atoms = FaceCenteredCubic(directions=[[0,1,1],
                                      [1,0,1],
                                      [1,1,0]],
                                      size=(1,1,1),
                                      symbol=<span style="color: #00cd00;">'Ni'</span>)
atoms[0].magmom = 1

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Ni-PBE'</span>,
          ismear=-5,
          kpts=(5,5,5),
          xc=<span style="color: #00cd00;">'PBE'</span>,
          ispin=2,lorbit=11,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'PBE energy:   '</span>,atoms.get_potential_energy()
    dos = DOS(calc,width=0.2)
    e_pbe = dos.get_energies()
    d_pbe = dos.get_dos()

    calc.clone(<span style="color: #00cd00;">'bulk/Ni-PBE0'</span>)
    calc.clone(<span style="color: #00cd00;">'bulk/Ni-HSE06'</span>)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Ni-PBE0'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
     calc.set(lhfcalc=<span style="color: #cd0000; font-weight: bold;">True</span>,
              algo=<span style="color: #00cd00;">'D'</span>,
              time=0.4)
     atoms = calc.get_atoms()
     <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'PBE0 energy:  '</span>,atoms.get_potential_energy()
     dos = DOS(calc,width=0.2)
     e_pbe0 = dos.get_energies()
     d_pbe0 = dos.get_dos()

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/Ni-HSE06'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
     calc.set(lhfcalc=<span style="color: #cd0000; font-weight: bold;">True</span>,
              hfscreen=0.2,
              algo=<span style="color: #00cd00;">'D'</span>, time=0.4)
     atoms = calc.get_atoms()
     <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'HSE06 energy: '</span>, atoms.get_potential_energy()
     dos = DOS(calc,width=0.2)
     e_hse06 = dos.get_energies()
     d_hse06 = dos.get_dos()

<span style="color: #cd0000; font-weight: bold;">import</span> pylab <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(e_pbe, d_pbe, label=<span style="color: #00cd00;">'PBE'</span>)
plt.plot(e_pbe0, d_pbe0, label=<span style="color: #00cd00;">'PBE0'</span>)
plt.plot(e_hse06, d_hse06, label=<span style="color: #00cd00;">'HSE06'</span>)
plt.xlabel(<span style="color: #00cd00;">'energy [eV]'</span>)
plt.ylabel(<span style="color: #00cd00;">'DOS'</span>)
plt.legend()
plt.savefig(<span style="color: #00cd00;">'images/ni-dos-pbe-pbe0-hse06.png'</span>)
</pre>


<pre class="example">
PBE energy:    -5.530247
PBE0 energy:   -6.848931
HSE06 energy:  -6.293369
</pre>



<div class="figure">
<p><img src="./images/ni-dos-pbe-pbe0-hse06.png"  alt="./images/ni-dos-pbe-pbe0-hse06.png" /></p>
<p>Comparison of DOS from GGA, and two hybrid GGAs (PBE0 ad HSE06).</p>
</div>


</div>
</div>

</div>

<div id="outline-container-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> <span class="todo TODO">TODO</span> DFT+D</h3>
<div class="outline-text-3" id="text-7-3">

<p><a href="http://cms.mpi.univie.ac.at/vasp/vasp/DFT_D2_method_Grimme.html">http://cms.mpi.univie.ac.at/vasp/vasp/DFT_D2_method_Grimme.html</a>
(<cite>PhysRevB.82.081101</cite>)
</p>
<p>
Van der Waal forces can play a considerable role in binding of aromatic molecules to metal surfaces <a href="http://th.fhi-berlin.mpg.de/site/uploads/Publications/PRL_submitted_2012063-582-586-2012.pdf">(ref)</a>. Here we consider the effects of these forces on the adsorption energy of benzene on an Au(111) surface.First, we consider the regular PBE functional.
</p>

</div>

<div id="outline-container-7-3-1" class="outline-4">
<h4 id="sec-7-3-1"><span class="section-number-4">7.3.1</span> PBE</h4>
<div class="outline-text-4" id="text-7-3-1">


</div>

<div id="outline-container-7-3-1-1" class="outline-5">
<h5 id="sec-7-3-1-1"><span class="section-number-5">7.3.1.1</span> gas-phase benzene</h5>
<div class="outline-text-5" id="text-7-3-1-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule

benzene = molecule(<span style="color: #00cd00;">'C6H6'</span>)
benzene.center(vacuum=5)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/benzene-pbe'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(1,1,1),
          ibrion=1,
          nsw=100,
          atoms=benzene) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> benzene.get_potential_energy()
</pre>


<pre class="example">
-76.011625
</pre>


</div>

</div>

<div id="outline-container-7-3-1-2" class="outline-5">
<h5 id="sec-7-3-1-2"><span class="section-number-5">7.3.1.2</span> clean slab</h5>
<div class="outline-text-5" id="text-7-3-1-2">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">the clean gold slab</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Au'</span>, size=(3,3,3), vacuum=10)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now we constrain the slab</span>
c = FixAtoms(mask=[atom.symbol==<span style="color: #00cd00;">'Au'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(c)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">from ase.visualize import view; view(atoms)</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Au-pbe'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(4,4,1),
          ibrion=1,
          nsw=100,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_potential_energy()
</pre>


<pre class="example">
-82.419513
</pre>


</div>

</div>

<div id="outline-container-7-3-1-3" class="outline-5">
<h5 id="sec-7-3-1-3"><span class="section-number-5">7.3.1.3</span> benzene on Au(111)</h5>
<div class="outline-text-5" id="text-7-3-1-3">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Benzene on the slab</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Au'</span>, size=(3,3,3), vacuum=10)
benzene = molecule(<span style="color: #00cd00;">'C6H6'</span>)
benzene.translate(-benzene.get_center_of_mass())

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">I want the benzene centered on the position in the middle of atoms</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">20, 22, 23 and 25</span>
p = (atoms.positions[20] +
     atoms.positions[22] +
     atoms.positions[23] +
     atoms.positions[25])/4.0 + [0.0, 0.0, 3.05]

benzene.translate(p)
atoms += benzene

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now we constrain the slab</span>
c = FixAtoms(mask=[atom.symbol==<span style="color: #00cd00;">'Au'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(c)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">from ase.visualize import view; view(atoms)</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Au-benzene-pbe'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(4,4,1),
          ibrion=1,
          nsw=100,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_potential_energy()
</pre>



</div>
</div>

</div>

<div id="outline-container-7-3-2" class="outline-4">
<h4 id="sec-7-3-2"><span class="section-number-4">7.3.2</span> DFT-D2</h4>
<div class="outline-text-4" id="text-7-3-2">

<p>To turn on the van der Waals corrections (<cite>JCC-JCC20495</cite>) we set <a href=http://cms.mpi.univie.ac.at/wiki/index.php/LVDW>LVDW</a> to <code>True</code>.
</p>
</div>

<div id="outline-container-7-3-2-1" class="outline-5">
<h5 id="sec-7-3-2-1"><span class="section-number-5">7.3.2.1</span> gas-phase benzene</h5>
<div class="outline-text-5" id="text-7-3-2-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule

benzene = molecule(<span style="color: #00cd00;">'C6H6'</span>)
benzene.center(vacuum=5)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/benzene-pbe-d2'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(1,1,1),
          ibrion=1,
          nsw=100,
          lvdw=<span style="color: #cd0000; font-weight: bold;">True</span>,
          atoms=benzene) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> benzene.get_potential_energy()
</pre>



</div>

</div>

<div id="outline-container-7-3-2-2" class="outline-5">
<h5 id="sec-7-3-2-2"><span class="section-number-5">7.3.2.2</span> clean slab</h5>
<div class="outline-text-5" id="text-7-3-2-2">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">the clean gold slab</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Au'</span>, size=(3,3,3), vacuum=10)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now we constrain the slab</span>
c = FixAtoms(mask=[atom.symbol==<span style="color: #00cd00;">'Au'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(c)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">from ase.visualize import view; view(atoms)</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Au-pbe-d2'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(4,4,1),
          ibrion=1,
          nsw=100,
          lvdw=<span style="color: #cd0000; font-weight: bold;">True</span>,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_potential_energy()
</pre>



</div>

</div>

<div id="outline-container-7-3-2-3" class="outline-5">
<h5 id="sec-7-3-2-3"><span class="section-number-5">7.3.2.3</span> benzene on Au(111)</h5>
<div class="outline-text-5" id="text-7-3-2-3">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Benzene on the slab</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

atoms = fcc111(<span style="color: #00cd00;">'Au'</span>, size=(3,3,3), vacuum=10)
benzene = molecule(<span style="color: #00cd00;">'C6H6'</span>)
benzene.translate(-benzene.get_center_of_mass())

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">I want the benzene centered on the position in the middle of atoms</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">20, 22, 23 and 25</span>
p = (atoms.positions[20] +
     atoms.positions[22] +
     atoms.positions[23] +
     atoms.positions[25])/4.0 + [0.0, 0.0, 3.05]

benzene.translate(p)
atoms += benzene

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now we constrain the slab</span>
c = FixAtoms(mask=[atom.symbol==<span style="color: #00cd00;">'Au'</span> <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms])
atoms.set_constraint(c)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">from ase.visualize import view; view(atoms)</span>

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'surfaces/Au-benzene-pbe-d2'</span>,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          encut=350,
          kpts=(4,4,1),
          ibrion=1,
          nsw=100,
          lvdw=<span style="color: #cd0000; font-weight: bold;">True</span>,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> atoms.get_potential_energy()
</pre>



</div>
</div>

</div>

<div id="outline-container-7-3-3" class="outline-4">
<h4 id="sec-7-3-3"><span class="section-number-4">7.3.3</span> Advanced vdW-DF functionals</h4>
<div class="outline-text-4" id="text-7-3-3">

<p>There is a more sophisticated (i.e. more parameters) treatment of van der Waal forces in VASP (<a href="http://cms.mpi.univie.ac.at/vasp/vasp/vdW_DF_functional_Langreth_Lundqvist_et_al.html">http://cms.mpi.univie.ac.at/vasp/vasp/vdW_DF_functional_Langreth_Lundqvist_et_al.html</a>).
</p>

</div>
</div>

</div>

<div id="outline-container-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> ELF</h3>
<div class="outline-text-3" id="text-7-4">


<p>
Need better intro here.
</p>




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">compute ELF for CF4</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule
<span style="color: #cd0000; font-weight: bold;">from</span> enthought.mayavi <span style="color: #cd0000; font-weight: bold;">import</span> mlab

atoms = molecule(<span style="color: #00cd00;">'CF4'</span>)
atoms.center(vacuum=5)

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/cf4-elf'</span>,
          encut=350,
          prec=<span style="color: #00cd00;">'high'</span>,
          ismear=0,
          sigma=0.01,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          lelf=<span style="color: #cd0000; font-weight: bold;">True</span>,
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    calc.calculate()

    x,y,z,elf = calc.get_elf()
    mlab.contour3d(x,y,z,elf,contours=[0.3])
    mlab.savefig(<span style="color: #00cd00;">'../../images/cf4-elf-3.png'</span>)

    mlab.figure()
    mlab.contour3d(x,y,z,elf,contours=[0.75])
    mlab.savefig(<span style="color: #00cd00;">'../../images/cf4-elf-75.png'</span>)
</pre>


<pre class="example">
None
</pre>




<div class="figure">
<p><img src="./images/cf4-elf-3.png"  alt="./images/cf4-elf-3.png" /></p>
<p>ELF for an isosurface of 0.3 for CF$_4$. \label{fig:elf1}</p>
</div>



<div class="figure">
<p><img src="./images/cf4-elf-75.png"  alt="./images/cf4-elf-75.png" /></p>
<p>ELF for an isosurface of 0.75 for CF$_4$. \label{fig:elf2}</p>
</div>

<p>
These images (Figure ref:ref:fig:elf1 and ref:ref:fig:elf2) are basically consistent with those in Reference (<cite>silvi1994</cite>).
</p>
</div>

</div>

<div id="outline-container-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> <span class="todo TODO">TODO</span> Charge partitioning schemes</h3>
<div class="outline-text-3" id="text-7-5">

</div>

</div>

<div id="outline-container-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> <span class="todo TODO">TODO</span> Modeling Core level shifts</h3>
<div class="outline-text-3" id="text-7-6">

</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Acknowledgments</h2>
<div class="outline-text-2" id="text-8">

<p>I would like to thank Zhongnan Xu for sending me some examples on magnetism. Alan McGaughey and Lars Grabow for sending me some NEB examples. Matt Curnan for examples of phonons.
</p>
<p>
Many thanks to students in my class who have pointed out typos, places of confusion, etc&hellip; These include Bruno Calfa, Matt Curnan, Charlie Janini, Feng Cao, Gamze Gumuslu, Nicholas Chisholm, Prateek Mehta, Qiyang Duan, Shubhaditya Majumdar, Steven Illes, Wee-Liat Ong, Ye Wang, Yichun Sun, Yubing Lu, and Zhongnan Xu.
</p></div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Appendices</h2>
<div class="outline-text-2" id="text-9">


</div>

<div id="outline-container-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> Recipes</h3>
<div class="outline-text-3" id="text-9-1">


</div>

<div id="outline-container-9-1-1" class="outline-4">
<h4 id="sec-9-1-1"><span class="section-number-4">9.1.1</span> Modifying Atoms by deleting atoms</h4>
<div class="outline-text-4" id="text-9-1-1">

<p>Sometimes it is convenient to create an Atoms object by deleting atoms from an existing object. Here is a recipe to delete all the hydrogen atoms in a molecule. The idea is to make a list of indices of which atoms to delete using list comprehension, then use list deletion to delete those indices.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> textwrap
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data.molecules <span style="color: #cd0000; font-weight: bold;">import</span> molecule

atoms = molecule(<span style="color: #00cd00;">'CH3CH2OH'</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> atoms

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">delete all the hydrogens</span>
ind2del = [atom.index <span style="color: #cd0000; font-weight: bold;">for</span> atom <span style="color: #cd0000; font-weight: bold;">in</span> atoms <span style="color: #cd0000; font-weight: bold;">if</span> atom.symbol==<span style="color: #00cd00;">'H'</span>]
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Indices to delete: '</span>,ind2del

<span style="color: #cd0000; font-weight: bold;">del</span> atoms[ind2del]

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now print what is left</span>
<span style="color: #cd0000; font-weight: bold;">print</span> atoms
</pre>


<pre class="example">
Atoms(symbols='C2OH6', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])
Indices to delete:  [3, 4, 5, 6, 7, 8]
Atoms(symbols='C2O', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])
</pre>


</div>

</div>

<div id="outline-container-9-1-2" class="outline-4">
<h4 id="sec-9-1-2"><span class="section-number-4">9.1.2</span> Advanced tagging</h4>
<div class="outline-text-4" id="text-9-1-2">

<p>We can label atoms with integer tags to help identify them later, e.g. which atoms are adsorbates, or surface atoms, or near an adsorbate, etc&hellip; We might want to refer to those atoms later for electronic structure, geometry analysis, etc&hellip;
</p>
<p>
The method uses integer tags that are powers of two, and then uses binary operators to check for matches. &amp; is a bitwise AND. The key to understanding this is to look at the tags in binary form. The tags [1 2 4 8] can be represented by a binary string:
</p>



<pre class="example">1 = [1 0 0 0]
2 = [0 1 0 0]
4 = [0 0 1 0]
8 = [0 0 0 1]
</pre>


<p>
So, an atom tagged with 1 and 2 would have a tag of [1 1 0 0] or equivalently in decimal numbers, a tag of 3.
</p>



<pre class="src src-python"><span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">adapted from https://listserv.fysik.dtu.dk/pipermail/campos/2004-September/001155.html</span>
<span style="color: #00cd00;">'''</span>

<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.io <span style="color: #cd0000; font-weight: bold;">import</span> write
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> bcc111, add_adsorbate
<span style="color: #cd0000; font-weight: bold;">from</span> ase.constraints <span style="color: #cd0000; font-weight: bold;">import</span> FixAtoms

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">the bcc111 function automatically tags atoms</span>
slab = bcc111(<span style="color: #00cd00;">'W'</span>,
              a=3.92,       <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">W lattice constant</span>
              size=(2,2,6), <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">6-layer slab in 2x2 configuration</span>
              vacuum=10.0)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">reset tags to be powers of two so we can use binary math</span>
slab.set_tags([2**a.get_tag() <span style="color: #cd0000; font-weight: bold;">for</span> a <span style="color: #cd0000; font-weight: bold;">in</span> slab])

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">we had 6 layers, so we create new tags starting at 7</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Note you must use powers of two for all the tags!</span>
LAYER1 = 2
ADSORBATE = 2**7
FREE = 2**8
NEARADSORBATE = 2**9

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">let us tag LAYER1 atoms to be FREE too. we can address it by LAYER1 or FREE</span>
tags = slab.get_tags()
<span style="color: #cd0000; font-weight: bold;">for</span> i,tag <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(tags):
    <span style="color: #cd0000; font-weight: bold;">if</span> tag == LAYER1:
        tags[i] += FREE
slab.set_tags(tags)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">create a CO molecule</span>
co= Atoms([Atom(<span style="color: #00cd00;">'C'</span>,[0., 0., 0. ], tag=ADSORBATE),
           Atom(<span style="color: #00cd00;">'O'</span>,[0., 0., 1.1], tag=ADSORBATE+FREE)]) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we will relax only O</span>

add_adsorbate(slab,co,height=1.2,position=<span style="color: #00cd00;">'hollow'</span>)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">the adsorbate is centered between atoms 20, 21 and 22 (use</span>
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">view(slab)) and over atom12 let us label those atoms, so it is easy to</span>
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">do electronic structure analysis on them later.</span>
tags = slab.get_tags() <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">len(tags) changed, so we reget them.</span>
tags[12]+=NEARADSORBATE
tags[20]+=NEARADSORBATE
tags[21]+=NEARADSORBATE
tags[22]+=NEARADSORBATE
slab.set_tags(tags)
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">update the tags</span>
slab.set_tags(tags)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">extract pieces of the slab based on tags</span>
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">atoms in the adsorbate</span>
ads = slab[(slab.get_tags() &amp; ADSORBATE) == ADSORBATE]

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">atoms in LAYER1</span>
layer1 = slab[(slab.get_tags() &amp; LAYER1) == LAYER1]

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">atoms defined as near the adsorbate</span>
nearads = slab[(slab.get_tags() &amp; NEARADSORBATE) == NEARADSORBATE]

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">atoms that are free</span>
free = slab[(slab.get_tags() &amp; FREE) == FREE]

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">atoms that are FREE and part of the ADSORBATE</span>
freeads = slab[(slab.get_tags() &amp; FREE+ADSORBATE) == FREE+ADSORBATE]

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">atoms that are NOT FREE</span>
notfree = slab[(slab.get_tags() &amp; FREE) != FREE]

constraint = FixAtoms(mask = (slab.get_tags() &amp; FREE) != FREE)
slab.set_constraint(constraint)
write(<span style="color: #00cd00;">'images/tagged-bcc111.png'</span>, slab, rotation=<span style="color: #00cd00;">'-90x'</span>, show_unit_cell=2)
<span style="color: #cd0000; font-weight: bold;">from</span> ase.visualize <span style="color: #cd0000; font-weight: bold;">import</span> view; view(slab)
</pre>




<div class="figure">
<p><img src="./images/tagged-bcc111.png"  alt="./images/tagged-bcc111.png" /></p>
<p>The tagged bcc(111) structure created above. Unfortunately, the frozen atoms do not show up in the figure.</p>
</div>
</div>

</div>

<div id="outline-container-9-1-3" class="outline-4">
<h4 id="sec-9-1-3"><span class="section-number-4">9.1.3</span> Using units in ase</h4>
<div class="outline-text-4" id="text-9-1-3">

<p><TT>ase</TT> uses a base set of atomic units.These are eV for energy, <img src="ltxpng/dft_2bd5cfdc7ed79f11b1b910921b594a109741bfdf.png" alt="$\AA$"/> for distance, seconds for time, and amu for mass. Other units are defined in terms of those units, and you can easily convert to alternative units by dividing your quantity in atomic units by the units you want.
</p>
<p>
Not too many units are defined:
['A', 'AUT', 'Ang', 'Angstrom', 'Bohr', 'C', 'Debye', 'GPa', 'Ha', 'Hartree', 'J', 'Pascal', 'Ry', 'Rydberg', 'alpha', 'cm', 'eV', 'erg', 'fs', 'kB', 'kJ', 'kcal', 'kg', 'm', 'meV', 'mol', 'nm', 's', 'second']
</p>
<p>
It is not that hard to define your own derived units though. Note these  are only conversion factors. No units algebra is enforced (i.e. it will be ok to add a m and a kg)!
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.units <span style="color: #cd0000; font-weight: bold;">import</span> *

d = 1*Angstrom
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">' d = {0} nm'</span>.format(d/nm)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'1 eV = {0} Hartrees'</span>.format(eV/Hartree)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'1 eV = {0} Rydbergs'</span>.format(eV/Rydberg)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'1 eV = {0} kJ/mol'</span>.format(eV/(kJ/mol))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'1 eV = {0} kcal/mol'</span>.format(eV/(kcal/mol))

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'1 Hartree = {0} kcal/mol'</span>.format(1*Hartree/(kcal/mol))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'1 Rydberg = {0} eV'</span>.format(1*Rydberg/eV)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">derived units</span>
minute = 60*s
hour = 60*minute

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">convert 10 hours to minutes</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'10 hours = {0} minutes'</span>.format(10*hour/minute)
</pre>


<pre class="example">
 d = 0.1 nm
1 eV = 0.036749 Hartrees
1 eV = 0.073499 Rydbergs
1 eV = 96.485309 kJ/mol
1 eV = 23.060542 kcal/mol
1 Hartree = 627.509541 kcal/mol
1 Rydberg = 13.605698 eV
10 hours = 600.0 minutes
</pre>


</div>

</div>

<div id="outline-container-9-1-4" class="outline-4">
<h4 id="sec-9-1-4"><span class="section-number-4">9.1.4</span> Extracting parts of an array</h4>
<div class="outline-text-4" id="text-9-1-4">


<p>
See <a href="http://www.scipy.org/Cookbook/BuildingArrays">http://www.scipy.org/Cookbook/BuildingArrays</a> for examples of making numpy arrays.
</p>

<p>
When analyzing numerical data you may often want to analyze only a part of the data. For example, suppose you have <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/> and <img src="ltxpng/dft_7caba42fa0145427d12beda30808356e5038ef71.png" alt="$y$"/> data, (<img src="ltxpng/dft_02d8901eb2633bf225ade6bfc031e446fe2a7a09.png" alt="\(x\)"/>=time, <img src="ltxpng/dft_80d411d9cb40acb189c0781d1fd29b9e4813818c.png" alt="\(y\)"/>=signal) and you want to integrate the date between a particular time interval. You can slice a numpy array to extract parts of it. See <a href="http://www.scipy.org/Cookbook/Indexing">http://www.scipy.org/Cookbook/Indexing</a> for several examples of this.
</p>
<p>
In this example we show how to extract the data in an interval. We have <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/> data in the range of 0 to 6, and <img src="ltxpng/dft_7caba42fa0145427d12beda30808356e5038ef71.png" alt="$y$"/> data that is the <img src="ltxpng/dft_92298bd26d3084c7dc2858b45e2bd9b0d8702f32.png" alt="$\cos(x)$"/>. We want to extract the <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/> and <img src="ltxpng/dft_7caba42fa0145427d12beda30808356e5038ef71.png" alt="$y$"/> data for <img src="ltxpng/dft_ef5d0b6cf2a0b7c1ced1f5a078ea0f47a198e99a.png" alt="$2 < x < 4$"/>, and the corresponding y-data. To do this, we utilize the numpy capability of slicing with a boolean array. We also show some customization of matplotlib.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib <span style="color: #cd0000; font-weight: bold;">as</span> mpl
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">http://matplotlib.sourceforge.net/users/customizing.html</span>
mpl.rcParams[<span style="color: #00cd00;">'legend.numpoints'</span>] = 1 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">default is 2</span>
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

x = np.linspace(0,6,100)
y = np.cos(x)

plt.plot(x,y,label=<span style="color: #00cd00;">'full'</span>)

ind = (x&gt;2) &amp; (x&lt;4)

subx = x[ind]
suby = y[ind]

plt.plot(subx,suby,<span style="color: #00cd00;">'bo'</span>,label=<span style="color: #00cd00;">'sliced'</span>)
xlabel(<span style="color: #00cd00;">'x'</span>)
ylabel(<span style="color: #00cd00;">'cos(x)'</span>)
plt.legend(loc=<span style="color: #00cd00;">'lower right'</span>)
plt.savefig(<span style="color: #00cd00;">'images/np-array-slice.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/np-array-slice.png"  alt="./images/np-array-slice.png" /></p>
<p>Example of slicing out part of an array. The solid line represents the whole array, and the symbols are the array between $2 &lt; x &lt; 4$.</p>
</div>
<p>
The expression <img src="ltxpng/dft_6c8fb1bd99c5e9041ad2f03d5bfbf78f950d49d0.png" alt="\(x>2\)"/> returns an array of booleans (True where the element of <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/> is greater than 2, and False where it is not) equal in size to <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/>. Similarly <img src="ltxpng/dft_ff0c75564cce658a1b5d52c1adab96713874c1c8.png" alt="\(x<4\)"/> returns a boolean array where <img src="ltxpng/dft_b156a73172ae47d31839816953f77103dca20741.png" alt="$x$"/> is less than 4. We take the logical <code>and</code> of these two boolean arrays to get another boolean array where both conditions are True (i.e. <img src="ltxpng/dft_8bfaf7457987bbfb273bf9d7b65856c4482ca5a6.png" alt="\(x<2\)"/> and <img src="ltxpng/dft_89887c8fc849054ac536fd6cd65f96a0017ad4ac.png" alt="\(x>4\)"/>). This final boolean array is <code>True</code> for the part of the arrays we are interested in, and we can use it to extract the subarrays we want.
</p>
</div>

</div>

<div id="outline-container-9-1-5" class="outline-4">
<h4 id="sec-9-1-5"><span class="section-number-4">9.1.5</span> Statistics</h4>
<div class="outline-text-4" id="text-9-1-5">


</div>

<div id="outline-container-9-1-5-1" class="outline-5">
<h5 id="sec-9-1-5-1"><span class="section-number-5">9.1.5.1</span> Confidence intervals</h5>
<div class="outline-text-5" id="text-9-1-5-1">

<p><TT>scipy</TT> has a statistical package available for getting statistical distributions. This is useful for computing confidence intervals using the student-t tables. Here is an example of computing a 95% confidence interval on an average.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> scipy.stats.distributions <span style="color: #cd0000; font-weight: bold;">import</span>  t

n = 10 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">number of measurements</span>
dof = n - 1 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">degrees of freedom</span>
avg_x = 16.1 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">average measurement</span>
std_x = 0.01 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">standard deviation of measurements</span>

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">Find 95% prediction interval for next measurement</span>

alpha = 1.0 - 0.95

pred_interval = t.ppf(1-alpha/2., dof) * std_x * np.sqrt(1.+1./n)

s = [<span style="color: #00cd00;">'We are 95% confident the next measurement'</span>,
       <span style="color: #00cd00;">' will be between {0:1.3f} and {1:1.3f}'</span>]
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">''</span>.join(s).format(avg_x - pred_interval, avg_x + pred_interval)
</pre>


<pre class="example">
We are 95% confident the next measurement will be between 16.076 and 16.124
</pre>


</div>
</div>

</div>

<div id="outline-container-9-1-6" class="outline-4">
<h4 id="sec-9-1-6"><span class="section-number-4">9.1.6</span> Curve fitting</h4>
<div class="outline-text-4" id="text-9-1-6">


</div>

<div id="outline-container-9-1-6-1" class="outline-5">
<h5 id="sec-9-1-6-1"><span class="section-number-5">9.1.6.1</span> Linear fitting</h5>
<div class="outline-text-5" id="text-9-1-6-1">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">examples of linear curve fitting using least squares</span>
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

xdata = np.array([0.,1.,2.,3.,4.,5.,6.])
ydata = np.array([0.1, 0.81, 4.03, 9.1, 15.99, 24.2, 37.2])

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">fit a third order polynomial</span>
<span style="color: #cd0000; font-weight: bold;">from</span> pylab <span style="color: #cd0000; font-weight: bold;">import</span> polyfit, plot, xlabel, ylabel, show, legend, savefig
pars = polyfit(xdata,ydata,3)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'pars from polyfit: {0}'</span>.format(pars)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;"># numpy method returns more data</span>
A = np.column_stack([xdata**3,
                     xdata**2,
                     xdata,
                     np.ones(<span style="color: #cd0000; font-weight: bold;">len</span>(xdata),np.float)])

pars_np,resids,rank,s = np.linalg.lstsq(A, ydata)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'pars from np.linalg.lstsq: {0}'</span>.format(pars_np)

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">we are trying to solve Ax = b for x in the least squares sense. There</span>
<span style="color: #00cd00;">are more rows in A than elements in x so, we can left multiply each</span>
<span style="color: #00cd00;">side by A^T, and then solve for x with an inverse.</span>

<span style="color: #00cd00;">A^TAx = A^Tb</span>
<span style="color: #00cd00;">x = (A^TA)^-1 A^T b</span>
<span style="color: #00cd00;">'''</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">not as pretty but equivalent!</span>
pars_man= np.dot(np.linalg.inv(np.dot(A.T,A)), np.dot(A.T,ydata))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'pars from linear algebra: {0}'</span>.format(pars_man)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">but, it is easy to fit an exponential function to it!</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">y = a*exp(x)+b</span>
Aexp = np.column_stack([np.exp(xdata), np.ones(<span style="color: #cd0000; font-weight: bold;">len</span>(xdata), np.float)])
pars_exp=np.dot(np.linalg.inv(np.dot(Aexp.T, Aexp)), np.dot(Aexp.T, ydata))

plot(xdata, ydata, <span style="color: #00cd00;">'ro'</span>)
fity = np.dot(A, pars)
plot(xdata, fity, <span style="color: #00cd00;">'k-'</span>, label=<span style="color: #00cd00;">'poly fit'</span>)
plot(xdata, np.dot(Aexp, pars_exp), <span style="color: #00cd00;">'b-'</span>, label=<span style="color: #00cd00;">'exp fit'</span>)
xlabel(<span style="color: #00cd00;">'x'</span>)
ylabel(<span style="color: #00cd00;">'y'</span>)
legend()
savefig(<span style="color: #00cd00;">'images/curve-fit-1.png'</span>)
</pre>


<pre class="example">
pars from polyfit: [ 0.04861111  0.63440476  0.61365079 -0.08928571]
pars from np.linalg.lstsq: [ 0.04861111  0.63440476  0.61365079 -0.08928571]
pars from linear algebra: [ 0.04861111  0.63440476  0.61365079 -0.08928571]
</pre>



<div class="figure">
<p><img src="./images/curve-fit-1.png"  alt="./images/curve-fit-1.png" /></p>
<p>Example of linear least-squares curve fitting.</p>
</div>

</div>
</div>

</div>

<div id="outline-container-9-1-7" class="outline-4">
<h4 id="sec-9-1-7"><span class="section-number-4">9.1.7</span> Nonlinear curve fitting</h4>
<div class="outline-text-4" id="text-9-1-7">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> scipy.optimize <span style="color: #cd0000; font-weight: bold;">import</span> leastsq
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

vols = np.array([13.71, 14.82, 16.0, 17.23, 18.52])

energies = np.array([-56.29, -56.41, -56.46, -56.463,-56.41])

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">Murnaghan</span>(parameters,vol):
    <span style="color: #00cd00;">'From Phys. Rev. B 28, 5480 (1983)'</span>
    E0 = parameters[0]
    B0 = parameters[1]
    BP = parameters[2]
    V0 = parameters[3]

    E = E0 + B0*vol/BP*(((V0/vol)**BP)/(BP-1)+1) - V0*B0/(BP-1.)

    <span style="color: #cd0000; font-weight: bold;">return</span> E

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">objective</span>(pars,y,x):
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we will minimize this function</span>
    err =  y - Murnaghan(pars,x)
    <span style="color: #cd0000; font-weight: bold;">return</span> err

x0 = [ -56., 0.54, 2., 16.5] <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">initial guess of parameters</span>

plsq = leastsq(objective, x0, args=(energies,vols))

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Fitted parameters = {0}'</span>.format(plsq[0])

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(vols,energies,<span style="color: #00cd00;">'ro'</span>)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">plot the fitted curve on top</span>
x = np.linspace(<span style="color: #cd0000; font-weight: bold;">min</span>(vols),<span style="color: #cd0000; font-weight: bold;">max</span>(vols),50)
y = Murnaghan(plsq[0],x)
plt.plot(x,y,<span style="color: #00cd00;">'k-'</span>)
plt.xlabel(<span style="color: #00cd00;">'Volume'</span>)
plt.ylabel(<span style="color: #00cd00;">'energy'</span>)
plt.savefig(<span style="color: #00cd00;">'images/nonlinear-curve-fitting.png'</span>)
</pre>


<pre class="example">
Fitted parameters = (array([-56.46839641,   0.57233217,   2.7407944 ,  16.55905648]), 1)
</pre>



<div class="figure">
<p><img src="./images/nonlinear-curve-fitting.png"  alt="./images/nonlinear-curve-fitting.png" /></p>
<p>Example of least-squares non-linear curve fitting.</p>
</div>

<p>
See additional examples at \url{<a href="http://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html">http://docs.scipy.org/doc/scipy/reference/tutorial/optimize.html</a>}.
</p>
</div>

</div>

<div id="outline-container-9-1-8" class="outline-4">
<h4 id="sec-9-1-8"><span class="section-number-4">9.1.8</span> Nonlinear curve fitting by direct least squares minimization</h4>
<div class="outline-text-4" id="text-9-1-8">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> scipy.optimize <span style="color: #cd0000; font-weight: bold;">import</span> fmin
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

volumes = np.array([13.71, 14.82, 16.0, 17.23, 18.52])

energies = np.array([-56.29, -56.41, -56.46, -56.463,-56.41])

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">Murnaghan</span>(parameters,vol):
    <span style="color: #00cd00;">'From PRB 28,5480 (1983'</span>
    E0 = parameters[0]
    B0 = parameters[1]
    BP = parameters[2]
    V0 = parameters[3]

    E = E0 + B0*vol/BP*(((V0/vol)**BP)/(BP-1)+1) - V0*B0/(BP-1.)

    <span style="color: #cd0000; font-weight: bold;">return</span> E

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">objective</span>(pars,vol):
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we will minimize this function</span>
    err =  energies - Murnaghan(pars,vol)
    <span style="color: #cd0000; font-weight: bold;">return</span> np.sum(err**2) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we return the summed squared error directly</span>

x0 = [ -56., 0.54, 2., 16.5] <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">initial guess of parameters</span>

plsq = fmin(objective,x0,args=(volumes,)) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">note args is a tuple</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'parameters = {0}'</span>.format(plsq)

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(volumes,energies,<span style="color: #00cd00;">'ro'</span>)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">plot the fitted curve on top</span>
x = np.linspace(<span style="color: #cd0000; font-weight: bold;">min</span>(volumes),<span style="color: #cd0000; font-weight: bold;">max</span>(volumes),50)
y = Murnaghan(plsq,x)
plt.plot(x,y,<span style="color: #00cd00;">'k-'</span>)
plt.xlabel(<span style="color: #00cd00;">'Volume ($\AA^3$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/nonlinear-fitting-lsq.png'</span>)
</pre>


<pre class="example">
Optimization terminated successfully.
         Current function value: 0.000020
         Iterations: 137
         Function evaluations: 240
parameters = [-56.46932645   0.59141447   1.9044796   16.59341303]
</pre>



<div class="figure">
<p><img src="./images/nonlinear-fitting-lsq.png"  alt="./images/nonlinear-fitting-lsq.png" /></p>
<p>Fitting a nonlinear function.</p>
</div>

</div>

</div>

<div id="outline-container-9-1-9" class="outline-4">
<h4 id="sec-9-1-9"><span class="section-number-4">9.1.9</span> Nonlinear curve fitting with confidence intervals</h4>
<div class="outline-text-4" id="text-9-1-9">




<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Nonlinear curve fit with confidence interval</span>
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> scipy.optimize <span style="color: #cd0000; font-weight: bold;">import</span> curve_fit
<span style="color: #cd0000; font-weight: bold;">from</span> scipy.stats.distributions <span style="color: #cd0000; font-weight: bold;">import</span>  t

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">fit this equation to data</span>
<span style="color: #00cd00;">y = c1 exp(-x) + c2*x</span>

<span style="color: #00cd00;">this is actually a linear regression problem, but it is convenient to</span>
<span style="color: #00cd00;">use the nonlinear fitting routine because it makes it easy to get</span>
<span style="color: #00cd00;">confidence intervals. The downside is you need an initial guess.</span>

<span style="color: #00cd00;">from Matlab</span>
<span style="color: #00cd00;">b =</span>

<span style="color: #00cd00;">    4.9671</span>
<span style="color: #00cd00;">    2.1100</span>


<span style="color: #00cd00;">bint =</span>

<span style="color: #00cd00;">    4.6267    5.3075</span>
<span style="color: #00cd00;">    1.7671    2.4528</span>
<span style="color: #00cd00;">'''</span>

x = np.array([ 0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9,  1. ])
y = np.array([ 4.70192769,  4.46826356,  4.57021389,  4.29240134,  3.88155125,
            3.78382253,  3.65454727,  3.86379487,  4.16428541,  4.06079909])

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this is the function we want to fit to our data</span>
<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">func</span>(x,c0, c1):
    <span style="color: #cd0000; font-weight: bold;">return</span> c0 * np.exp(-x) + c1*x

pars, pcov = curve_fit(func, x, y, p0=[4.96, 2.11])

alpha = 0.05 <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">95% confidence interval</span>

n = <span style="color: #cd0000; font-weight: bold;">len</span>(y)    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">number of data points</span>
p = <span style="color: #cd0000; font-weight: bold;">len</span>(pars) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">number of parameters</span>

dof = <span style="color: #cd0000; font-weight: bold;">max</span>(0, n-p) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">number of degrees of freedom</span>

tval = t.ppf(1.0-alpha/2., dof) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">student-t value for the dof and confidence level</span>

<span style="color: #cd0000; font-weight: bold;">for</span> i, p,var <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">zip</span>(range(n), pars, np.diag(pcov)):
    sigma = var**0.5
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'c{0}: {1} [{2}  {3}]'</span>.format(i, p,
                                  p - sigma*tval,
                                  p + sigma*tval)

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
plt.plot(x,y,<span style="color: #00cd00;">'bo '</span>)
xfit = np.linspace(0,1)
yfit = func(xfit, pars[0], pars[1])
plt.plot(xfit,yfit,<span style="color: #00cd00;">'b-'</span>)
plt.legend([<span style="color: #00cd00;">'data'</span>,<span style="color: #00cd00;">'fit'</span>],loc=<span style="color: #00cd00;">'best'</span>)
plt.savefig(<span style="color: #00cd00;">'images/nonlin-fit-ci.png'</span>)
</pre>


<pre class="example">
c0: 4.96713966439 [4.62674476321  5.30753456558]
c1: 2.10995112628 [1.76711622067  2.45278603188]
</pre>



<div class="figure">
<p><img src="./images/nonlin-fit-ci.png"  alt="./images/nonlin-fit-ci.png" /></p>
<p>Nonlinear fit to data.</p>
</div>

</div>

</div>

<div id="outline-container-9-1-10" class="outline-4">
<h4 id="sec-9-1-10"><span class="section-number-4">9.1.10</span> Interpolation with splines</h4>
<div class="outline-text-4" id="text-9-1-10">

<p>When you do not know the functional form of data to fit an equation, you can still fit/interpolate with splines.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">use splines to fit and interpolate data</span>
<span style="color: #cd0000; font-weight: bold;">from</span> scipy.interpolate <span style="color: #cd0000; font-weight: bold;">import</span> interp1d
<span style="color: #cd0000; font-weight: bold;">from</span> scipy.optimize <span style="color: #cd0000; font-weight: bold;">import</span> fmin
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

x = np.array([ 0,      1,      2,      3,      4    ])
y = np.array([ 0.,     0.308,  0.55,   0.546,  0.44 ])

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">create the interpolating function</span>
f = interp1d(x, y, kind=<span style="color: #00cd00;">'cubic'</span>, bounds_error=<span style="color: #cd0000; font-weight: bold;">False</span>)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">to find the maximum, we minimize the negative of the function. We</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">cannot just multiply f by -1, so we create a new function here.</span>
f2 = interp1d(x, -y, kind=<span style="color: #00cd00;">'cubic'</span>)
xmax = fmin(f2, 2.5)

xfit = np.linspace(0,4)

plt.plot(x,y,<span style="color: #00cd00;">'bo'</span>)
plt.plot(xfit, f(xfit),<span style="color: #00cd00;">'r-'</span>)
plt.plot(xmax, f(xmax),<span style="color: #00cd00;">'g*'</span>)
plt.legend([<span style="color: #00cd00;">'data'</span>,<span style="color: #00cd00;">'fit'</span>,<span style="color: #00cd00;">'max'</span>], loc=<span style="color: #00cd00;">'best'</span>, numpoints=1)
plt.xlabel(<span style="color: #00cd00;">'x data'</span>)
plt.ylabel(<span style="color: #00cd00;">'y data'</span>)
plt.title(<span style="color: #00cd00;">'Max point = ({0:1.2f}, {1:1.2f})'</span>.format(<span style="color: #cd0000; font-weight: bold;">float</span>(xmax),
                                                    <span style="color: #cd0000; font-weight: bold;">float</span>(f(xmax))))
plt.savefig(<span style="color: #00cd00;">'images/splinefit.png'</span>)
</pre>



<div class="figure">
<p><img src="./images/splinefit.png"  alt="./images/splinefit.png" /></p>
<p>Illustration of a spline fit to data and finding the maximum point.</p>
</div>

<p>
There are other good examples at <a href="http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html">http://docs.scipy.org/doc/scipy/reference/tutorial/interpolate.html</a>
</p>
</div>

</div>

<div id="outline-container-9-1-11" class="outline-4">
<h4 id="sec-9-1-11"><span class="section-number-4">9.1.11</span> Interpolation in 3D</h4>
<div class="outline-text-4" id="text-9-1-11">


<p>
You might ask, why would I need to interpolate in 3D? Suppose you want to plot the charge density along a line through a unit cell that does not correspond to grid points. What are you to do? Interpolate. In contrast to an abundance of methods for 1D and 2D interpolation, I could not find any standard library methods for 3D interpolation.
</p>
<p>
The principle we will use to develop an interpolation function in 3D is called trilinear interpolation, where we use multiple linear 1D interpolations to compute the value of a point inside a cube. As developed here, this solution only applies to rectangular grids. Later we will generalize the approach. We state the problem as follows:
</p>
<p>
We know a scalar field inside a unit cell on a regularly spaced grid. In VASP these fields may be the charge density or electrostatic potential for example, and they are known on the fft grids. We want to estimate the value of the scalar field at a point not on the grid, say P=(a,b,c).
</p>
<p>
Solution: Find the cube that contains the point, and is defined by points
    P1-P8 as shown in Figure ref:ref:fig:trilinearpinterp.
</p>


<div class="figure">
<p><img src="./images/trilinear-interpolation.png"  alt="./images/trilinear-interpolation.png" /></p>
<p>Trilinear interpolation scheme. \label{fig:trilinearpinterp}</p>
</div>

<p>
We use 1D interpolation formulas to compute the value of the scalar field at points I1 by interpolating between P1 and P2, and the value of the scalar field at I2 by interpolating between P3 and P4. In these points the only variable changing is x, so it is a simple 1D interpolation. We can then compute the value of the scalar field at I5 by interpolating between I1 and I2. We repeat the process on the top of the cube, to obtain points I3, I4 and I5. Finally, we compute the value of the scalar field at point P by interpolating between points I5 and I6. Note that the point I5 has coordinates (a,b,z1) and I6 is at (a,b,z2), so the final interpolation is again a 1D interpolation along z evaluated at z=c to get the final value of the scalar field at P=(a,b,c).
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> jasp
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-centered'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    x, y, z, cd = calc.get_charge_density()

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">interp3d</span>(x,y,z,cd,xi,yi,zi):
    <span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">    interpolate a cubic 3D grid defined by x,y,z,cd at the point</span>
<span style="color: #00cd00;">    (xi,yi,zi)</span>
<span style="color: #00cd00;">    '''</span>

    <span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">get_index</span>(value,vector):
        <span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">        assumes vector ordered decreasing to increasing. A bisection</span>
<span style="color: #00cd00;">        search would be faster.</span>
<span style="color: #00cd00;">        '''</span>
        <span style="color: #cd0000; font-weight: bold;">for</span> i,val <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(vector):
            <span style="color: #cd0000; font-weight: bold;">if</span> val &gt; value:
                <span style="color: #cd0000; font-weight: bold;">return</span> i-1
        <span style="color: #cd0000; font-weight: bold;">return</span> <span style="color: #cd0000; font-weight: bold;">None</span>

    xv = x[:,0,0]
    yv = y[0,:,0]
    zv = z[0,0,:]

    a,b,c = xi, yi, zi

    i = get_index(a,xv)
    j = get_index(b,yv)
    k = get_index(c,zv)

    x1 = x[i,j,k]
    x2 = x[i+1,j,k]
    y1 = y[i,j,k]
    y2 = y[i,j+1,k]
    z1 = z[i,j,k]
    z2 = z[i,j,k+1]

    u1 = cd[i, j, k]
    u2 = cd[i+1, j, k]
    u3 = cd[i, j+1, k]
    u4 = cd[i+1, j+1, k]
    u5 = cd[i, j, k+1]
    u6 = cd[i+1, j, k+1]
    u7 = cd[i, j+1, k+1]
    u8 = cd[i+1, j+1, k+1]

    w1 = u2 + (u2-u1)/(x2-x1)*(a-x2)
    w2 = u4 + (u4-u3)/(x2-x1)*(a-x2)
    w3 = w2 + (w2-w1)/(y2-y1)*(b-y2)
    w4 = u5 + (u6-u5)/(x2-x1)*(a-x1)
    w5 = u7 + (u8-u7)/(x2-x1)*(a-x1)
    w6 = w4 + (w5-w4)/(y2-y1)*(b-y1)
    w7 = w3 + (w6-w3)/(z2-z1)*(c-z1)
    u = w7

    <span style="color: #cd0000; font-weight: bold;">return</span> u

pos = atoms.get_positions()

P1 = np.array([0.0, 5.0, 5.0])
P2 = np.array([9.0, 5.0, 5.0])

npoints = 60

points = [P1 + n*(P2-P1)/npoints <span style="color: #cd0000; font-weight: bold;">for</span> n <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(npoints)]

R = [np.linalg.norm(p-P1) <span style="color: #cd0000; font-weight: bold;">for</span> p <span style="color: #cd0000; font-weight: bold;">in</span> points]

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">interpolated line</span>
icd = [interp3d(x,y,z,cd,p[0],p[1],p[2]) <span style="color: #cd0000; font-weight: bold;">for</span> p <span style="color: #cd0000; font-weight: bold;">in</span> points]

<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

plt.plot(R, icd)
cR = np.linalg.norm(pos[0] - P1)
oR = np.linalg.norm(pos[1] - P1)
plt.plot([cR, cR], [0, 2], <span style="color: #00cd00;">'r-'</span>) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">markers for where the nuclei are</span>
plt.plot([oR, oR], [0, 8], <span style="color: #00cd00;">'r-'</span>)
plt.xlabel(<span style="color: #00cd00;">'|R| ($\AA$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Charge density (e/$\AA^3$)'</span>)
plt.savefig(<span style="color: #00cd00;">'images/CO-charge-density.png'</span>)
plt.show()
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/CO-charge-density.png"  alt="./images/CO-charge-density.png" /></p>
<p>An example of interpolated charge density of a CO molecule along the axis of molecule.</p>
</div>

<p>
To generalize this to non-cubic cells, we need to do interpolation along arbitrary vectors. The overall strategy is the same:
</p>
<p>
    Find the cell that contains the point (a,b,c).
    compute the scaled coordinates (sa,sb,sc) of the point inside the cell.
    Do the interpolations along the basis vectors. Given u1 at P1(x1,y1,z1) and u2 at P2(x2,y2,z2) where (P2-P1) is a cell basis vector a, u = u1 + sa*(u2-u1). There are still 7 interpolations to do.
</p>
<p>
Below is an example of this code, using a the python library bisect to find the cell.
</p>



<pre class="src src-python"><span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">3D vector interpolation in non-cubic unit cells with vector</span>
<span style="color: #00cd00;">interpolation.</span>

<span style="color: #00cd00;">This function should work for any shape unit cell.</span>
<span style="color: #00cd00;">'''</span>
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">import</span> bisect
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> pylab <span style="color: #cd0000; font-weight: bold;">import</span> plot, xlabel, ylabel, savefig, show

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/co-centered'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    atoms = calc.get_atoms()
    x,y,z,cd = calc.get_charge_density()

<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">vinterp3d</span>(x,y,z,u,xi,yi,zi):

    p = np.array([xi,yi,zi])

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">1D arrays of cooridinates</span>
    xv = x[:,0,0]
    yv = y[0,:,0]
    zv = z[0,0,:]

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">we subtract 1 because bisect tells us where to insert the</span>
    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">element to maintain an ordered list, so we want the index to the</span>
    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">left of that point</span>
    i = bisect.bisect_right(xv,xi) - 1
    j = bisect.bisect_right(yv,yi) - 1
    k = bisect.bisect_right(zv,zi) - 1

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">points at edge of cell. We only need P1, P2, P3, and P5</span>
    P1 = np.array([x[i,j,k],y[i,j,k],z[i,j,k]])
    P2 = np.array([x[i+1,j,k],y[i+1,j,k],z[i+1,j,k]])
    P3 = np.array([x[i,j+1,k],y[i,j+1,k],z[i,j+1,k]])
    P5 = np.array([x[i,j,k+1],y[i,j,k+1],z[i,j,k+1]])

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">values of u at edge of cell</span>
    u1 = u[i,j,k]
    u2 = u[i+1,j,k]
    u3 = u[i,j+1,k]
    u4 = u[i+1,j+1,k]
    u5 = u[i,j,k+1]
    u6 = u[i+1,j,k+1]
    u7 = u[i,j+1,k+1]
    u8 = u[i+1,j+1,k+1]

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">cell basis vectors, not the unit cell, but the voxel cell containing the point</span>
    cbasis = np.array([P2-P1,
                       P3-P1,
                       P5-P1])

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">now get interpolated point in terms of the cell basis</span>
    s = np.dot(np.linalg.inv(cbasis.T),np.array([xi,yi,zi])-P1)

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">now s = (sa, sb, sc) which are fractional coordinates in the vector space</span>
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">next we do the interpolations</span>
    ui1 = u1 + s[0]*(u2-u1)
    ui2 = u3 + s[0]*(u4-u3)

    ui3 = u5 + s[0]*(u6-u5)
    ui4 = u7 + s[0]*(u8-u7)

    ui5 = ui1 + s[1]*(ui2-ui1)
    ui6 = ui3 + s[1]*(ui4-ui3)

    ui7 = ui5 + s[2]*(ui6-ui5)

    <span style="color: #cd0000; font-weight: bold;">return</span> ui7

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">compute a line with 60 points in it through these two points</span>
P1 = np.array([0.0, 5.0, 5.0])
P2 = np.array([10.0, 5.0, 5.0])

npoints = 60

points = [P1 + n*(P2-P1)/npoints <span style="color: #cd0000; font-weight: bold;">for</span> n <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(npoints)]

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">compute the distance along the line</span>
R = [np.linalg.norm(p-P1) <span style="color: #cd0000; font-weight: bold;">for</span> p <span style="color: #cd0000; font-weight: bold;">in</span> points]

icd = [vinterp3d(x,y,z,cd,p[0],p[1],p[2]) <span style="color: #cd0000; font-weight: bold;">for</span> p <span style="color: #cd0000; font-weight: bold;">in</span> points]

plot(R,icd)
pos = atoms.get_positions()
cR = np.linalg.norm(pos[0]-P1)
oR = np.linalg.norm(pos[1]-P1)
plot([cR,cR],[0,2],<span style="color: #00cd00;">'r-'</span>) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">markers for where the nuclei are</span>
plot([oR,oR],[0,8],<span style="color: #00cd00;">'r-'</span>)
xlabel(<span style="color: #00cd00;">'|R| ($\AA$)'</span>)
ylabel(<span style="color: #00cd00;">'Charge density (e/$\AA^3$)'</span>)
savefig(<span style="color: #00cd00;">'images/interpolated-charge-density.png'</span>)
show()
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/interpolated-charge-density.png"  alt="./images/interpolated-charge-density.png" /></p>
<p>Interpolated charge density for a CO molecule.</p>
</div>

</div>

</div>

<div id="outline-container-9-1-12" class="outline-4">
<h4 id="sec-9-1-12"><span class="section-number-4">9.1.12</span> Reading and writing data</h4>
<div class="outline-text-4" id="text-9-1-12">



</div>

<div id="outline-container-9-1-12-1" class="outline-5">
<h5 id="sec-9-1-12-1"><span class="section-number-5">9.1.12.1</span> Built-in io modules</h5>
<div class="outline-text-5" id="text-9-1-12-1">


<p>
<code>pylab</code> has two convenient and powerful functions for saving and
reading data, <TT>pylab.save</TT> and <TT>pylab.load</TT>.
</p>



<pre class="src src-python">pylab.save(<span style="color: #00cd00;">'pdat.dat'</span>,(x,y))
</pre>


<p>
and later you can read these arrays back in with:
</p>



<pre class="src src-python">x,y = pylab.load(<span style="color: #00cd00;">'pdat.dat'</span>)
</pre>


<p>
see also <TT>pylab.csv2rec</TT> and <TT>pylab.loadtxt</TT> and
<TT>pylab.savetxt</TT>.
</p>
<p>
See <a href="http://www.scipy.org/Cookbook/InputOutput">http://www.scipy.org/Cookbook/InputOutput</a> for examples of numpy io.
</p>
</div>

</div>

<div id="outline-container-9-1-12-2" class="outline-5">
<h5 id="sec-9-1-12-2"><span class="section-number-5">9.1.12.2</span> From scratch</h5>
<div class="outline-text-5" id="text-9-1-12-2">


<p>
You can save data in many ways from scratch. Basically, just open a
file and write data to it. Likewise, any datafile that has some
structure to it can probably be read by python.
</p>
<p>
Let us consider a datafile with these contents:
</p>



<pre class="example">        #header
        #ignore these lines
        john, 4
        robert, 5
        terry, 5
</pre>


<p>
A standard approach would be to read in all the lines, skip the first
two lines, split each line (remember each line is a string) at the
',', and append the first field to one variable, and append the second
field to another variable as an integer.  For example:
</p>



<pre class="src src-python">v1 = []
v2 = []
lines = <span style="color: #cd0000; font-weight: bold;">open</span>(<span style="color: #00cd00;">'somefile'</span>,<span style="color: #00cd00;">'r'</span>).readlines()

<span style="color: #cd0000; font-weight: bold;">for</span> line <span style="color: #cd0000; font-weight: bold;">in</span> lines[2:]: <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">skip the first two lines</span>
    fields = line.split(<span style="color: #00cd00;">','</span>)
        v1.append(fields[0]) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">names</span>
        v2.append(<span style="color: #cd0000; font-weight: bold;">int</span>(fields[1])) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">number</span>
</pre>


<p>
Writing datafiles is easy too.
</p>


<pre class="src src-python">v1 = [<span style="color: #00cd00;">'john'</span>, <span style="color: #00cd00;">'robert'</span>, <span style="color: #00cd00;">'terry'</span>]
v2 = [4,5,6]
f = <span style="color: #cd0000; font-weight: bold;">open</span>(<span style="color: #00cd00;">'somefile'</span>, <span style="color: #00cd00;">'w'</span>) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">note 'w' = write mode</span>
f.write(<span style="color: #00cd00;">'#header\n'</span>)
f.write(<span style="color: #00cd00;">'#ignore these lines\n'</span>)
<span style="color: #cd0000; font-weight: bold;">for</span> a,b <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">zip</span>(v1,v2):
        f.write(<span style="color: #00cd00;">'{0}, {1}\n'</span>.format(a,b))
f.close()
</pre>


<p>
Some notes:
</p><ol>
<li>opening a file in 'w' mode clobbers any existing file, so do that
</li>
</ol>

<p>with care!
</p><ol>
<li>when writing to a file you have to add a carriage return to each line.
</li>
<li>Manually writing and reading files is pretty tedious. Whenever
</li>
</ol>

<p>possible you should use the built-in methods of <TT>numpy</TT> or <TT>pylab</TT>.
</p>
</div>
</div>

</div>

<div id="outline-container-9-1-13" class="outline-4">
<h4 id="sec-9-1-13"><span class="section-number-4">9.1.13</span> Integration</h4>
<div class="outline-text-4" id="text-9-1-13">

<p>Numerical integrations is easy with the numpy.trapz() method. Use it like this: <TT>numpy.trapz</TT>(y,x). Note that y comes first. y and x must be the same length.
</p>
<p>
Integration can be used to calculate average properties of continuous distributions. Suppose for example, we have a density of states, &rho; as a function of energy E. We can integrate the density of states to find the total number of states:
</p>
<p>
<img src="ltxpng/dft_ed15b2213ed3dd63d81724f5d780990203d0bf2c.png" alt="$N_{states} = \int \rho dE$"/>
</p>
<p>
or, in python:
</p>



<pre class="src src-python">Nstates = np.trapz(rho,E)
</pre>


<p>
where rho is a vector that contains the density of states at each energy in the vector E (vector here means a list of numbers).
</p>
<p>
The average energy of distribution is:
</p>
<p>
<img src="ltxpng/dft_db91e587f8bdf02967733c9098c2f5998c48387a.png" alt="$E_{avg} = \frac{\int \rho E dE}{\int \rho dE}$"/>
</p>
<p>
or, in python:
</p>



<pre class="src src-python">e_avg = np.trapz(rho*E,E)/np.trapz(rho,E)
</pre>


<p>
These last two examples are the zeroth and first moments of the density of states. The second moment is related to the width squared of the distribution, and the third and fourth moements are related to skewness and kurtosis of the distribution.
</p>
<p>
The nth moment is defined by:
</p>
<p>
<img src="ltxpng/dft_af6b43d9c9f44c06450770d1e8bb2b08413d6626.png" alt="$m_n = \frac{\int \rho*E^n dE}{\int \rho dE}$"/>
</p>
<p>
To get the second moment of the density of states in python, we use::
</p>



<pre class="src src-python">n = 2
mom_2 = np.trapz(rho*E**n,E)/np.trapz(rho,E)
</pre>


</div>

</div>

<div id="outline-container-9-1-14" class="outline-4">
<h4 id="sec-9-1-14"><span class="section-number-4">9.1.14</span> Numerical differentiation</h4>
<div class="outline-text-4" id="text-9-1-14">

<p>numpy has a function called <TT>numpy.diff</TT> that is similar to the one found in Matlab. It calculates the differences between the elements in your list, and returns a list that is one element shorter, which makes it unsuitable for plotting the derivative of a function.
</p>

</div>

<div id="outline-container-9-1-14-1" class="outline-5">
<h5 id="sec-9-1-14-1"><span class="section-number-5">9.1.14.1</span> Simple loops to define finite difference derivatives</h5>
<div class="outline-text-5" id="text-9-1-14-1">


<p>
Loops in python are pretty slow (relatively speaking) but they are usually trivial to understand. In this script we show some simple ways to construct derivative vectors using loops. It is implied in these formulas that the data points are equally spaced.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">import</span> time

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">These are the brainless way to calculate numerical derivatives. They</span>
<span style="color: #00cd00;">work well for very smooth data. they are surprisingly fast even up to</span>
<span style="color: #00cd00;">10000 points in the vector.</span>
<span style="color: #00cd00;">'''</span>

x = np.linspace(0.78, 0.79, 100) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">100 points between 0.78 and 0.79</span>
y = np.sin(x)
dy_analytical = np.cos(x)
<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">let us use a forward difference method:</span>
<span style="color: #00cd00;">that works up until the last point, where there is not</span>
<span style="color: #00cd00;">a forward difference to use. there, we use a backward difference.</span>
<span style="color: #00cd00;">'''</span>

tf1 = time.time()
dyf = [0.0]*<span style="color: #cd0000; font-weight: bold;">len</span>(x)
<span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(len(y)-1):
    dyf[i] = (y[i+1] - y[i])/(x[i+1]-x[i])
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">set last element by backwards difference</span>
dyf[-1] = (y[-1] - y[-2])/(x[-1] - x[-2])

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">' Forward difference took {0:1.1f} seconds'</span>.format(time.time() - tf1)

<span style="color: #00cd00;">'''and now a backwards difference'''</span>
tb1 = time.time()
dyb = [0.0]*<span style="color: #cd0000; font-weight: bold;">len</span>(x)
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">set first element by forward difference</span>
dyb[0] = (y[0] - y[1])/(x[0] - x[1])
<span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(1,<span style="color: #cd0000; font-weight: bold;">len</span>(y)):
    dyb[i] = (y[i] - y[i-1])/(x[i]-x[i-1])

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">' Backward difference took {0:1.1f} seconds'</span>.format(time.time() - tb1)

<span style="color: #00cd00;">'''and now, a centered formula'''</span>
tc1 = time.time()
dyc = [0.0]*<span style="color: #cd0000; font-weight: bold;">len</span>(x)
dyc[0] = (y[0] - y[1])/(x[0] - x[1])
<span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(1,<span style="color: #cd0000; font-weight: bold;">len</span>(y)-1):
    dyc[i] = (y[i+1] - y[i-1])/(x[i+1]-x[i-1])
dyc[-1] = (y[-1] - y[-2])/(x[-1] - x[-2])

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">' Centered difference took {0:1.1f} seconds'</span>.format(time.time() - tc1)

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">the centered formula is the most accurate formula here</span>
<span style="color: #00cd00;">'''</span>

plt.plot(x,dy_analytical,label=<span style="color: #00cd00;">'analytical derivative'</span>)
plt.plot(x,dyf,<span style="color: #00cd00;">'--'</span>,label=<span style="color: #00cd00;">'forward'</span>)
plt.plot(x,dyb,<span style="color: #00cd00;">'--'</span>,label=<span style="color: #00cd00;">'backward'</span>)
plt.plot(x,dyc,<span style="color: #00cd00;">'--'</span>,label=<span style="color: #00cd00;">'centered'</span>)

plt.legend(loc=<span style="color: #00cd00;">'lower left'</span>)
plt.savefig(<span style="color: #00cd00;">'images/simple-diffs.png'</span>)
</pre>


<pre class="example">
 Forward difference took 0.0 seconds
 Backward difference took 0.0 seconds
 Centered difference took 0.0 seconds
</pre>


<p>
Obviously, all of these evaluations are very fast.
</p>

<div class="figure">
<p><img src="./images/simple-diffs.png"  alt="./images/simple-diffs.png" /></p>
<p>Comparison of different numerical derivatives.</p>
</div>

<p>
Loops are usually not great for performance. Numpy offers some vectorized methods that allow us to compute derivatives without loops, although this comes at the mental cost of harder to understand syntax:
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

x = np.linspace(0,2*np.pi,100)
y = np.sin(x)
dy_analytical = np.cos(x)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">we need to specify the size of dy ahead because diff returns</span>
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">an array of n-1 elements</span>
dy = np.zeros(y.shape,np.float) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we know it will be this size</span>
dy[0:-1] = np.diff(y)/np.diff(x)
dy[-1] = (y[-1] - y[-2])/(x[-1] - x[-2])


<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">calculate dy by center differencing using array slices</span>
<span style="color: #00cd00;">'''</span>

dy2 = np.zeros(y.shape,np.float) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we know it will be this size</span>
dy2[1:-1] = (y[2:] - y[0:-2])/(x[2:] - x[0:-2])
dy2[0] = (y[1]-y[0])/(x[1]-x[0])
dy2[-1] = (y[-1] - y[-2])/(x[-1] - x[-2])

plt.plot(x,y)
plt.plot(x,dy_analytical,label=<span style="color: #00cd00;">'analytical derivative'</span>)
plt.plot(x,dy,label=<span style="color: #00cd00;">'forward diff'</span>)
plt.plot(x,dy2,<span style="color: #00cd00;">'k--'</span>,lw=2,label=<span style="color: #00cd00;">'centered diff'</span>)
plt.legend(loc=<span style="color: #00cd00;">'lower left'</span>)
plt.savefig(<span style="color: #00cd00;">'images/vectorized-diffs.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/vectorized-diffs.png"  alt="./images/vectorized-diffs.png" /></p>
<p>Comparison of different numerical derivatives.</p>
</div>

<p>
If your data is very noisy, you will have a hard time getting good derivatives; derivatives tend to magnify noise. In these cases, you have to employ smoothing techniques, either implicitly by using a multipoint derivative formula, or explicitly by smoothing the data yourself, or taking the derivative of a function that has been fit to the data in the neighborhood you are interested in.
</p>
<p>
Here is an example of a 4-point centered difference of some noisy data:
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

x = np.linspace(0,2*np.pi,100)
y = np.sin(x) + 0.1*np.random.random(size=x.shape)
dy_analytical = np.cos(x)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">2-point formula</span>
dyf = [0.0]*<span style="color: #cd0000; font-weight: bold;">len</span>(x)
<span style="color: #cd0000; font-weight: bold;">for</span> i <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">range</span>(len(y)-1):
    dyf[i] = (y[i+1] - y[i])/(x[i+1]-x[i])
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">set last element by backwards difference</span>
dyf[-1] = (y[-1] - y[-2])/(x[-1] - x[-2])

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">calculate dy by 4-point center differencing using array slices</span>

<span style="color: #00cd00;">\frac{y[i-2] - 8y[i-1] + 8[i+1] - y[i+2]}{12h}</span>

<span style="color: #00cd00;">y[0] and y[1] must be defined by lower order methods</span>
<span style="color: #00cd00;">and y[-1] and y[-2] must be defined by lower order methods</span>
<span style="color: #00cd00;">'''</span>

dy = np.zeros(y.shape,np.float) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we know it will be this size</span>
h = x[1]-x[0] <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">this assumes the points are evenely spaced!</span>
dy[2:-2] = (y[0:-4] - 8*y[1:-3] + 8*y[3:-1] - y[4:])/(12.*h)

dy[0] = (y[1]-y[0])/(x[1]-x[0])
dy[1] = (y[2]-y[1])/(x[2]-x[1])
dy[-2] = (y[-2] - y[-3])/(x[-2] - x[-3])
dy[-1] = (y[-1] - y[-2])/(x[-1] - x[-2])

plt.plot(x,y)
plt.plot(x,dy_analytical,label=<span style="color: #00cd00;">'analytical derivative'</span>)
plt.plot(x,dyf,<span style="color: #00cd00;">'r-'</span>,label=<span style="color: #00cd00;">'2pt-forward diff'</span>)
plt.plot(x,dy,<span style="color: #00cd00;">'k--'</span>,lw=2,label=<span style="color: #00cd00;">'4pt-centered diff'</span>)
plt.legend(loc=<span style="color: #00cd00;">'lower left'</span>)
plt.savefig(<span style="color: #00cd00;">'images/multipt-diff.png'</span>)
</pre>


<pre class="example">
None
</pre>



<div class="figure">
<p><img src="./images/multipt-diff.png"  alt="./images/multipt-diff.png" /></p>
<p>Comparison of 2 point and 4 point numerical derivatives.</p>
</div>

<p>
The derivative is still noisy, but the four-point derivative is a little better than the two-pt formula.
</p>
</div>

</div>

<div id="outline-container-9-1-14-2" class="outline-5">
<h5 id="sec-9-1-14-2"><span class="section-number-5">9.1.14.2</span> FFT derivatives</h5>
<div class="outline-text-5" id="text-9-1-14-2">


<p>
It is possible to perform derivatives using fast fourier transforms (FFT):
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt

N = 101 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">number of points</span>
L = 2*np.pi <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">interval of data</span>

x = np.arange(0.0,L,L/<span style="color: #cd0000; font-weight: bold;">float</span>(N)) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">this does not include the endpoint</span>

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">add some random noise</span>
y = np.sin(x) + 0.05*np.random.random(size=x.shape)
dy_analytical = np.cos(x)

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">http://sci.tech-archive.net/Archive/sci.math/2008-05/msg00401.html</span>

<span style="color: #00cd00;">you can use fft to calculate derivatives!</span>
<span style="color: #00cd00;">'''</span>

<span style="color: #cd0000; font-weight: bold;">if</span> N % 2 == 0:
    k = np.asarray(<span style="color: #cd0000; font-weight: bold;">range</span>(0,N/2)+[0] + <span style="color: #cd0000; font-weight: bold;">range</span>(-N/2+1,0))
<span style="color: #cd0000; font-weight: bold;">else:</span>
    k = np.asarray(<span style="color: #cd0000; font-weight: bold;">range</span>(0,(N-1)/2) +[0] + <span style="color: #cd0000; font-weight: bold;">range</span>(-(N-1)/2,0))

k *= 2*np.pi/L

fd = np.fft.ifft(1.j*k * np.fft.fft(y))

plt.plot(x,y)
plt.plot(x,dy_analytical,label=<span style="color: #00cd00;">'analytical der'</span>)
plt.plot(x,fd,label=<span style="color: #00cd00;">'fft der'</span>)
plt.legend(loc=<span style="color: #00cd00;">'lower left'</span>)

plt.savefig(<span style="color: #00cd00;">'images/fft-der.png'</span>)
</pre>




<div class="figure">
<p><img src="./images/fft-der.png"  alt="./images/fft-der.png" /></p>
<p>Comparison of FFT numerical derivatives.</p>
</div>

<p>
This example does not show any major advantage in the quality of the derivative, and it is almost certain I would never remember how to do this off the top of my head.
</p>
</div>
</div>

</div>

<div id="outline-container-9-1-15" class="outline-4">
<h4 id="sec-9-1-15"><span class="section-number-4">9.1.15</span> NetCDF files</h4>
<div class="outline-text-4" id="text-9-1-15">


<p>
<a href="http://www.unidata.ucar.edu/software/netcdf">NetCDF</a> is a binary,
but cross-platform structured data format.      The input file and
output file for Dacapo is the NetCDF format. On creating a NetCDF file
you must define the dimensions and variables before you can store data
in them. You can create and read NetCDF files in python using one of
the following modules:
</p>
<p>
<TT>Scientific.IO.NetCDF</TT>
(<a href="http://dirac.cnrs-orleans.fr/plone/software/scientificpython/">http://dirac.cnrs-orleans.fr/plone/software/scientificpython/</a>)
</p>
<p>
<TT>netCDF3</TT> (<a href="http://netcdf4-python.googlecode.com/svn/trunk/docs/netCDF3-module.html">http://netcdf4-python.googlecode.com/svn/trunk/docs/netCDF3-module.html</a>)
</p>
<p>
<TT>pycdf</TT> (<a href="http://pysclint.sourceforge.net/pycdf/">http://pysclint.sourceforge.net/pycdf/</a>) this is a very
low level module modelled after the C-api. I am not sure it is completely
bug-free (I have problems with character variables)
</p>
</div>

</div>

<div id="outline-container-9-1-16" class="outline-4">
<h4 id="sec-9-1-16"><span class="section-number-4">9.1.16</span> Python modules</h4>
<div class="outline-text-4" id="text-9-1-16">

<p>The comma separated values (<TT>csv</TT>) module in python allows you to
easily create datafiles:
</p>
<p>
csv writing:
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

x = np.linspace(0.0,6.0,100)
y = np.cos(x)

<span style="color: #cd0000; font-weight: bold;">import</span> csv
writer = csv.writer(<span style="color: #cd0000; font-weight: bold;">open</span>(<span style="color: #00cd00;">"some.csv"</span>, <span style="color: #00cd00;">"w"</span>))
writer.writerows(<span style="color: #cd0000; font-weight: bold;">zip</span>(x,y))
</pre>


<p>
It is not so easy to read the data back in though because the module
only returns strings, so you must turn the strings back into floats (or
whatever other format they should be).
</p>
<p>
csv reading:
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> csv
reader = csv.reader(<span style="color: #cd0000; font-weight: bold;">open</span>(<span style="color: #00cd00;">"some.csv"</span>,<span style="color: #00cd00;">'r'</span>),delimiter=<span style="color: #00cd00;">','</span>)

x,y = [],[]
<span style="color: #cd0000; font-weight: bold;">for</span> row <span style="color: #cd0000; font-weight: bold;">in</span> reader:
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">csv returns strings that must be cast as floats</span>
    a,b = [<span style="color: #cd0000; font-weight: bold;">float</span>(z) <span style="color: #cd0000; font-weight: bold;">for</span> z <span style="color: #cd0000; font-weight: bold;">in</span> row]
    x.append(a)
    y.append(b)
</pre>


<p>
This is almost as much work as manually reading the data though. The
module is more powerful than I have shown here, so one day checkout
<code>pydoc csv</code>.
</p>
<p>
The <TT>pickle</TT> and <TT>shelve</TT> modules of python also offer some
data storage functionality. Check them out some day too.
</p>
</div>

</div>

<div id="outline-container-9-1-17" class="outline-4">
<h4 id="sec-9-1-17"><span class="section-number-4">9.1.17</span> Writing and reading Excel files</h4>
<div class="outline-text-4" id="text-9-1-17">


</div>

<div id="outline-container-9-1-17-1" class="outline-5">
<h5 id="sec-9-1-17-1"><span class="section-number-5">9.1.17.1</span> Writing Excel files</h5>
<div class="outline-text-5" id="text-9-1-17-1">

<p>It is sometimes convenient to do some analysis in Excel. We can create Excel files in python with <TT>xlwt</TT>. Google this module if you need to do this a lot.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> xlwt

wbk = xlwt.Workbook()
sheet = wbk.add_sheet(<span style="color: #00cd00;">'sheet 1'</span>)

volumes = np.array([13.72, 14.83, 16.0, 17.23, 18.52])
energies = np.array([-56.29, -56.41, -56.46, -56.46, -56.42])

<span style="color: #cd0000; font-weight: bold;">for</span> i, pair <span style="color: #cd0000; font-weight: bold;">in</span> <span style="color: #cd0000; font-weight: bold;">enumerate</span>(zip(volumes, energies)):
    vol = pair[0]
    energy = pair[1]
    sheet.write(i,0,vol)
    sheet.write(i,1,energy)
wbk.save(<span style="color: #00cd00;">'images/test-write.xls'</span>)
</pre>


</div>

</div>

<div id="outline-container-9-1-17-2" class="outline-5">
<h5 id="sec-9-1-17-2"><span class="section-number-5">9.1.17.2</span> Reading Excel files</h5>
<div class="outline-text-5" id="text-9-1-17-2">

<p>We can also read Excel files (even on Linux!) with <TT>xlrd</TT>. Let us read in the data we just wrote. We wrote 5 volumes to column 0, and 5 energies to column 1.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> xlrd
wbk = xlrd.open_workbook(<span style="color: #00cd00;">'images/test-write.xls'</span>)
sheet1 = wbk.sheet_by_name(<span style="color: #00cd00;">'sheet 1'</span>)
<span style="color: #cd0000; font-weight: bold;">print</span> sheet1.col_values(0)
<span style="color: #cd0000; font-weight: bold;">print</span> sheet1.col_values(1)
</pre>


<pre class="example">
[13.72, 14.83, 16.0, 17.23, 18.52]
[-56.29, -56.41, -56.46, -56.46, -56.42]
</pre>


</div>
</div>

</div>

<div id="outline-container-9-1-18" class="outline-4">
<h4 id="sec-9-1-18"><span class="section-number-4">9.1.18</span> <span class="todo TODO">TODO</span> making movies</h4>
<div class="outline-text-4" id="text-9-1-18">

<ol>
<li>using animate
</li>
<li>using swftools (png2swf, pdf2swf)
</li>
</ol>

<p>#<a href="http://wiki.swftools.org/wiki/Main_Page#SWF_Tools_0.9.2_.28_Current_Stable_Version_.29_Documentation">http://wiki.swftools.org/wiki/Main_Page#SWF_Tools_0.9.2_.28_Current_Stable_Version_.29_Documentation</a>
</p>
</div>
</div>

</div>

<div id="outline-container-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> Computational geometry</h3>
<div class="outline-text-3" id="text-9-2">


</div>

<div id="outline-container-9-2-1" class="outline-4">
<h4 id="sec-9-2-1"><span class="section-number-4">9.2.1</span> Changing coordinate systems</h4>
<div class="outline-text-4" id="text-9-2-1">

<p>Let A, B, C be the unit cell vectors
</p>


<p>
<img src="ltxpng/dft_20225ed412dd65bea5597f9c13feb46e974d5cec.png" alt="\begin{eqnarray}
A = A1 x + A2 y + A3 z <br/>
B = B1 x + B2 y + B3 z \\
C = C1 x + C2 y + C3 z
\end{eqnarray}"/>
</p>


<p>
and we want to find the vector <img src="ltxpng/dft_4cd7acc5c3a4a11923caa1528f85eea410c30f0d.png" alt="$[s1, s2, s3]$"/> so that
<img src="ltxpng/dft_7e28501e463bd67801f8de67e72d534608f7ab93.png" alt="\(P = s1 A + s2 B + s3 C \)"/>
</p>
<p>
if we expand this, we get:
</p>


<p>
<img src="ltxpng/dft_46db27604d1892294d9def15858301fdd56e7ac6.png" alt="\begin{align*}
&s1 A1 x + s1 A2 y + s1 A3 z   <br/>
&+ s2 B1 x + s2 B2 y + s2 B3 z \\
&+ s3 C1 x + s3 C2 y + s3 C3 z = p1 x + p2 y + p3 z
\end{align*}"/>
</p>


<p>
If we now match coefficients on x, y, and z, we can write a set of
linear equations as:
</p>


<p>
<img src="ltxpng/dft_b28139ae0e0166b121087298343ea5844f0f2d8b.png" alt="\begin{equation}
\left [ \begin{array}{ccc}
A1 & B1 & C1 <br/>
A2 & B2 & C2 \\
A3 & B3 & C3
\end{array}\right]
\left [ \begin{array}{c}
s1 \\
s2 \\
s3 \end{array}\right] =
\left [\begin{array}{c}
p1 \\ p2 \\ p3 \end{array}\right]
\end{equation}"/>
</p>



<p>
or, in standard form:
</p>
<p>
<img src="ltxpng/dft_41a1f9018f7c783dac02ca4b6e49952cabac7419.png" alt="$A^T s = p$"/>
</p>
<p>
and we need to solve for s as:
</p>
<p>
<img src="ltxpng/dft_20848bb917367db13be6239bda2fd448b61f369c.png" alt="$s = (A^T)^{-1} \cdot p$"/>
</p>
<p>
p must be a column vector, so we will have to transpose the positions
provided by the atoms class, and then transpose the final result to
get the positions back into row-vector form:
</p>
<p>
<img src="ltxpng/dft_fb4c9a9366395031eda323f382257b2cb9040cf5.png" alt="$s = ((A^T)^{-1} p^T)^T$"/>
</p>
<p>
Here we implement that in code:
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.surface <span style="color: #cd0000; font-weight: bold;">import</span> fcc111
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
np.set_printoptions(precision=3,suppress=<span style="color: #cd0000; font-weight: bold;">True</span>)

slab = fcc111(<span style="color: #00cd00;">'Pd'</span>,
              a=3.92,       <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Pd lattice constant</span>
              size=(2,2,3), <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">3-layer slab in 1x1 configuration</span>
              vacuum=10.0)

pos = slab.get_positions() <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">these positions use x,y,z vectors as a basis</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">we want to see the atoms in terms of the unitcell vectors</span>
newbasis = slab.get_cell()

s = np.dot(np.linalg.inv(newbasis.T),pos.T).T
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Coordinates in new basis are: \n'</span>,s

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">what we just did is equivalent to the following atoms method</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Scaled coordinates from ase are: \n'</span>,slab.get_scaled_positions()
</pre>



<pre class="example">Coordinates in new basis are:
[[ 0.167  0.167  0.408]
 [ 0.667  0.167  0.408]
 [ 0.167  0.667  0.408]
 [ 0.667  0.667  0.408]
 [-0.167  0.333  0.5  ]
 [ 0.333  0.333  0.5  ]
 [-0.167  0.833  0.5  ]
 [ 0.333  0.833  0.5  ]
 [ 0.     0.     0.592]
 [ 0.5    0.     0.592]
 [ 0.     0.5    0.592]
 [ 0.5    0.5    0.592]]
Scaled coordinates from ase are:
[[ 0.167  0.167  0.408]
 [ 0.667  0.167  0.408]
 [ 0.167  0.667  0.408]
 [ 0.667  0.667  0.408]
 [ 0.833  0.333  0.5  ]
 [ 0.333  0.333  0.5  ]
 [ 0.833  0.833  0.5  ]
 [ 0.333  0.833  0.5  ]
 [ 0.     0.     0.592]
 [ 0.5    0.     0.592]
 [ 0.     0.5    0.592]
 [ 0.5    0.5    0.592]]
</pre>



<p>
The method shown above is general to all basis set transformations. We
examine another case next. Sometimes it is nice if all the coordinates
are integers. For this example, we will use the bcc primitive lattice
vectors and express the positions of each atom in terms of them. By
definition each atomic position should be an integer combination of
the primitive lattice vectors (before relaxation, and assuming one
atom is at the origin, and the unit cell is aligned with the primitive
basis!)
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> BodyCenteredCubic
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
bulk = BodyCenteredCubic(directions=[[1,0,0],
                                     [0,1,0],
                                     [0,0,1]],
                         size=(2,2,2),
                         latticeconstant=2.87,
                         symbol=<span style="color: #00cd00;">'Fe'</span>)


newbasis = 2.87*np.array([[-0.5, 0.5, 0.5],
                          [0.5, -0.5, 0.5],
                          [0.5, 0.5, -0.5]])

pos = bulk.get_positions()

s = np.dot(np.linalg.inv(newbasis.T),pos.T).T
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'atom positions in primitive basis'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> s

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">let us see the unit cell in terms of the primitive basis too</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'unit cell in terms of the primitive basis'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> np.dot(np.linalg.inv(newbasis.T),bulk.get_cell().T).T
</pre>



<pre class="example">atom positions in primitive basis
[[ 0.  0.  0.]
 [ 1.  1.  1.]
 [ 0.  1.  1.]
 [ 1.  2.  2.]
 [ 1.  0.  1.]
 [ 2.  1.  2.]
 [ 1.  1.  2.]
 [ 2.  2.  3.]
 [ 1.  1.  0.]
 [ 2.  2.  1.]
 [ 1.  2.  1.]
 [ 2.  3.  2.]
 [ 2.  1.  1.]
 [ 3.  2.  2.]
 [ 2.  2.  2.]
 [ 3.  3.  3.]]
unit cell in terms of the primitive basis
[[ 0.  2.  2.]
 [ 2.  0.  2.]
 [ 2.  2.  0.]]
</pre>


</div>

</div>

<div id="outline-container-9-2-2" class="outline-4">
<h4 id="sec-9-2-2"><span class="section-number-4">9.2.2</span> Simple distances, angles</h4>
<div class="outline-text-4" id="text-9-2-2">

<p><code>Scientific.Geometry</code> contains several useful functions for
performing vector algebra including computing lengths and angles.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> Scientific.Geometry <span style="color: #cd0000; font-weight: bold;">import</span> Vector

A = Vector([1,1,1])   <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">Scientfic</span>
a = np.array([1,1,1]) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">numpy</span>

B = Vector([0.0,1.0,0.0])

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|A| = '</span>,A.length()        <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">Scientific Python way</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|a| = '</span>,np.sum(a**2)**0.5 <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">numpy way</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|a| = '</span>,np.linalg.norm(a) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">numpy way 2</span>

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'ScientificPython angle = '</span>,A.angle(B) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">in radians</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'numpy angle =            '</span>,np.arccos(np.dot(a/np.linalg.norm(a),B/np.linalg.norm(B)))

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">cross products</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Scientific A .cross. B = '</span>,A.cross(B)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'numpy A .cross. B      = '</span>,np.cross(A,B) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">you can use Vectors in numpy</span>
</pre>



</div>

</div>

<div id="outline-container-9-2-3" class="outline-4">
<h4 id="sec-9-2-3"><span class="section-number-4">9.2.3</span> Unit cell properties</h4>
<div class="outline-text-4" id="text-9-2-3">

<p>The volume of a unit cell can be calculated from <img src="ltxpng/dft_412e2fd728c79cbf644cd942934174aed5fee991.png" alt="$V = (a_1 \times a_2)
\cdot a_3$"/> where <img src="ltxpng/dft_2d111ef7b347a3e8a8bdee173d00a7debb6da304.png" alt="$a_1$"/>, <img src="ltxpng/dft_5166a43a524a56c16d0977ed9a093819c1eaf7ff.png" alt="$a_2$"/> and <img src="ltxpng/dft_e36869b2ac1eccfddb187b80b4db6af8e4864337.png" alt="$a_3$"/> are the unit cell vectors. It
is more convenient, however, to simply evaluate that equation as the
determinant of the matrix describing the unit cell, where each row of
the matrix is a unit cell vector.
</p>
<p>
   <img src="ltxpng/dft_756afa8562c835fe6dc9a3e0a11310dfac21a975.png" alt="$V = |\det(ucell)|$"/>
</p>
<p>
Why do we need to take the absolute value? The sign of the determinant
depends on the handedness of the order of the unit cell vectors. If
they are right-handed the determinant will be positive, and if they
are left-handed the determinant will be negative. Switching any two
rows will change the sign of the determinant and the
handedness. <TT>ase</TT> implements a convenient function to get the
volume of an <TT>Atoms</TT> object: <TT>ase.Atoms.get_volume</TT>.
</p>
<p>
Here are three equivalent ways to compute the unit cell volume.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

a1 = [2, 0, 0]
a2 = [1, 1, 0]
a3 = [0, 0, 10]

uc = np.array([a1, a2, a3])

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'V = {0} ang^3 from dot/cross'</span>.format(np.dot(np.cross(a1,a2),a3))
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'V = {0} ang^3 from det'</span>.format(np.linalg.det(uc))

<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms

atoms = Atoms([],cell=uc) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">empty list of atoms</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'V = {0} ang^3 from get_volume'</span>.format(atoms.get_volume())
</pre>


<pre class="example">
V = 20 ang^3 from dot/cross
V = 20.0 ang^3 from det
V = 20.0 ang^3 from get_volume
</pre>


</div>

</div>

<div id="outline-container-9-2-4" class="outline-4">
<h4 id="sec-9-2-4"><span class="section-number-4">9.2.4</span> d-spacing</h4>
<div class="outline-text-4" id="text-9-2-4">

<p>If you like to set up the vacuum in your slab calculations in terms of
equivalent layers of atoms, you need to calculate the d-spacing (which
is the spacing between parallel planes of atoms) for the hkl plane you
are using. The script below shows several ways to accomplish that.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">from</span> ase.lattice.cubic <span style="color: #cd0000; font-weight: bold;">import</span> FaceCenteredCubic

ag = FaceCenteredCubic(directions=[[1,0,0],
                                   [0,1,0],
                                   [0,0,1]],
                       size=(1,1,1),
                       symbol=<span style="color: #00cd00;">'Ag'</span>,
                       latticeconstant=4.0)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">these are the reciprocal lattice vectors</span>
b1,b2,b3 = np.linalg.inv(ag.get_cell())

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">g(111) = 1*b1 + 1*b2 + 1*b3</span>

<span style="color: #00cd00;">and |g(111)| = 1/d_111</span>
<span style="color: #00cd00;">'''</span>
h,k,l = (1,1,1)
d = 1./np.linalg.norm(h*b1 + k*b2 + l*b3)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'d_111 spacing (method 1) = {0:1.3f} Angstroms'</span>.format(d)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">method #2</span>
hkl = np.array([h,k,l])
G = np.array([b1,b2,b3]) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">reciprocal unit cell</span>

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">Gstar is usually defined as this matrix of dot products:</span>

<span style="color: #00cd00;">Gstar = np.array([[dot(b1,b1), dot(b1,b2), dot(b1,b3)],</span>
<span style="color: #00cd00;">                  [dot(b1,b2), dot(b2,b2), dot(b2,b3)],</span>
<span style="color: #00cd00;">                  [dot(b1,b3), dot(b2,b3), dot(b3,b3)]])</span>

<span style="color: #00cd00;">but I prefer the notationally more compact:</span>
<span style="color: #00cd00;">Gstar = G .dot. transpose(G)</span>

<span style="color: #00cd00;">then, 1/d_hkl^2 = hkl .dot. Gstar .dot. hkl</span>
<span style="color: #00cd00;">'''</span>

Gstar = np.dot(G,G.T)

id2 = np.dot(hkl,np.dot(Gstar,hkl))

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'d_111 spacing (method 2) ='</span>,np.sqrt(1/id2)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">http://books.google.com/books?id=nJHSqEseuIUC&amp;lpg=PA118&amp;ots=YA9TBldoVH</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">&amp;dq=reciprocal%20metric%20tensor&amp;pg=PA119#v=onepage</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">&amp;q=reciprocal%20metric%20tensor&amp;f=false</span>

<span style="color: #00cd00;">'''Finally, many text books on crystallography use long algebraic</span>
<span style="color: #00cd00;">formulas for computing the d-spacing with sin and cos, vector lengths,</span>
<span style="color: #00cd00;">and angles. Below we compute these and use them in the general</span>
<span style="color: #00cd00;">triclinic structure formula which applies to all the structures.</span>
<span style="color: #00cd00;">'''</span>
<span style="color: #cd0000; font-weight: bold;">from</span> Scientific.Geometry <span style="color: #cd0000; font-weight: bold;">import</span> Vector
<span style="color: #cd0000; font-weight: bold;">import</span> math

unitcell = ag.get_cell()
A = Vector(unitcell[0])
B = Vector(unitcell[1])
C = Vector(unitcell[2])

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">lengths of the vectors</span>
a = A.length()<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">*angstroms2bohr</span>
b = B.length()<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">*angstroms2bohr</span>
c = C.length()<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">*angstroms2bohr</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">angles between the vectors in radians</span>
alpha = B.angle(C)
beta = A.angle(C)
gamma = A.angle(B)

<span style="color: #cd0000; font-weight: bold;">print</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'a   b   c   alpha beta gamma'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'{0:1.3f} {1:1.3f} {2:1.3f} {3:1.3f} {4:1.3f} {5:1.3f}\n'</span>.format(a,b,c,
                                                                alpha,beta,gamma)

h,k,l = (1,1,1)

<span style="color: #cd0000; font-weight: bold;">from</span> math <span style="color: #cd0000; font-weight: bold;">import</span> sin, cos

id2 = ((h**2/a**2*sin(alpha)**2
       + k**2/b**2*sin(beta)**2
       + l**2/c**2*sin(gamma)**2
       +2*k*l/b/c*(cos(beta)*cos(gamma)-cos(alpha))
       +2*h*l/a/c*(cos(alpha)*cos(gamma)-cos(beta))
       +2*h*k/a/b*(cos(alpha)*cos(beta)-cos(gamma)))
       /(1-cos(alpha)**2-cos(beta)**2 - cos(gamma)**2
         +2*cos(alpha)*cos(beta)*cos(gamma)))

d = 1/math.sqrt(id2)

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'d_111 spacing (method 3) = {0}'</span>.format(d)

</pre>


<pre class="example">

a   b   c   alpha beta gamma
4.000 4.000 4.000 1.571 1.571 1.571

d_111 spacing (method 3) = 2.30940107676
</pre>


</div>
</div>

</div>

<div id="outline-container-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> Equations of State</h3>
<div class="outline-text-3" id="text-9-3">


<p>
The module <TT>ase.util.eos</TT> uses a simple polynomial equation of
state to find bulk unit cell equilibrium volumes and bulk
modulus. There are several other choices you could use that are more
standard in the literature. Here we summarize them and provide
references to the relevant literature. In each of these cases we show equations for the energy as a function of volume, although sometimes the volume is transformed or normalized.
</p>

</div>

<div id="outline-container-9-3-1" class="outline-4">
<h4 id="sec-9-3-1"><span class="section-number-4">9.3.1</span> Birch-Murnaghan</h4>
<div class="outline-text-4" id="text-9-3-1">

<p>This is probably the most common equation of state used most often,
and is a modification of the original Murnaghan EOS described below. A
current description of the equation is in reference
(<cite>PhysRevB.70.224107</cite>). You can also find the equations for the Vinet and
Poirier-Tarantola equations of state in that reference.
</p>
<p>
Birch-Murnaghan EOS:
</p>
<p>
   <img src="ltxpng/dft_f8aafd9d48d5685a686ddfc463d3b528054f6b42.png" alt="$E(\eta) = E_0 + \frac{9B_0 V_0}{16}(\eta^2-1)^2(6+B'_0(\eta^2-1)-4\eta^2)$"/>
</p>
<p>
where <img src="ltxpng/dft_14ee78e883d6d220b9034f884ff4271f82a4847b.png" alt="$\eta=(V/V_0)^{1/3}$"/>, <img src="ltxpng/dft_1e37e36dc32dc409e6b8952325d41d65e2cb901f.png" alt="$B_0$"/> and <img src="ltxpng/dft_7c10a7de4eb9204e4a30435f5389d62f5bf3044e.png" alt="$B'_0$"/> are the bulk
modulus and its pressure derivative at the equilibrium volume
<img src="ltxpng/dft_7571b229a734c1610236234921f5540cfbbc20ad.png" alt="$V_0$"/>. You may find other derivations of this equation in the
literature too.
</p>
<p>
Two other equations of state in that reference are the Vinet EOS:
</p>
<p>
   <img src="ltxpng/dft_e8591cc9a654f7964e5c7edefcdb98e689ab7ab4.png" alt="$E(\eta) = E_0 + \frac{2 B_0 V_0}{(B'_0-1)^2}(2-(5+3B'_0 (\eta-1) e^{-3(B'_0-1)(\eta-1)/2})$"/>
</p>
<p>
and the Poirier-Tarantola EOS:
</p>
<p>
   <img src="ltxpng/dft_aac87270c1cd1599ee4c3c9b0c3cc637f64f5b6e.png" alt="$E(\varrho) = E_0 + \frac{B_0 V_0 \varrho^2}{6}(3 + \varrho (B'_0-2))$"/>
</p>
<p>
with <img src="ltxpng/dft_2000bd8406ac5bde7a0595a27bd5a4d4eb5fc222.png" alt="$\varrho=-3 \ln(\eta)$"/>.
</p>
</div>

</div>

<div id="outline-container-9-3-2" class="outline-4">
<h4 id="sec-9-3-2"><span class="section-number-4">9.3.2</span> Murnaghan</h4>
<div class="outline-text-4" id="text-9-3-2">

<p>The equation most often used in the Murnaghan  (<cite>Murnaghan1944</cite>)
equation of state is described in (<cite>PhysRevB.28.5480</cite>).
</p>

<p>
   <img src="ltxpng/dft_082e2492b2ae6f586335e24e57e51d516b0d8dc8.png" alt="$E = E_T+\frac{B_0 V}{B'_0}\left[\frac{(V_0/V)^{B'_0}}{B'_0-1}+1\right]-\frac{V_0 B_0}{B'_0-1}$"/>
</p>
<p>
where <img src="ltxpng/dft_b70ccdbf6ac287511bccf199231ceaec2d681b77.png" alt="$V$"/> is the volume, <img src="ltxpng/dft_1e37e36dc32dc409e6b8952325d41d65e2cb901f.png" alt="$B_0$"/> and <img src="ltxpng/dft_7c10a7de4eb9204e4a30435f5389d62f5bf3044e.png" alt="$B'_0$"/> are the bulk
modulus and its pressure derivative at the equilibrium volume
<img src="ltxpng/dft_7571b229a734c1610236234921f5540cfbbc20ad.png" alt="$V_0$"/>. All of these are parameters that are fitted to energy
vs. unit cell volume (<img src="ltxpng/dft_b70ccdbf6ac287511bccf199231ceaec2d681b77.png" alt="$V$"/>) data. When fitting data to this equation a
guess of 2-4 for <img src="ltxpng/dft_7c10a7de4eb9204e4a30435f5389d62f5bf3044e.png" alt="$B'_0$"/> is usually a good start.
</p>
</div>

</div>

<div id="outline-container-9-3-3" class="outline-4">
<h4 id="sec-9-3-3"><span class="section-number-4">9.3.3</span> Birch</h4>
<div class="outline-text-4" id="text-9-3-3">



<p>
The original Birch equation (<cite>Birch</cite>) is:
</p>

<p>
   <img src="ltxpng/dft_ba8361c3bc8782b666469e6c35142c7c2262928d.png" alt="$E = E_0 + \frac{9}{8} B_0 V_0 \left(\left(\frac{V_0}{V}\right)^{\frac{2}{3}}-1\right)^2+\frac{9}{16} B_0 V_0 (B'_0-4)\left(\left(\frac{V}{V_0}\right)^{2/3}-1\right)^3$"/>
</p>
</div>

</div>

<div id="outline-container-9-3-4" class="outline-4">
<h4 id="sec-9-3-4"><span class="section-number-4">9.3.4</span> The Anton-Schmidt Equation of state (<cite>Mayer200323</cite>)</h4>
<div class="outline-text-4" id="text-9-3-4">


<p>
   <img src="ltxpng/dft_4140f978f1e78f2d2d1e9231401061df439db89c.png" alt="$E(V) = E_\infty + \frac{B V_0}{n+1}\left(\frac{V}{V_0}\right)^{n+1} \left( \ln{\frac{V}{V_0}} - \frac{1}{n+1}\right)$"/>
</p>
<p>
where <img src="ltxpng/dft_c2da87968f76faa8a20240e6f55d1c9e64aa2d56.png" alt="$E_\infty$"/> corresponds to the energy at infinite separation,
although the model they use to derive this equation breaks down at
large separations so this is usually not a good estimate of the
cohesive energy. <img src="ltxpng/dft_4a95e7a167dd37c165400bfaa98d5a68f3bd79b4.png" alt="$n$"/> is typically about -2.
</p>
</div>

</div>

<div id="outline-container-9-3-5" class="outline-4">
<h4 id="sec-9-3-5"><span class="section-number-4">9.3.5</span> Fitting data to these equations of state</h4>
<div class="outline-text-4" id="text-9-3-5">

<p>To use these equations of state to find the equilibrium cell volume
and bulk modulus we need a set of calculations that give us the energy
of the unit cell as a function of the cell volume. We then fit that
data to one of the above equations to extract the parameters we want.
All of these equations of state are non-linear in the cell volume,
which means you have to provide some initial guesses for the
parameters.
</p>
<p>
Here we describe a strategy for getting some estimates of the
parameters using a linear least squares fitting of a parabola to the
data to estimate <img src="ltxpng/dft_a9b8d3125fdf6b5fdaa8b3f355290e38ac765357.png" alt="$E_0$"/>, <img src="ltxpng/dft_7571b229a734c1610236234921f5540cfbbc20ad.png" alt="$V_0$"/>, <img src="ltxpng/dft_7f2fa095f6f92a9a535af32a4b581cb58021cc37.png" alt="$B$"/> and
<img src="ltxpng/dft_7c10a7de4eb9204e4a30435f5389d62f5bf3044e.png" alt="$B'_0$"/> which are used as initial guess for a non-linear least
squares fit of the equation of state to the data.
</p>
<p>
The following example illustrates one approach to this problem for the
Murnaghan equation of state:
</p>



<pre class="src src-python"><span style="color: #00cd00;">'''Example of fitting the Birch-Murnaghan EOS to data'''</span>

<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np
<span style="color: #cd0000; font-weight: bold;">import</span> matplotlib.pyplot <span style="color: #cd0000; font-weight: bold;">as</span> plt
<span style="color: #cd0000; font-weight: bold;">from</span> scipy.optimize <span style="color: #cd0000; font-weight: bold;">import</span> leastsq

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">raw data from 2.2.3-al-analyze-eos.py</span>
v = np.array([13.72, 14.83, 16.0, 17.23, 18.52])
e = np.array([-56.29, -56.41, -56.46, -56.46, -56.42])

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">make a vector to evaluate fits on with a lot of points so it looks smooth</span>
vfit = np.linspace(<span style="color: #cd0000; font-weight: bold;">min</span>(v),<span style="color: #cd0000; font-weight: bold;">max</span>(v),100)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">## fit a parabola to the data</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">y = ax^2 + bx + c</span>
a,b,c = np.polyfit(v,e,2) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">this is from pylab</span>

<span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">the parabola does not fit the data very well, but we can use it to get</span>
<span style="color: #00cd00;">some analytical guesses for other parameters.</span>

<span style="color: #00cd00;">V0 = minimum energy volume, or where dE/dV=0</span>
<span style="color: #00cd00;">E = aV^2 + bV + c</span>
<span style="color: #00cd00;">dE/dV = 2aV + b = 0</span>
<span style="color: #00cd00;">V0 = -b/2a</span>

<span style="color: #00cd00;">E0 is the minimum energy, which is:</span>
<span style="color: #00cd00;">E0 = aV0^2 + bV0 + c</span>

<span style="color: #00cd00;">B is equal to V0*d^2E/dV^2, which is just 2a*V0</span>

<span style="color: #00cd00;">and from experience we know Bprime_0 is usually a small number like 4</span>
<span style="color: #00cd00;">'''</span>

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">now here are our initial guesses.</span>
v0 = -b/(2*a)
e0 = a*v0**2 + b*v0 + c
b0 = 2*a*v0
bP = 4

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">now we have to create the equation of state function</span>
<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">Murnaghan</span>(parameters,vol):
    <span style="color: #00cd00;">'''</span>
<span style="color: #00cd00;">    given a vector of parameters and volumes, return a vector of energies.</span>
<span style="color: #00cd00;">    equation From PRB 28,5480 (1983)</span>
<span style="color: #00cd00;">    '''</span>
    E0 = parameters[0]
    B0 = parameters[1]
    BP = parameters[2]
    V0 = parameters[3]

    E = E0 + B0*vol/BP*(((V0/vol)**BP)/(BP-1)+1) - V0*B0/(BP-1.)

    <span style="color: #cd0000; font-weight: bold;">return</span> E

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">and we define an objective function that will be minimized</span>
<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">objective</span>(pars,y,x):
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">we will minimize this function</span>
    err =  y - Murnaghan(pars,x)
    <span style="color: #cd0000; font-weight: bold;">return</span> err

x0 = [e0, b0, bP, v0] <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">initial guesses in the same order used in the Murnaghan function</span>

murnpars, ier = leastsq(objective, x0, args=(e,v)) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">this is from scipy</span>

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">now we make a figure summarizing the results</span>
plt.plot(v,e,<span style="color: #00cd00;">'ro'</span>)
plt.plot(vfit, a*vfit**2 + b*vfit + c,<span style="color: #00cd00;">'--'</span>,label=<span style="color: #00cd00;">'parabolic fit'</span>)
plt.plot(vfit, Murnaghan(murnpars,vfit), label=<span style="color: #00cd00;">'Murnaghan fit'</span>)
plt.xlabel(<span style="color: #00cd00;">'Volume ($\AA^3$)'</span>)
plt.ylabel(<span style="color: #00cd00;">'Energy (eV)'</span>)
plt.legend(loc=<span style="color: #00cd00;">'best'</span>)

<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">add some text to the figure in figure coordinates</span>
ax = plt.gca()
plt.text(0.4, 0.5, <span style="color: #00cd00;">'Min volume = {0:1.2f} $\AA^3$'</span>.format(murnpars[3]),
     transform = ax.transAxes)
plt.text(0.4, 0.4, <span style="color: #00cd00;">'Bulk modulus = {0:1.2f} eV/$\AA^3$ = {1:1.2f} GPa'</span>.format(murnpars[1],
                                                                          murnpars[1]*160.21773),
     transform = ax.transAxes)
plt.savefig(<span style="color: #00cd00;">'images/a-eos.png'</span>)

np.set_printoptions(precision=3)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'initial guesses  : '</span>, np.array(x0) <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">array for easy printing</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'fitted parameters: '</span>, murnpars

</pre>


<pre class="example">
initial guesses  :  [-56.472   0.631   4.     16.79 ]
fitted parameters:  [-56.466   0.49    4.753  16.573]
</pre>



<div class="figure">
<p><img src="./images/a-eos.png"  alt="./images/a-eos.png" /></p>
<p>Fitted equation of state for bulk data. The initial fitted parabola is shown to illustrate how it is useful for making initial guesses of the minimum and bulk modulus.</p>
</div>

<p>
You can see the Murnaghan equation of state fits the data better than
the parabola.
</p>
<p>
Here is a comparison of the initial guesses and final parameters. You
can see our guesses from the parabola were actually pretty good, and
are the main reason we converged to a solution. If you try other
guesses you will probably find the <code>scipy.optimize.leastsq</code> function
does not converge.
</p>
</div>
</div>

</div>

<div id="outline-container-9-4" class="outline-3">
<h3 id="sec-9-4"><span class="section-number-3">9.4</span> Miscellaneous \texttt{jasp}/VASP tips</h3>
<div class="outline-text-3" id="text-9-4">


</div>

<div id="outline-container-9-4-1" class="outline-4">
<h4 id="sec-9-4-1"><span class="section-number-4">9.4.1</span> Installing jasp</h4>
<div class="outline-text-4" id="text-9-4-1">


<p>
You need to create an executable script named <code>runvasp.py</code> on your executable path. Here is an example script that works for both serial and parallel versions of VASP. This script is located in <code>jasp/bin</code>.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">!/usr/bin/env python</span>
<span style="color: #cd0000; font-weight: bold;">import</span> os

serial_vasp = <span style="color: #00cd00;">'/home/jkitchin/src/vasp/bin/vasp_serial_intel_mkl'</span>
parallel_vasp = <span style="color: #00cd00;">'/home/jkitchin/src/vasp/bin/vasp_openmpi_intel_mkl'</span>

<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #00cd00;">'PBS_NODEFILE'</span> <span style="color: #cd0000; font-weight: bold;">in</span> os.environ:
    NPROCS = <span style="color: #cd0000; font-weight: bold;">len</span>(open(os.environ[<span style="color: #00cd00;">'PBS_NODEFILE'</span>]).readlines())

    <span style="color: #cd0000; font-weight: bold;">if</span> NPROCS == 1:
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'NPROCS = '</span>,NPROCS
        exitcode = os.system(serial_vasp)
    <span style="color: #cd0000; font-weight: bold;">else:</span>
        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'NPROCS = '</span>,NPROCS
        parcmd = <span style="color: #00cd00;">'mpirun -np %i %s'</span> % (NPROCS,parallel_vasp)
        exitcode = os.system(parcmd)
<span style="color: #cd0000; font-weight: bold;">else:</span>
    exitcode = os.system(serial_vasp)
<span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">end</span>
</pre>


<p>
Then create an environment variable that points to this script. For example in <code>.bashrc</code>:
</p>


<pre class="src src-sh"><span style="color: #cd0000; font-weight: bold;">export</span> <span style="color: #cd00cd;">VASP_SCRIPT</span>=$<span style="color: #cd00cd;">HOME</span>/kitchinpython/jasp/bin/run_vasp.py
</pre>


<p>
<code>jasp</code> expects to find the POTCAR potentials in specific directories. You have two options:
</p><ol>
<li>Install the potentials in a directory and name the potential directories like this:
</li>
</ol>




<pre class="example">my_vasp_potentials
    potpaw
    potpaw_GGA
    potpaw_PBE
</pre>

<p>
The <code>potpaw</code> directory contains the LDA potentials, <code>potpaw_GGA</code> contains PW91 potentials, and <code>potpaw_PBE</code> contains the PBE potentials. Then, in your .bashrc file set an environment variable that points to this directory. For example:
</p>



<pre class="src src-sh"><span style="color: #cd0000; font-weight: bold;">export</span> <span style="color: #cd00cd;">VASP_PP_PATH</span>=$<span style="color: #cd00cd;">HOME</span>/vasp/my_vasp_potentials
</pre>


<p>
If you already have potential directories setup with different names, you can always make symlinks with the names above that point to your directories.
</p>
</div>

</div>

<div id="outline-container-9-4-2" class="outline-4">
<h4 id="sec-9-4-2"><span class="section-number-4">9.4.2</span> Using a special setup</h4>
<div class="outline-text-4" id="text-9-4-2">

<p>VASP provides <a href="http://cms.mpi.univie.ac.at/vasp/vasp/PAW_potentials.html">special setups</a> for some elements. The following guidelines tell you what is in a potential:
</p>
<p>
No extension means the standard potential. The following extensions mean:
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>Meaning of extensions on POTCAR files for special setups.</caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">extension</th><th scope="col" class="left"></th></tr>
</thead>
<tbody>
<tr><td class="left">_h</td><td class="left">means the potential is harder than the standard (i.e. needs a higher cutoff energy)</td></tr>
<tr><td class="left">_s</td><td class="left">means the potential is softer than the standard (i.e. needs a lower cutoff energy)</td></tr>
<tr><td class="left">_sv</td><td class="left"><img src="ltxpng/dft_a289d4f4f2d485ec0de1a0aef57850050e7b0f08.png" alt="$s$"/> and <img src="ltxpng/dft_5e98e1cfb6e4911898c38a891de0db95f9e41518.png" alt="$p$"/> semi-core states are treated as valence states</td></tr>
<tr><td class="left">_pv</td><td class="left"><img src="ltxpng/dft_5e98e1cfb6e4911898c38a891de0db95f9e41518.png" alt="$p$"/> semi-core states are treated as valence states</td></tr>
<tr><td class="left">_d</td><td class="left"><img src="ltxpng/dft_4d33e1e6aecb6d1979140f27643b5062adac5088.png" alt="$d$"/> semi-core states are treated as valence states</td></tr>
</tbody>
</table>


<p>
Here are some links to information in the VASP manual for the setups.
</p>
<ul>
<li><a href="http://cms.mpi.univie.ac.at/vasp/vasp/st_row_elements.html">1st row elements</a>
</li>
<li><a href="http://cms.mpi.univie.ac.at/vasp/vasp/Alkali_alkali_earth_elements_simple_metals.html">Alkali and alkali-earth metals</a>
</li>
<li><a href="http://cms.mpi.univie.ac.at/vasp/vasp/_elements.html">d-elements</a>
</li>
<li><a href="http://cms.mpi.univie.ac.at/vasp/vasp/_elements_including_first_row.html">p-elements</a>
</li>
<li><a href="http://cms.mpi.univie.ac.at/vasp/vasp/_elements_I.html">f-elements</a>
</li>
</ul>

<p>Here we show how to select the O_sv potential in a calculation.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atoms, Atom
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[5, 5, 5], magmom=1)],
             cell=(6, 6, 6))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O_sv'</span>,
          encut=300,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          ispin=2,
          ismear=0,
          sigma=0.001,
          setups={<span style="color: #00cd00;">'O'</span>:<span style="color: #00cd00;">'_sv'</span>}, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">specifies O_sv potential</span>
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'Total energy = {0} eV'</span>.format(atoms.get_potential_energy())
</pre>


<pre class="example">
Total energy = -1578.61345 eV
</pre>


<p>
How do you know you got the right special setup? We can look at the first line of the POTCAR file in the calculation directory to see.
</p>


<pre class="src src-sh">head -n 1 molecules/O_sv/POTCAR
</pre>


<pre class="example">
PAW_PBE O_sv 05Jul2007
</pre>


<p>
This shows we indeed used the O_sv setup.
</p>
</div>

</div>

<div id="outline-container-9-4-3" class="outline-4">
<h4 id="sec-9-4-3"><span class="section-number-4">9.4.3</span> Running jasp in parallel</h4>
<div class="outline-text-4" id="text-9-4-3">

<p>jasp is smart. If you ask for more than one node, it will automatically try to run in parallel.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
JASPRC[<span style="color: #00cd00;">'queue.nodes'</span>]=4
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
atoms = Atoms([Atom(<span style="color: #00cd00;">'O'</span>,[5,5,5],magmom=1)],
             cell=(6,6,6))

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'molecules/O_sv-4nodes'</span>,
          encut=300,
          xc=<span style="color: #00cd00;">'PBE'</span>,
          ispin=2,
          ismear=0,
          sigma=0.001,
          setups={<span style="color: #00cd00;">'O'</span>:<span style="color: #00cd00;">'_sv'</span>}, <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">specifies O_sv potential</span>
          atoms=atoms) <span style="color: #cd0000; font-weight: bold;">as</span> calc:

    <span style="color: #cd0000; font-weight: bold;">print</span> calc.calculate()
</pre>


<pre class="example">
None
</pre>


<p>
How do you know it ran on four nodes?
</p>


<pre class="src src-sh">head molecules/O_sv-4nodes/OUTCAR
</pre>



<pre class="example"> vasp.5.2.12 11Nov11 complex

 executed on             LinuxIFC date 2012.08.31  09:10:10
 running on    4 nodes
 distr:  one band on    1 nodes,    4 groups


--------------------------------------------------------------------------------------------------------


</pre>


</div>

</div>

<div id="outline-container-9-4-4" class="outline-4">
<h4 id="sec-9-4-4"><span class="section-number-4">9.4.4</span> Running multiple instances of jasp in parallel</h4>
<div class="outline-text-4" id="text-9-4-4">

<p><TT>jasp</TT> was designed to enable asynchronous, parallel running processes through a queuing system. This is ideal for submitting large numbers of independent calculations in one script. The design uses exceptions to exit the script if the results are not available for subsequent analysis. The design expects that you run the script often, and the results are analyzed only when they are finally available.
</p>
<p>
Sometimes it is convenient to run a set of calculations and then wait for them to finish so that a second set of calculations that depend on the first results can be run. In this scenario, it is inconvenient to have to rerun your script again after the first set of calculations is done.  The challenge is how to tell the computer to run a set of calculations in parallel, <b>and</b> wait for the calculations to finish. This can be achieved using the <TT>multiprocessing</TT> module in python.
</p>
<p>
The principle idea is to set up the calculations you want to run, and use <TT>multiprocessing</TT> to handle running them and waiting for you. To do this, you must instruct <TT>jasp</TT> to use a "run mode", and construct a script with a function that runs a calculation, and a section that only runs in the "__main__" script.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">import</span> multiprocessing
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">from</span> ase.utils.eos <span style="color: #cd0000; font-weight: bold;">import</span> EquationOfState
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

JASPRC[<span style="color: #00cd00;">'mode'</span>] = <span style="color: #00cd00;">'run'</span>

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this is the function that runs a calculation</span>
<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">do_calculation</span>(calculator):
    <span style="color: #00cd00;">'function to run a calculation through multiprocessing'</span>
    <span style="color: #cd0000; font-weight: bold;">with</span> calculator <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        e = atoms.get_potential_energy()
        v = atoms.get_volume()
    <span style="color: #cd0000; font-weight: bold;">return</span> v, e

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this only runs in the main script, not in processes on other cores</span>
<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">__name__</span> == <span style="color: #00cd00;">'__main__'</span>:
    NCORES = 6  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">number of cores to run processes on</span>

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">setup an atoms object</span>
    a = 3.6
    atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,(0, 0, 0))],
                  cell=0.5 * a*np.array([[1.0, 1.0, 0.0],
                                         [0.0, 1.0, 1.0],
                                         [1.0, 0.0, 1.0]]))
    v0 = atoms.get_volume()

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Step 1</span>
    COUNTER = 0
    calculators = []  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">list of calculators to be run</span>
    factors = [-0.1, 0.05, 0.0, 0.05, 0.1]
    <span style="color: #cd0000; font-weight: bold;">for</span> f <span style="color: #cd0000; font-weight: bold;">in</span> factors:
        newatoms = atoms.copy()
        newatoms.set_volume(v0*(1 + f))
        label = <span style="color: #00cd00;">'bulk/cu-mp/step1-{0}'</span>.format(COUNTER)
        COUNTER += 1

        calc = jasp(label,
                    xc=<span style="color: #00cd00;">'PBE'</span>,
                    encut=350,
                    kpts=(6,6,6),
                    isym=2,
                    atoms=newatoms)

        calculators.append(calc)

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now we set up the Pool of processes</span>
    pool = multiprocessing.Pool(processes=NCORES)

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get the output from running each calculation</span>
    out = pool.map(do_calculation, calculators)
    pool.close()
    pool.join() <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this makes the script wait here until all jobs are done</span>

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now proceed with analysis</span>
    V = [x[0] <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> out]
    E = [x[1] <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> out]

    eos = EquationOfState(V, E)
    v1, e1, B = eos.fit()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'step1: v1 = {v1}'</span>.format(**<span style="color: #cd0000; font-weight: bold;">locals</span>())

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">## ################################################################</span>
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;"># STEP 2, eos around the minimum</span>
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;"># #################################################################</span>
    factors = [-0.06, -0.04, -0.02,
               0.0,
               0.02, 0.04, 0.06]

    calculators = [] <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">reset list</span>
    <span style="color: #cd0000; font-weight: bold;">for</span> f <span style="color: #cd0000; font-weight: bold;">in</span> factors:
        newatoms = atoms.copy()
        newatoms.set_volume(v1*(1 + f))
        label = <span style="color: #00cd00;">'bulk/cu-mp/step2-{0}'</span>.format(COUNTER)
        COUNTER += 1

        calc = jasp(label,
                    xc=<span style="color: #00cd00;">'PBE'</span>,
                    encut=350,
                    kpts=(6,6,6),
                    isym=2,
                    atoms=newatoms)
        calculators.append(calc)

    pool = multiprocessing.Pool(processes=NCORES)

    out = pool.map(do_calculation, calculators)
    pool.close()
    pool.join() <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">wait here for calculations to finish</span>

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">proceed with analysis</span>
    V += [x[0] <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> out]
    E += [x[1] <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> out]

    V = np.array(V)
    E = np.array(E)

    f = np.array(V)/v1

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">only take points within +- 10% of the minimum</span>
    ind = (f &gt;=0.90) &amp; (f &lt;= 1.1)

    eos = EquationOfState(V[ind], E[ind])
    v2, e2, B = eos.fit()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'step2: v2 = {v2}'</span>.format(**<span style="color: #cd0000; font-weight: bold;">locals</span>())
    eos.plot(<span style="color: #00cd00;">'images/cu-mp-eos.png'</span>)


</pre>


<pre class="example">
step1: v1 = 12.0218897111
step2: v2 = 12.0216094217
</pre>



<div class="figure">
<p><img src="./images/cu-mp-eos.png"  alt="./images/cu-mp-eos.png" /></p>
<p>Equation of state for Cu using the multiprocessing module.</p>
</div>


<div class="note">
<p>The first time you run this you will get all the VASP output. The second time you get the smaller output above.
</p>
<p>
Also, I have not figured out how to integrate this method with the queue system. At the moment, the runjasp.py script which ultimately runs VASP will run VASP in parallel, i.e. one process on multiple nodes/cores instead of a single job that runs multiple processes simultaneously on multiple nodes/cores.
</p>
</div>

<p>
Here is an example of running this through the queue. The main variations are you must set several variables in <code>JASPRC</code> that indicate you want to use <TT>multiprocessing</TT>, and you must save the script and submit manually to the queue with matching parameters. This is not 100% satisfying, but it is the best that I have found for now.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">!/usr/bin/env python</span>
<span style="color: #cd0000; font-weight: bold;">import</span> multiprocessing
<span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase <span style="color: #cd0000; font-weight: bold;">import</span> Atom, Atoms
<span style="color: #cd0000; font-weight: bold;">from</span> ase.utils.eos <span style="color: #cd0000; font-weight: bold;">import</span> EquationOfState
<span style="color: #cd0000; font-weight: bold;">import</span> numpy <span style="color: #cd0000; font-weight: bold;">as</span> np

JASPRC[<span style="color: #00cd00;">'mode'</span>] = <span style="color: #00cd00;">'run'</span>
JASPRC[<span style="color: #00cd00;">'queue.nodes'</span>] = 1

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Here we will be able to run three MPI jobs on 2 cores at a time.</span>
JASPRC[<span style="color: #00cd00;">'queue.ppn'</span>] = 6
JASPRC[<span style="color: #00cd00;">'multiprocessing.cores_per_process'</span>] = 2

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">to submit this script, save it as cu-mp.py</span>
<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">qsub -l nodes=1:ppn=6,walltime=10:00:00 cu-mp.py</span>
<span style="color: #cd0000; font-weight: bold;">import</span> os
<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #00cd00;">'PBS_O_WORKDIR'</span> <span style="color: #cd0000; font-weight: bold;">in</span> os.environ:
    os.chdir(os.environ[<span style="color: #00cd00;">'PBS_O_WORKDIR'</span>])

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this is the function that runs a calculation</span>
<span style="color: #cd0000; font-weight: bold;">def</span> <span style="color: #cd0000; font-weight: bold;">do_calculation</span>(calculator):
    <span style="color: #00cd00;">'function to run a calculation through multiprocessing'</span>
    <span style="color: #cd0000; font-weight: bold;">with</span> calculator <span style="color: #cd0000; font-weight: bold;">as</span> calc:
        atoms = calc.get_atoms()
        e = atoms.get_potential_energy()
        v = atoms.get_volume()
    <span style="color: #cd0000; font-weight: bold;">return</span> v, e

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this only runs in the main script, not in processes on other cores</span>
<span style="color: #cd0000; font-weight: bold;">if</span> <span style="color: #cd0000; font-weight: bold;">__name__</span> == <span style="color: #00cd00;">'__main__'</span>:

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">setup an atoms object</span>
    a = 3.6
    atoms = Atoms([Atom(<span style="color: #00cd00;">'Cu'</span>,(0, 0, 0))],
                  cell=0.5 * a*np.array([[1.0, 1.0, 0.0],
                                         [0.0, 1.0, 1.0],
                                         [1.0, 0.0, 1.0]]))
    v0 = atoms.get_volume()

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">Step 1</span>
    COUNTER = 0
    calculators = []  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">list of calculators to be run</span>
    factors = [-0.1, 0.05, 0.0, 0.05, 0.1]
    <span style="color: #cd0000; font-weight: bold;">for</span> f <span style="color: #cd0000; font-weight: bold;">in</span> factors:
        newatoms = atoms.copy()
        newatoms.set_volume(v0*(1 + f))
        label = <span style="color: #00cd00;">'bulk/cu-mp2/step1-{0}'</span>.format(COUNTER)
        COUNTER += 1

        calc = jasp(label,
                    xc=<span style="color: #00cd00;">'PBE'</span>,
                    encut=350,
                    kpts=(6,6,6),
                    isym=2,
                    debug=logging.DEBUG,
                    atoms=newatoms)

        calculators.append(calc)

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now we set up the Pool of processes</span>
    pool = multiprocessing.Pool(processes=3) <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">ask for 6 cores but run MPI on 2 cores</span>

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">get the output from running each calculation</span>
    out = pool.map(do_calculation, calculators)
    pool.close()
    pool.join() <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this makes the script wait here until all jobs are done</span>

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now proceed with analysis</span>
    V = [x[0] <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> out]
    E = [x[1] <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> out]

    eos = EquationOfState(V, E)
    v1, e1, B = eos.fit()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'step1: v1 = {v1}'</span>.format(**<span style="color: #cd0000; font-weight: bold;">locals</span>())

    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;">## ################################################################</span>
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;"># STEP 2, eos around the minimum</span>
    <span style="color: #cd0000; font-weight: bold;">#</span><span style="color: #cd0000; font-weight: bold;"># #################################################################</span>
    factors = [-0.06, -0.04, -0.02,
               0.0,
               0.02, 0.04, 0.06]

    calculators = [] <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">reset list</span>
    <span style="color: #cd0000; font-weight: bold;">for</span> f <span style="color: #cd0000; font-weight: bold;">in</span> factors:
        newatoms = atoms.copy()
        newatoms.set_volume(v1*(1 + f))
        label = <span style="color: #00cd00;">'bulk/cu-mp2/step2-{0}'</span>.format(COUNTER)
        COUNTER += 1

        calc = jasp(label,
                    xc=<span style="color: #00cd00;">'PBE'</span>,
                    encut=350,
                    kpts=(6,6,6),
                    isym=2,
                    debug=logging.DEBUG,
                    atoms=newatoms)
        calculators.append(calc)

    pool = multiprocessing.Pool(processes=3)

    out = pool.map(do_calculation, calculators)
    pool.close()
    pool.join() <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">wait here for calculations to finish</span>

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">proceed with analysis</span>
    V += [x[0] <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> out]
    E += [x[1] <span style="color: #cd0000; font-weight: bold;">for</span> x <span style="color: #cd0000; font-weight: bold;">in</span> out]

    V = np.array(V)
    E = np.array(E)

    f = np.array(V)/v1

    <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">only take points within +- 10% of the minimum</span>
    ind = (f &gt;=0.90) &amp; (f &lt;= 1.1)

    eos = EquationOfState(V[ind], E[ind])
    v2, e2, B = eos.fit()
    <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'step2: v2 = {v2}'</span>.format(**<span style="color: #cd0000; font-weight: bold;">locals</span>())
    eos.plot(<span style="color: #00cd00;">'images/cu-mp2-eos.png'</span>,show=<span style="color: #cd0000; font-weight: bold;">True</span>)
</pre>


<pre class="example">
step1: v1 = 12.0218897111
step2: v2 = 12.0216189798
</pre>



<div class="figure">
<p><img src="./images/cu-mp2-eos.png"  alt="./images/cu-mp2-eos.png" /></p>
<p>Second view of a Cu equation of state computed with multiprocessing.</p>
</div>

</div>

</div>

<div id="outline-container-9-4-5" class="outline-4">
<h4 id="sec-9-4-5"><span class="section-number-4">9.4.5</span> Exporting data json, xml, python, sqlite</h4>
<div class="outline-text-4" id="text-9-4-5">

<p>jasp has some capability for representing a calculation result in an archival format. The formats currently under development are json, xml, python and sqlite. The main point of these methods is to make it easy to create archive files that are machine readable for supplementary information in publications. These are under development.
</p>

</div>

<div id="outline-container-9-4-5-1" class="outline-5">
<h5 id="sec-9-4-5-1"><span class="section-number-5">9.4.5.1</span> python</h5>
<div class="outline-text-5" id="text-9-4-5-1">

<p>This is code that should reconstruct the python code needed to run a particular calculation. There are some limitations, e.g. it does not currently get magnetic moments on the atoms.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> calc.python
</pre>



<pre class="example">from numpy import array
from ase import Atom, Atoms
from jasp import *

atoms = Atoms([Atom('Cu',[0.0, 0.0, 0.0]),
               cell = [[1.818, 0.0, 1.818],
                       [1.818, 1.818, 0.0],
                       [0.0, 1.818, 1.818]])

with jasp('bulk/alloy/cu',
          nbands = 9,
          nsw = 10,
          ibrion = 2,
          isif = 4,
          encut = 350.0,
          prec = 'Normal',
          kpts = array([13, 13, 13]),
          reciprocal = False,
          xc = 'PBE',
          txt = '-',
          gamma = False,
          atoms=atoms) as calc:
    # your code here

</pre>


</div>

</div>

<div id="outline-container-9-4-5-2" class="outline-5">
<h5 id="sec-9-4-5-2"><span class="section-number-5">9.4.5.2</span> json</h5>
<div class="outline-text-5" id="text-9-4-5-2">





<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> calc.pretty_json
</pre>



<pre class="example">{
    "INCAR": {
        "addgrid": null,
        "aexx": null,
        "aggac": null,
        "aggax": null,
        "aldac": null,
        "algo": null,
        "amin": null,
        "amix": null,
        "amix_mag": null,
        "bmix": null,
        "bmix_mag": null,
        "ddr": null,
        "deper": null,
        "dfnmax": null,
        "dfnmin": null,
        "dipol": null,
        "drotmax": null,
        "ebreak": null,
        "ediff": null,
        "ediffg": null,
        "eint": null,
        "emax": null,
        "emin": null,
        "enaug": null,
        "encut": 350.0,
        "encutfock": null,
        "encutgw": null,
        "falpha": null,
        "falphadec": null,
        "fdstep": null,
        "ferdo": null,
        "ferwe": null,
        "fnmin": null,
        "ftimedec": null,
        "ftimeinc": null,
        "ftimemax": null,
        "gga": null,
        "hfscreen": null,
        "ialgo": null,
        "iband": null,
        "ibrion": 2,
        "ichain": null,
        "icharg": null,
        "idipol": null,
        "images": null,
        "iniwav": null,
        "invcurve": null,
        "iopt": null,
        "isif": 4,
        "ismear": null,
        "ispin": null,
        "istart": null,
        "isym": null,
        "iwavpr": null,
        "jacobian": null,
        "kgamma": null,
        "kpuse": null,
        "kspacing": null,
        "laechg": null,
        "lasph": null,
        "lasync": null,
        "lbfgsmem": null,
        "lcharg": null,
        "lclimb": null,
        "lcorr": null,
        "ldau": null,
        "ldau_luj": null,
        "ldauj": null,
        "ldaul": null,
        "ldauprint": null,
        "ldautype": null,
        "ldauu": null,
        "ldiag": null,
        "ldipol": null,
        "ldneb": null,
        "lelf": null,
        "lepsilon": null,
        "lglobal": null,
        "lhfcalc": null,
        "llineopt": null,
        "lmaxmix": null,
        "lnebcell": null,
        "loptics": null,
        "lorbit": null,
        "lpard": null,
        "lplane": null,
        "lscalapack": null,
        "lscalu": null,
        "lsepb": null,
        "lsepk": null,
        "ltangentold": null,
        "lthomas": null,
        "luse_vdw": null,
        "lvdw": null,
        "lvhar": null,
        "lvtot": null,
        "lwave": null,
        "magmom": null,
        "maxmix": null,
        "maxmove": null,
        "nbands": 9,
        "nblk": null,
        "nbmod": null,
        "nelect": null,
        "nelm": null,
        "nelmdl": null,
        "nelmin": null,
        "nfree": null,
        "ngx": null,
        "ngxf": null,
        "ngy": null,
        "ngyf": null,
        "ngz": null,
        "ngzf": null,
        "nkred": null,
        "nkredx": null,
        "nkredy": null,
        "nkredz": null,
        "nomega": null,
        "nomegar": null,
        "npar": null,
        "nsim": null,
        "nsw": 10,
        "nupdown": null,
        "nwrite": null,
        "param1": null,
        "param2": null,
        "pomass": null,
        "potim": null,
        "prec": "Normal",
        "precfock": null,
        "ropt": null,
        "rwigs": null,
        "sdalpha": null,
        "sdr": null,
        "sigma": null,
        "smass": null,
        "snl": null,
        "spring": null,
        "stol": null,
        "symprec": null,
        "system": null,
        "tebeg": null,
        "teend": null,
        "time": null,
        "timestep": null,
        "vdwgr": null,
        "vdwrn": null,
        "voskown": null,
        "weimin": null,
        "zab_vdw": null,
        "zval": null
    },
    "atoms": {
        "cell": [
            [
                1.818,
                0.0,
                1.818
            ],
            [
                1.818,
                1.818,
                0.0
            ],
            [
                0.0,
                1.818,
                1.818
            ]
        ],
        "pbc": [
            true,
            true,
            true
        ],
        "positions": [
            [
                0.0,
                0.0,
                0.0
            ]
        ],
        "symbols": [
            "Cu"
        ],
        "tags": [
            0
        ]
    },
    "input": {
        "gamma": false,
        "kpts": [
            13,
            13,
            13
        ],
        "kpts_nintersections": null,
        "reciprocal": false,
        "setups": null,
        "txt": "-",
        "xc": "PBE"
    }
}
</pre>


</div>

</div>

<div id="outline-container-9-4-5-3" class="outline-5">
<h5 id="sec-9-4-5-3"><span class="section-number-5">9.4.5.3</span> xml</h5>
<div class="outline-text-5" id="text-9-4-5-3">

<p>This relies on the pyxser module.
</p>


<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp <span style="color: #cd0000; font-weight: bold;">import</span> *

<span style="color: #cd0000; font-weight: bold;">with</span> jasp(<span style="color: #00cd00;">'bulk/alloy/cu'</span>) <span style="color: #cd0000; font-weight: bold;">as</span> calc:
    <span style="color: #cd0000; font-weight: bold;">print</span> calc.xml
</pre>



<pre class="example">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;pyxs:obj xmlns:pyxs="http://projects.coder.cl/pyxser/model/" version="1.0" type="vasp" module="jasp.serialize" objid="id488763344"&gt;
  &lt;pyxs:col type="dict" name="d"&gt;
    &lt;pyxs:col type="dict" name="INCAR"&gt;
      &lt;pyxs:prop type="str" name="prec"&gt;Normal&lt;/pyxs:prop&gt;
      &lt;pyxs:prop type="float" name="encut"&gt;350.0&lt;/pyxs:prop&gt;
      &lt;pyxs:prop type="int" name="nbands"&gt;9&lt;/pyxs:prop&gt;
      &lt;pyxs:prop type="int" name="isif"&gt;4&lt;/pyxs:prop&gt;
      &lt;pyxs:prop type="int" name="nsw"&gt;10&lt;/pyxs:prop&gt;
      &lt;pyxs:prop type="int" name="ibrion"&gt;2&lt;/pyxs:prop&gt;
    &lt;/pyxs:col&gt;
    &lt;pyxs:col type="dict" name="input"&gt;
      &lt;pyxs:col type="list" name="kpts"&gt;
        &lt;pyxs:prop type="int" name="kpts"&gt;13&lt;/pyxs:prop&gt;
        &lt;pyxs:prop type="int" name="kpts"&gt;13&lt;/pyxs:prop&gt;
        &lt;pyxs:prop type="int" name="kpts"&gt;13&lt;/pyxs:prop&gt;
      &lt;/pyxs:col&gt;
      &lt;pyxs:prop type="bool" name="reciprocal"&gt;False&lt;/pyxs:prop&gt;
      &lt;pyxs:prop type="str" name="xc"&gt;PBE&lt;/pyxs:prop&gt;
      &lt;pyxs:prop type="str" name="txt"&gt;-&lt;/pyxs:prop&gt;
      &lt;pyxs:prop type="bool" name="gamma"&gt;False&lt;/pyxs:prop&gt;
    &lt;/pyxs:col&gt;
    &lt;pyxs:col type="dict" name="atoms"&gt;
      &lt;pyxs:col type="list" name="cell"&gt;
        &lt;pyxs:col type="list" name="cell"&gt;
          &lt;pyxs:prop type="float" name="cell"&gt;1.818&lt;/pyxs:prop&gt;
          &lt;pyxs:prop type="float" name="cell"&gt;0.0&lt;/pyxs:prop&gt;
          &lt;pyxs:prop type="float" name="cell"&gt;1.818&lt;/pyxs:prop&gt;
        &lt;/pyxs:col&gt;
        &lt;pyxs:col type="list" name="cell"&gt;
          &lt;pyxs:prop type="float" name="cell"&gt;1.818&lt;/pyxs:prop&gt;
          &lt;pyxs:prop type="float" name="cell"&gt;1.818&lt;/pyxs:prop&gt;
          &lt;pyxs:prop type="float" name="cell"&gt;0.0&lt;/pyxs:prop&gt;
        &lt;/pyxs:col&gt;
        &lt;pyxs:col type="list" name="cell"&gt;
          &lt;pyxs:prop type="float" name="cell"&gt;0.0&lt;/pyxs:prop&gt;
          &lt;pyxs:prop type="float" name="cell"&gt;1.818&lt;/pyxs:prop&gt;
          &lt;pyxs:prop type="float" name="cell"&gt;1.818&lt;/pyxs:prop&gt;
        &lt;/pyxs:col&gt;
      &lt;/pyxs:col&gt;
      &lt;pyxs:col type="list" name="symbols"&gt;
        &lt;pyxs:prop type="str" name="symbols"&gt;Cu&lt;/pyxs:prop&gt;
      &lt;/pyxs:col&gt;
      &lt;pyxs:col type="list" name="pbc"&gt;
        &lt;pyxs:prop type="bool" name="pbc"&gt;True&lt;/pyxs:prop&gt;
        &lt;pyxs:prop type="bool" name="pbc"&gt;True&lt;/pyxs:prop&gt;
        &lt;pyxs:prop type="bool" name="pbc"&gt;True&lt;/pyxs:prop&gt;
      &lt;/pyxs:col&gt;
      &lt;pyxs:col type="list" name="positions"&gt;
        &lt;pyxs:col type="list" name="positions"&gt;
          &lt;pyxs:prop type="float" name="positions"&gt;0.0&lt;/pyxs:prop&gt;
          &lt;pyxs:prop type="float" name="positions"&gt;0.0&lt;/pyxs:prop&gt;
          &lt;pyxs:prop type="float" name="positions"&gt;0.0&lt;/pyxs:prop&gt;
        &lt;/pyxs:col&gt;
      &lt;/pyxs:col&gt;
    &lt;/pyxs:col&gt;
  &lt;/pyxs:col&gt;
&lt;/pyxs:obj&gt;

</pre>


</div>
</div>

</div>

<div id="outline-container-9-4-6" class="outline-4">
<h4 id="sec-9-4-6"><span class="section-number-4">9.4.6</span> Recommended values for ENCUT and valence electrons for different POTCAR files</h4>
<div class="outline-text-4" id="text-9-4-6">

<p>The <a href=http://cms.mpi.univie.ac.at/wiki/index.php/ENCUT>ENCUT</a> tag and <a href=http://cms.mpi.univie.ac.at/wiki/index.php/PREC>PREC</a> tag affect the accuracy/convergence of your calculations.
</p>



<pre class="src src-python"><span style="color: #cd0000; font-weight: bold;">from</span> jasp.POTCAR <span style="color: #cd0000; font-weight: bold;">import</span> *
<span style="color: #cd0000; font-weight: bold;">from</span> ase.data <span style="color: #cd0000; font-weight: bold;">import</span> chemical_symbols
<span style="color: #cd0000; font-weight: bold;">import</span> glob, os

<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+tblname: POTCAR'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+caption: Parameters for POTPAW_PBE POTCAR files.'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'#+ATTR_LaTeX: longtable'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'| POTCAR | ENMIN | ENMAX | prec=high (eV) | # val. elect. |'</span>
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|-'</span>

chemical_symbols.sort()
<span style="color: #cd0000; font-weight: bold;">for</span> symbol <span style="color: #cd0000; font-weight: bold;">in</span> chemical_symbols:

    potcars = glob.glob(<span style="color: #00cd00;">'{0}/POTPAW_PBE/{1}*/POTCAR'</span>.format(os.environ[<span style="color: #00cd00;">'VASP_PP_PATH'</span>],
                                                     symbol))

    <span style="color: #cd0000; font-weight: bold;">for</span> potcar <span style="color: #cd0000; font-weight: bold;">in</span> potcars:

        POTCAR = os.path.relpath(potcar,
                                 os.environ[<span style="color: #00cd00;">'VASP_PP_PATH'</span>]+<span style="color: #00cd00;">'/POTPAW_PBE'</span>)[:-7]
        ENMIN = get_ENMIN(potcar)
        ENMAX = get_ENMAX(potcar)
        HIGH  = 1.3*ENMAX
        ZVAL  = get_ZVAL(potcar)

        <span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'|{POTCAR:30s}|{ENMIN}|{ENMAX}|{HIGH:1.3f}|{ZVAL}|'</span>.format(**<span style="color: #cd0000; font-weight: bold;">locals</span>())
</pre>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption>Parameters for POTPAW_PBE POTCAR files.</caption>
<colgroup><col class="left" /><col class="right" /><col class="right" /><col class="right" /><col class="right" />
</colgroup>
<thead>
<tr><th scope="col" class="left">POTCAR</th><th scope="col" class="right">ENMIN</th><th scope="col" class="right">ENMAX</th><th scope="col" class="right">prec=high (eV)</th><th scope="col" class="right"># val. elect.</th></tr>
</thead>
<tbody>
<tr><td class="left">Ac</td><td class="right">129.178</td><td class="right">172.237</td><td class="right">223.908</td><td class="right">11.0</td></tr>
<tr><td class="left">Ag_new</td><td class="right">187.383</td><td class="right">249.844</td><td class="right">324.797</td><td class="right">11.0</td></tr>
<tr><td class="left">Ag</td><td class="right">187.385</td><td class="right">249.846</td><td class="right">324.800</td><td class="right">11.0</td></tr>
<tr><td class="left">Ag_pv</td><td class="right">223.399</td><td class="right">297.865</td><td class="right">387.225</td><td class="right">17.0</td></tr>
<tr><td class="left">Al</td><td class="right">180.225</td><td class="right">240.3</td><td class="right">312.390</td><td class="right">3.0</td></tr>
<tr><td class="left">Am</td><td class="right">191.906</td><td class="right">255.875</td><td class="right">332.637</td><td class="right">17.0</td></tr>
<tr><td class="left">Ar</td><td class="right">199.795</td><td class="right">266.393</td><td class="right">346.311</td><td class="right">8.0</td></tr>
<tr><td class="left">As_d_GW</td><td class="right">259.629</td><td class="right">346.172</td><td class="right">450.024</td><td class="right">15.0</td></tr>
<tr><td class="left">As_d</td><td class="right">216.488</td><td class="right">288.651</td><td class="right">375.246</td><td class="right">15.0</td></tr>
<tr><td class="left">As_GW</td><td class="right">156.526</td><td class="right">208.702</td><td class="right">271.313</td><td class="right">5.0</td></tr>
<tr><td class="left">As</td><td class="right">156.51</td><td class="right">208.68</td><td class="right">271.284</td><td class="right">5.0</td></tr>
<tr><td class="left">At_d</td><td class="right">199.688</td><td class="right">266.251</td><td class="right">346.126</td><td class="right">17.0</td></tr>
<tr><td class="left">At</td><td class="right">121.073</td><td class="right">161.43</td><td class="right">209.859</td><td class="right">7.0</td></tr>
<tr><td class="left">Au_new</td><td class="right">172.457</td><td class="right">229.943</td><td class="right">298.926</td><td class="right">11.0</td></tr>
<tr><td class="left">Au</td><td class="right">172.461</td><td class="right">229.948</td><td class="right">298.932</td><td class="right">11.0</td></tr>
<tr><td class="left">Ba_sv</td><td class="right">140.408</td><td class="right">187.21</td><td class="right">243.373</td><td class="right">10.0</td></tr>
<tr><td class="left">Be</td><td class="right">185.658</td><td class="right">247.544</td><td class="right">321.807</td><td class="right">2.0</td></tr>
<tr><td class="left">Be_sv</td><td class="right">231.563</td><td class="right">308.75</td><td class="right">401.375</td><td class="right">4.0</td></tr>
<tr><td class="left">B_h</td><td class="right">500.0</td><td class="right">700.0</td><td class="right">910.000</td><td class="right">3.0</td></tr>
<tr><td class="left">Bi_d</td><td class="right">182.138</td><td class="right">242.851</td><td class="right">315.706</td><td class="right">15.0</td></tr>
<tr><td class="left">Bi</td><td class="right">78.777</td><td class="right">105.037</td><td class="right">136.548</td><td class="right">5.0</td></tr>
<tr><td class="left">Bi_pv</td><td class="right">231.89</td><td class="right">309.187</td><td class="right">401.943</td><td class="right">21.0</td></tr>
<tr><td class="left">B</td><td class="right">238.954</td><td class="right">318.606</td><td class="right">414.188</td><td class="right">3.0</td></tr>
<tr><td class="left">Br</td><td class="right">162.198</td><td class="right">216.264</td><td class="right">281.143</td><td class="right">7.0</td></tr>
<tr><td class="left">B_s</td><td class="right">201.934</td><td class="right">269.245</td><td class="right">350.019</td><td class="right">3.0</td></tr>
<tr><td class="left">Ba_sv</td><td class="right">140.408</td><td class="right">187.21</td><td class="right">243.373</td><td class="right">10.0</td></tr>
<tr><td class="left">Be</td><td class="right">185.658</td><td class="right">247.544</td><td class="right">321.807</td><td class="right">2.0</td></tr>
<tr><td class="left">Be_sv</td><td class="right">231.563</td><td class="right">308.75</td><td class="right">401.375</td><td class="right">4.0</td></tr>
<tr><td class="left">Bi_d</td><td class="right">182.138</td><td class="right">242.851</td><td class="right">315.706</td><td class="right">15.0</td></tr>
<tr><td class="left">Bi</td><td class="right">78.777</td><td class="right">105.037</td><td class="right">136.548</td><td class="right">5.0</td></tr>
<tr><td class="left">Bi_pv</td><td class="right">231.89</td><td class="right">309.187</td><td class="right">401.943</td><td class="right">21.0</td></tr>
<tr><td class="left">Br</td><td class="right">162.198</td><td class="right">216.264</td><td class="right">281.143</td><td class="right">7.0</td></tr>
<tr><td class="left">Ca</td><td class="right">77.067</td><td class="right">102.755</td><td class="right">133.582</td><td class="right">2.0</td></tr>
<tr><td class="left">Ca_pv</td><td class="right">89.665</td><td class="right">119.554</td><td class="right">155.420</td><td class="right">8.0</td></tr>
<tr><td class="left">Ca_sv</td><td class="right">199.939</td><td class="right">266.586</td><td class="right">346.562</td><td class="right">10.0</td></tr>
<tr><td class="left">C_d</td><td class="right">310.494</td><td class="right">413.992</td><td class="right">538.190</td><td class="right">4.0</td></tr>
<tr><td class="left">Cd</td><td class="right">205.757</td><td class="right">274.342</td><td class="right">356.645</td><td class="right">12.0</td></tr>
<tr><td class="left">Ce_3</td><td class="right">135.964</td><td class="right">181.286</td><td class="right">235.672</td><td class="right">11.0</td></tr>
<tr><td class="left">Ce_h</td><td class="right">224.925</td><td class="right">299.9</td><td class="right">389.870</td><td class="right">12.0</td></tr>
<tr><td class="left">Ce</td><td class="right">204.781</td><td class="right">273.042</td><td class="right">354.955</td><td class="right">12.0</td></tr>
<tr><td class="left">C_GW</td><td class="right">310.494</td><td class="right">413.992</td><td class="right">538.190</td><td class="right">4.0</td></tr>
<tr><td class="left">C_h_nr</td><td class="right">556.263</td><td class="right">741.684</td><td class="right">964.189</td><td class="right">4.0</td></tr>
<tr><td class="left">C_h</td><td class="right">500.0</td><td class="right">700.0</td><td class="right">910.000</td><td class="right">4.0</td></tr>
<tr><td class="left">Cl_h</td><td class="right">306.852</td><td class="right">409.136</td><td class="right">531.877</td><td class="right">7.0</td></tr>
<tr><td class="left">Cl</td><td class="right">196.854</td><td class="right">280.0</td><td class="right">364.000</td><td class="right">7.0</td></tr>
<tr><td class="left">Co_new</td><td class="right">200.976</td><td class="right">267.968</td><td class="right">348.358</td><td class="right">9.0</td></tr>
<tr><td class="left">Co</td><td class="right">200.977</td><td class="right">267.969</td><td class="right">348.360</td><td class="right">9.0</td></tr>
<tr><td class="left">Co_sv</td><td class="right">292.771</td><td class="right">390.362</td><td class="right">507.471</td><td class="right">17.0</td></tr>
<tr><td class="left">C</td><td class="right">300.0</td><td class="right">400.0</td><td class="right">520.000</td><td class="right">4.0</td></tr>
<tr><td class="left">Cr</td><td class="right">170.311</td><td class="right">227.082</td><td class="right">295.207</td><td class="right">6.0</td></tr>
<tr><td class="left">Cr_pv_new</td><td class="right">199.261</td><td class="right">265.681</td><td class="right">345.385</td><td class="right">12.0</td></tr>
<tr><td class="left">Cr_pv</td><td class="right">199.262</td><td class="right">265.683</td><td class="right">345.388</td><td class="right">12.0</td></tr>
<tr><td class="left">Cr_sv_new</td><td class="right">296.603</td><td class="right">395.471</td><td class="right">514.112</td><td class="right">14.0</td></tr>
<tr><td class="left">Cr_sv</td><td class="right">296.603</td><td class="right">395.471</td><td class="right">514.112</td><td class="right">14.0</td></tr>
<tr><td class="left">C_s</td><td class="right">205.426</td><td class="right">273.901</td><td class="right">356.071</td><td class="right">4.0</td></tr>
<tr><td class="left">Cs_sv</td><td class="right">165.238</td><td class="right">220.318</td><td class="right">286.413</td><td class="right">9.0</td></tr>
<tr><td class="left">Cu_f</td><td class="right">221.585</td><td class="right">295.446</td><td class="right">384.080</td><td class="right">11.0</td></tr>
<tr><td class="left">Cu_new</td><td class="right">221.585</td><td class="right">295.446</td><td class="right">384.080</td><td class="right">11.0</td></tr>
<tr><td class="left">Cu</td><td class="right">204.91</td><td class="right">273.214</td><td class="right">355.178</td><td class="right">11.0</td></tr>
<tr><td class="left">Cu_pvf</td><td class="right">276.486</td><td class="right">368.648</td><td class="right">479.242</td><td class="right">17.0</td></tr>
<tr><td class="left">Cu_pv</td><td class="right">276.454</td><td class="right">368.605</td><td class="right">479.187</td><td class="right">17.0</td></tr>
<tr><td class="left">Ca</td><td class="right">77.067</td><td class="right">102.755</td><td class="right">133.582</td><td class="right">2.0</td></tr>
<tr><td class="left">Ca_pv</td><td class="right">89.665</td><td class="right">119.554</td><td class="right">155.420</td><td class="right">8.0</td></tr>
<tr><td class="left">Ca_sv</td><td class="right">199.939</td><td class="right">266.586</td><td class="right">346.562</td><td class="right">10.0</td></tr>
<tr><td class="left">Cd</td><td class="right">205.757</td><td class="right">274.342</td><td class="right">356.645</td><td class="right">12.0</td></tr>
<tr><td class="left">Ce_3</td><td class="right">135.964</td><td class="right">181.286</td><td class="right">235.672</td><td class="right">11.0</td></tr>
<tr><td class="left">Ce_h</td><td class="right">224.925</td><td class="right">299.9</td><td class="right">389.870</td><td class="right">12.0</td></tr>
<tr><td class="left">Ce</td><td class="right">204.781</td><td class="right">273.042</td><td class="right">354.955</td><td class="right">12.0</td></tr>
<tr><td class="left">Cl_h</td><td class="right">306.852</td><td class="right">409.136</td><td class="right">531.877</td><td class="right">7.0</td></tr>
<tr><td class="left">Cl</td><td class="right">196.854</td><td class="right">280.0</td><td class="right">364.000</td><td class="right">7.0</td></tr>
<tr><td class="left">Co_new</td><td class="right">200.976</td><td class="right">267.968</td><td class="right">348.358</td><td class="right">9.0</td></tr>
<tr><td class="left">Co</td><td class="right">200.977</td><td class="right">267.969</td><td class="right">348.360</td><td class="right">9.0</td></tr>
<tr><td class="left">Co_sv</td><td class="right">292.771</td><td class="right">390.362</td><td class="right">507.471</td><td class="right">17.0</td></tr>
<tr><td class="left">Cr</td><td class="right">170.311</td><td class="right">227.082</td><td class="right">295.207</td><td class="right">6.0</td></tr>
<tr><td class="left">Cr_pv_new</td><td class="right">199.261</td><td class="right">265.681</td><td class="right">345.385</td><td class="right">12.0</td></tr>
<tr><td class="left">Cr_pv</td><td class="right">199.262</td><td class="right">265.683</td><td class="right">345.388</td><td class="right">12.0</td></tr>
<tr><td class="left">Cr_sv_new</td><td class="right">296.603</td><td class="right">395.471</td><td class="right">514.112</td><td class="right">14.0</td></tr>
<tr><td class="left">Cr_sv</td><td class="right">296.603</td><td class="right">395.471</td><td class="right">514.112</td><td class="right">14.0</td></tr>
<tr><td class="left">Cs_sv</td><td class="right">165.238</td><td class="right">220.318</td><td class="right">286.413</td><td class="right">9.0</td></tr>
<tr><td class="left">Cu_f</td><td class="right">221.585</td><td class="right">295.446</td><td class="right">384.080</td><td class="right">11.0</td></tr>
<tr><td class="left">Cu_new</td><td class="right">221.585</td><td class="right">295.446</td><td class="right">384.080</td><td class="right">11.0</td></tr>
<tr><td class="left">Cu</td><td class="right">204.91</td><td class="right">273.214</td><td class="right">355.178</td><td class="right">11.0</td></tr>
<tr><td class="left">Cu_pvf</td><td class="right">276.486</td><td class="right">368.648</td><td class="right">479.242</td><td class="right">17.0</td></tr>
<tr><td class="left">Cu_pv</td><td class="right">276.454</td><td class="right">368.605</td><td class="right">479.187</td><td class="right">17.0</td></tr>
<tr><td class="left">Dy_3</td><td class="right">116.797</td><td class="right">155.729</td><td class="right">202.448</td><td class="right">9.0</td></tr>
<tr><td class="left">Dy</td><td class="right">191.601</td><td class="right">255.467</td><td class="right">332.107</td><td class="right">20.0</td></tr>
<tr><td class="left">Er_2</td><td class="right">89.813</td><td class="right">119.75</td><td class="right">155.675</td><td class="right">8.0</td></tr>
<tr><td class="left">Er_3</td><td class="right">116.29</td><td class="right">155.053</td><td class="right">201.569</td><td class="right">9.0</td></tr>
<tr><td class="left">Er</td><td class="right">223.587</td><td class="right">298.116</td><td class="right">387.551</td><td class="right">22.0</td></tr>
<tr><td class="left">Eu_2</td><td class="right">74.478</td><td class="right">99.304</td><td class="right">129.095</td><td class="right">8.0</td></tr>
<tr><td class="left">Eu_3</td><td class="right">96.793</td><td class="right">129.057</td><td class="right">167.774</td><td class="right">9.0</td></tr>
<tr><td class="left">Eu_GW</td><td class="right">452.441</td><td class="right">603.254</td><td class="right">784.230</td><td class="right">17.0</td></tr>
<tr><td class="left">Eu</td><td class="right">187.251</td><td class="right">249.668</td><td class="right">324.568</td><td class="right">17.0</td></tr>
<tr><td class="left">F_d_GW</td><td class="right">365.773</td><td class="right">487.698</td><td class="right">634.007</td><td class="right">7.0</td></tr>
<tr><td class="left">Fe</td><td class="right">200.912</td><td class="right">267.883</td><td class="right">348.248</td><td class="right">8.0</td></tr>
<tr><td class="left">Fe_pv_new</td><td class="right">219.928</td><td class="right">293.238</td><td class="right">381.209</td><td class="right">14.0</td></tr>
<tr><td class="left">Fe_pv</td><td class="right">219.929</td><td class="right">293.238</td><td class="right">381.209</td><td class="right">14.0</td></tr>
<tr><td class="left">Fe_sv_h</td><td class="right">410.523</td><td class="right">547.365</td><td class="right">711.575</td><td class="right">16.0</td></tr>
<tr><td class="left">Fe_sv</td><td class="right">292.918</td><td class="right">390.558</td><td class="right">507.725</td><td class="right">16.0</td></tr>
<tr><td class="left">F_h</td><td class="right">500.0</td><td class="right">700.0</td><td class="right">910.000</td><td class="right">7.0</td></tr>
<tr><td class="left">F</td><td class="right">300.0</td><td class="right">400.0</td><td class="right">520.000</td><td class="right">7.0</td></tr>
<tr><td class="left">Fr_sv</td><td class="right">160.905</td><td class="right">214.54</td><td class="right">278.902</td><td class="right">9.0</td></tr>
<tr><td class="left">F_s</td><td class="right">217.369</td><td class="right">289.825</td><td class="right">376.772</td><td class="right">7.0</td></tr>
<tr><td class="left">Fe</td><td class="right">200.912</td><td class="right">267.883</td><td class="right">348.248</td><td class="right">8.0</td></tr>
<tr><td class="left">Fe_pv_new</td><td class="right">219.928</td><td class="right">293.238</td><td class="right">381.209</td><td class="right">14.0</td></tr>
<tr><td class="left">Fe_pv</td><td class="right">219.929</td><td class="right">293.238</td><td class="right">381.209</td><td class="right">14.0</td></tr>
<tr><td class="left">Fe_sv_h</td><td class="right">410.523</td><td class="right">547.365</td><td class="right">711.575</td><td class="right">16.0</td></tr>
<tr><td class="left">Fe_sv</td><td class="right">292.918</td><td class="right">390.558</td><td class="right">507.725</td><td class="right">16.0</td></tr>
<tr><td class="left">Fr_sv</td><td class="right">160.905</td><td class="right">214.54</td><td class="right">278.902</td><td class="right">9.0</td></tr>
<tr><td class="left">Ga_d_GW</td><td class="right">277.386</td><td class="right">369.848</td><td class="right">480.802</td><td class="right">13.0</td></tr>
<tr><td class="left">Ga_d</td><td class="right">212.022</td><td class="right">282.697</td><td class="right">367.506</td><td class="right">13.0</td></tr>
<tr><td class="left">Ga_h</td><td class="right">303.451</td><td class="right">404.601</td><td class="right">525.981</td><td class="right">13.0</td></tr>
<tr><td class="left">Ga</td><td class="right">101.009</td><td class="right">134.678</td><td class="right">175.081</td><td class="right">3.0</td></tr>
<tr><td class="left">Ga_s</td><td class="right">62.877</td><td class="right">83.836</td><td class="right">108.987</td><td class="right">3.0</td></tr>
<tr><td class="left">Ga_sv_GW</td><td class="right">377.564</td><td class="right">503.418</td><td class="right">654.443</td><td class="right">21.0</td></tr>
<tr><td class="left">Gd_3</td><td class="right">115.761</td><td class="right">154.348</td><td class="right">200.652</td><td class="right">9.0</td></tr>
<tr><td class="left">Gd</td><td class="right">192.354</td><td class="right">256.472</td><td class="right">333.414</td><td class="right">18.0</td></tr>
<tr><td class="left">Ge_d3</td><td class="right">169.58</td><td class="right">226.106</td><td class="right">293.938</td><td class="right">14.0</td></tr>
<tr><td class="left">Ge_d_GW2</td><td class="right">254.348</td><td class="right">339.13</td><td class="right">440.869</td><td class="right">14.0</td></tr>
<tr><td class="left">Ge_d_GW</td><td class="right">232.72</td><td class="right">310.294</td><td class="right">403.382</td><td class="right">14.0</td></tr>
<tr><td class="left">Ge_d_GW_ref</td><td class="right">429.008</td><td class="right">572.01</td><td class="right">743.613</td><td class="right">14.0</td></tr>
<tr><td class="left">Ge_d</td><td class="right">232.72</td><td class="right">310.294</td><td class="right">403.382</td><td class="right">14.0</td></tr>
<tr><td class="left">Ge_h</td><td class="right">307.818</td><td class="right">410.425</td><td class="right">533.553</td><td class="right">14.0</td></tr>
<tr><td class="left">Ge</td><td class="right">130.355</td><td class="right">173.807</td><td class="right">225.949</td><td class="right">4.0</td></tr>
<tr><td class="left">H1.25</td><td class="right">200.0</td><td class="right">250.0</td><td class="right">325.000</td><td class="right">1.25</td></tr>
<tr><td class="left">H1.5</td><td class="right">200.0</td><td class="right">250.0</td><td class="right">325.000</td><td class="right">1.5</td></tr>
<tr><td class="left">H.5</td><td class="right">200.0</td><td class="right">250.0</td><td class="right">325.000</td><td class="right">0.5</td></tr>
<tr><td class="left">H.75</td><td class="right">200.0</td><td class="right">250.0</td><td class="right">325.000</td><td class="right">0.75</td></tr>
<tr><td class="left">He</td><td class="right">359.172</td><td class="right">478.896</td><td class="right">622.565</td><td class="right">2.0</td></tr>
<tr><td class="left">Hf</td><td class="right">165.25</td><td class="right">220.333</td><td class="right">286.433</td><td class="right">4.0</td></tr>
<tr><td class="left">Hf_pv</td><td class="right">165.256</td><td class="right">220.342</td><td class="right">286.445</td><td class="right">10.0</td></tr>
<tr><td class="left">Hf_sv_GW</td><td class="right">238.045</td><td class="right">317.394</td><td class="right">412.612</td><td class="right">12.0</td></tr>
<tr><td class="left">Hf_sv</td><td class="right">178.083</td><td class="right">237.444</td><td class="right">308.677</td><td class="right">12.0</td></tr>
<tr><td class="left">Hg</td><td class="right">174.911</td><td class="right">233.214</td><td class="right">303.178</td><td class="right">12.0</td></tr>
<tr><td class="left">H_h</td><td class="right">500.0</td><td class="right">700.0</td><td class="right">910.000</td><td class="right">1.0</td></tr>
<tr><td class="left">Ho_3</td><td class="right">115.615</td><td class="right">154.153</td><td class="right">200.399</td><td class="right">9.0</td></tr>
<tr><td class="left">Ho</td><td class="right">192.876</td><td class="right">257.168</td><td class="right">334.318</td><td class="right">21.0</td></tr>
<tr><td class="left">H</td><td class="right">200.0</td><td class="right">250.0</td><td class="right">325.000</td><td class="right">1.0</td></tr>
<tr><td class="left">He</td><td class="right">359.172</td><td class="right">478.896</td><td class="right">622.565</td><td class="right">2.0</td></tr>
<tr><td class="left">Hf</td><td class="right">165.25</td><td class="right">220.333</td><td class="right">286.433</td><td class="right">4.0</td></tr>
<tr><td class="left">Hf_pv</td><td class="right">165.256</td><td class="right">220.342</td><td class="right">286.445</td><td class="right">10.0</td></tr>
<tr><td class="left">Hf_sv_GW</td><td class="right">238.045</td><td class="right">317.394</td><td class="right">412.612</td><td class="right">12.0</td></tr>
<tr><td class="left">Hf_sv</td><td class="right">178.083</td><td class="right">237.444</td><td class="right">308.677</td><td class="right">12.0</td></tr>
<tr><td class="left">Hg</td><td class="right">174.911</td><td class="right">233.214</td><td class="right">303.178</td><td class="right">12.0</td></tr>
<tr><td class="left">Ho_3</td><td class="right">115.615</td><td class="right">154.153</td><td class="right">200.399</td><td class="right">9.0</td></tr>
<tr><td class="left">Ho</td><td class="right">192.876</td><td class="right">257.168</td><td class="right">334.318</td><td class="right">21.0</td></tr>
<tr><td class="left">In_d</td><td class="right">179.413</td><td class="right">239.218</td><td class="right">310.983</td><td class="right">13.0</td></tr>
<tr><td class="left">In</td><td class="right">71.951</td><td class="right">95.934</td><td class="right">124.714</td><td class="right">3.0</td></tr>
<tr><td class="left">I</td><td class="right">131.735</td><td class="right">175.647</td><td class="right">228.341</td><td class="right">7.0</td></tr>
<tr><td class="left">Ir</td><td class="right">158.153</td><td class="right">210.87</td><td class="right">274.131</td><td class="right">9.0</td></tr>
<tr><td class="left">In_d</td><td class="right">179.413</td><td class="right">239.218</td><td class="right">310.983</td><td class="right">13.0</td></tr>
<tr><td class="left">In</td><td class="right">71.951</td><td class="right">95.934</td><td class="right">124.714</td><td class="right">3.0</td></tr>
<tr><td class="left">Ir</td><td class="right">158.153</td><td class="right">210.87</td><td class="right">274.131</td><td class="right">9.0</td></tr>
<tr><td class="left">K_pv</td><td class="right">87.548</td><td class="right">116.731</td><td class="right">151.750</td><td class="right">7.0</td></tr>
<tr><td class="left">Kr</td><td class="right">138.945</td><td class="right">185.26</td><td class="right">240.838</td><td class="right">8.0</td></tr>
<tr><td class="left">K_sv</td><td class="right">194.412</td><td class="right">259.216</td><td class="right">336.981</td><td class="right">9.0</td></tr>
<tr><td class="left">Kr</td><td class="right">138.945</td><td class="right">185.26</td><td class="right">240.838</td><td class="right">8.0</td></tr>
<tr><td class="left">La</td><td class="right">164.485</td><td class="right">219.313</td><td class="right">285.107</td><td class="right">11.0</td></tr>
<tr><td class="left">La_s</td><td class="right">102.414</td><td class="right">136.552</td><td class="right">177.518</td><td class="right">9.0</td></tr>
<tr><td class="left">Li</td><td class="right">100.0</td><td class="right">140.0</td><td class="right">182.000</td><td class="right">1.0</td></tr>
<tr><td class="left">Li_sv2</td><td class="right">416.33</td><td class="right">555.106</td><td class="right">721.638</td><td class="right">3.0</td></tr>
<tr><td class="left">Li_sv</td><td class="right">374.276</td><td class="right">499.034</td><td class="right">648.744</td><td class="right">3.0</td></tr>
<tr><td class="left">Lu_3</td><td class="right">116.257</td><td class="right">155.009</td><td class="right">201.512</td><td class="right">9.0</td></tr>
<tr><td class="left">Lu</td><td class="right">191.771</td><td class="right">255.695</td><td class="right">332.404</td><td class="right">25.0</td></tr>
<tr><td class="left">Mg_new</td><td class="right">94.607</td><td class="right">126.143</td><td class="right">163.986</td><td class="right">2.0</td></tr>
<tr><td class="left">Mg</td><td class="right">157.509</td><td class="right">210.012</td><td class="right">273.016</td><td class="right">2.0</td></tr>
<tr><td class="left">Mg_pv_GW</td><td class="right">302.947</td><td class="right">403.929</td><td class="right">525.108</td><td class="right">8.0</td></tr>
<tr><td class="left">Mg_pv.old</td><td class="right">199.18</td><td class="right">265.574</td><td class="right">345.246</td><td class="right">8.0</td></tr>
<tr><td class="left">Mg_pv</td><td class="right">302.947</td><td class="right">403.929</td><td class="right">525.108</td><td class="right">8.0</td></tr>
<tr><td class="left">Mg_sv</td><td class="right">371.417</td><td class="right">495.223</td><td class="right">643.790</td><td class="right">10.0</td></tr>
<tr><td class="left">Mn</td><td class="right">202.399</td><td class="right">269.865</td><td class="right">350.825</td><td class="right">7.0</td></tr>
<tr><td class="left">Mn_pv_new</td><td class="right">202.398</td><td class="right">269.864</td><td class="right">350.823</td><td class="right">13.0</td></tr>
<tr><td class="left">Mn_pv</td><td class="right">202.399</td><td class="right">269.865</td><td class="right">350.825</td><td class="right">13.0</td></tr>
<tr><td class="left">Mn_sv</td><td class="right">290.39</td><td class="right">387.187</td><td class="right">503.343</td><td class="right">15.0</td></tr>
<tr><td class="left">Mo</td><td class="right">168.438</td><td class="right">224.584</td><td class="right">291.959</td><td class="right">6.0</td></tr>
<tr><td class="left">Mo_pv_new</td><td class="right">168.438</td><td class="right">224.584</td><td class="right">291.959</td><td class="right">12.0</td></tr>
<tr><td class="left">Mo_pv</td><td class="right">168.438</td><td class="right">224.584</td><td class="right">291.959</td><td class="right">12.0</td></tr>
<tr><td class="left">Mo_sv</td><td class="right">182.007</td><td class="right">242.676</td><td class="right">315.479</td><td class="right">14.0</td></tr>
<tr><td class="left">Na</td><td class="right">76.476</td><td class="right">101.968</td><td class="right">132.558</td><td class="right">1.0</td></tr>
<tr><td class="left">Na_pv</td><td class="right">194.671</td><td class="right">259.561</td><td class="right">337.429</td><td class="right">7.0</td></tr>
<tr><td class="left">Na_sv</td><td class="right">484.23</td><td class="right">700.0</td><td class="right">910.000</td><td class="right">9.0</td></tr>
<tr><td class="left">Nb_pv</td><td class="right">156.456</td><td class="right">208.608</td><td class="right">271.190</td><td class="right">11.0</td></tr>
<tr><td class="left">Nb_sv_new</td><td class="right">219.927</td><td class="right">293.235</td><td class="right">381.206</td><td class="right">13.0</td></tr>
<tr><td class="left">Nb_sv</td><td class="right">219.927</td><td class="right">293.235</td><td class="right">381.206</td><td class="right">13.0</td></tr>
<tr><td class="left">Nd_3</td><td class="right">136.909</td><td class="right">182.546</td><td class="right">237.310</td><td class="right">11.0</td></tr>
<tr><td class="left">Nd</td><td class="right">189.892</td><td class="right">253.189</td><td class="right">329.146</td><td class="right">14.0</td></tr>
<tr><td class="left">Ne</td><td class="right">257.704</td><td class="right">343.606</td><td class="right">446.688</td><td class="right">8.0</td></tr>
<tr><td class="left">N_h</td><td class="right">500.0</td><td class="right">700.0</td><td class="right">910.000</td><td class="right">5.0</td></tr>
<tr><td class="left">Ni_new</td><td class="right">202.149</td><td class="right">269.532</td><td class="right">350.392</td><td class="right">10.0</td></tr>
<tr><td class="left">Ni</td><td class="right">202.15</td><td class="right">269.533</td><td class="right">350.393</td><td class="right">10.0</td></tr>
<tr><td class="left">Ni_pv</td><td class="right">275.959</td><td class="right">367.945</td><td class="right">478.329</td><td class="right">16.0</td></tr>
<tr><td class="left">N</td><td class="right">300.0</td><td class="right">400.0</td><td class="right">520.000</td><td class="right">5.0</td></tr>
<tr><td class="left">Np</td><td class="right">190.776</td><td class="right">254.369</td><td class="right">330.680</td><td class="right">15.0</td></tr>
<tr><td class="left">Np_s</td><td class="right">158.138</td><td class="right">210.851</td><td class="right">274.106</td><td class="right">15.0</td></tr>
<tr><td class="left">N_s_GW</td><td class="right">222.371</td><td class="right">296.495</td><td class="right">385.444</td><td class="right">5.0</td></tr>
<tr><td class="left">N_s</td><td class="right">209.76</td><td class="right">279.68</td><td class="right">363.584</td><td class="right">5.0</td></tr>
<tr><td class="left">N_vs</td><td class="right">209.76</td><td class="right">279.68</td><td class="right">363.584</td><td class="right">5.0</td></tr>
<tr><td class="left">Na</td><td class="right">76.476</td><td class="right">101.968</td><td class="right">132.558</td><td class="right">1.0</td></tr>
<tr><td class="left">Na_pv</td><td class="right">194.671</td><td class="right">259.561</td><td class="right">337.429</td><td class="right">7.0</td></tr>
<tr><td class="left">Na_sv</td><td class="right">484.23</td><td class="right">700.0</td><td class="right">910.000</td><td class="right">9.0</td></tr>
<tr><td class="left">Nb_pv</td><td class="right">156.456</td><td class="right">208.608</td><td class="right">271.190</td><td class="right">11.0</td></tr>
<tr><td class="left">Nb_sv_new</td><td class="right">219.927</td><td class="right">293.235</td><td class="right">381.206</td><td class="right">13.0</td></tr>
<tr><td class="left">Nb_sv</td><td class="right">219.927</td><td class="right">293.235</td><td class="right">381.206</td><td class="right">13.0</td></tr>
<tr><td class="left">Nd_3</td><td class="right">136.909</td><td class="right">182.546</td><td class="right">237.310</td><td class="right">11.0</td></tr>
<tr><td class="left">Nd</td><td class="right">189.892</td><td class="right">253.189</td><td class="right">329.146</td><td class="right">14.0</td></tr>
<tr><td class="left">Ne</td><td class="right">257.704</td><td class="right">343.606</td><td class="right">446.688</td><td class="right">8.0</td></tr>
<tr><td class="left">Ni_new</td><td class="right">202.149</td><td class="right">269.532</td><td class="right">350.392</td><td class="right">10.0</td></tr>
<tr><td class="left">Ni</td><td class="right">202.15</td><td class="right">269.533</td><td class="right">350.393</td><td class="right">10.0</td></tr>
<tr><td class="left">Ni_pv</td><td class="right">275.959</td><td class="right">367.945</td><td class="right">478.329</td><td class="right">16.0</td></tr>
<tr><td class="left">Np</td><td class="right">190.776</td><td class="right">254.369</td><td class="right">330.680</td><td class="right">15.0</td></tr>
<tr><td class="left">Np_s</td><td class="right">158.138</td><td class="right">210.851</td><td class="right">274.106</td><td class="right">15.0</td></tr>
<tr><td class="left">O_GW</td><td class="right">310.976</td><td class="right">414.635</td><td class="right">539.025</td><td class="right">6.0</td></tr>
<tr><td class="left">O_h</td><td class="right">500.0</td><td class="right">700.0</td><td class="right">910.000</td><td class="right">6.0</td></tr>
<tr><td class="left">O</td><td class="right">300.0</td><td class="right">400.0</td><td class="right">520.000</td><td class="right">6.0</td></tr>
<tr><td class="left">O_s_GW</td><td class="right">225.516</td><td class="right">300.688</td><td class="right">390.894</td><td class="right">6.0</td></tr>
<tr><td class="left">O_s</td><td class="right">212.131</td><td class="right">282.841</td><td class="right">367.693</td><td class="right">6.0</td></tr>
<tr><td class="left">Os</td><td class="right">171.017</td><td class="right">228.022</td><td class="right">296.429</td><td class="right">8.0</td></tr>
<tr><td class="left">Os_pv</td><td class="right">171.017</td><td class="right">228.022</td><td class="right">296.429</td><td class="right">14.0</td></tr>
<tr><td class="left">O_sv</td><td class="right">1066.119</td><td class="right">1421.493</td><td class="right">1847.941</td><td class="right">8.0</td></tr>
<tr><td class="left">Os</td><td class="right">171.017</td><td class="right">228.022</td><td class="right">296.429</td><td class="right">8.0</td></tr>
<tr><td class="left">Os_pv</td><td class="right">171.017</td><td class="right">228.022</td><td class="right">296.429</td><td class="right">14.0</td></tr>
<tr><td class="left">Pa</td><td class="right">189.237</td><td class="right">252.316</td><td class="right">328.011</td><td class="right">13.0</td></tr>
<tr><td class="left">Pa_s</td><td class="right">145.182</td><td class="right">193.576</td><td class="right">251.649</td><td class="right">11.0</td></tr>
<tr><td class="left">Pb_d</td><td class="right">178.384</td><td class="right">237.846</td><td class="right">309.200</td><td class="right">14.0</td></tr>
<tr><td class="left">Pb_d_rel2</td><td class="right">178.357</td><td class="right">237.809</td><td class="right">309.152</td><td class="right">14.0</td></tr>
<tr><td class="left">Pb_d_rel</td><td class="right">178.357</td><td class="right">237.809</td><td class="right">309.152</td><td class="right">14.0</td></tr>
<tr><td class="left">Pb</td><td class="right">73.48</td><td class="right">97.973</td><td class="right">127.365</td><td class="right">4.0</td></tr>
<tr><td class="left">Pd_new</td><td class="right">188.194</td><td class="right">250.925</td><td class="right">326.203</td><td class="right">10.0</td></tr>
<tr><td class="left">Pd</td><td class="right">188.194</td><td class="right">250.925</td><td class="right">326.203</td><td class="right">10.0</td></tr>
<tr><td class="left">Pd_pv_new</td><td class="right">188.194</td><td class="right">250.925</td><td class="right">326.203</td><td class="right">16.0</td></tr>
<tr><td class="left">Pd_pv</td><td class="right">203.323</td><td class="right">271.098</td><td class="right">352.427</td><td class="right">16.0</td></tr>
<tr><td class="left">Pd_vnew</td><td class="right">188.194</td><td class="right">250.925</td><td class="right">326.203</td><td class="right">10.0</td></tr>
<tr><td class="left">P_h</td><td class="right">292.651</td><td class="right">390.202</td><td class="right">507.263</td><td class="right">5.0</td></tr>
<tr><td class="left">Pm_3</td><td class="right">137.931</td><td class="right">183.908</td><td class="right">239.080</td><td class="right">11.0</td></tr>
<tr><td class="left">Pm</td><td class="right">193.97</td><td class="right">258.627</td><td class="right">336.215</td><td class="right">15.0</td></tr>
<tr><td class="left">Po_d</td><td class="right">198.424</td><td class="right">264.565</td><td class="right">343.935</td><td class="right">16.0</td></tr>
<tr><td class="left">Po</td><td class="right">119.78</td><td class="right">159.707</td><td class="right">207.619</td><td class="right">6.0</td></tr>
<tr><td class="left">P</td><td class="right">191.28</td><td class="right">270.0</td><td class="right">351.000</td><td class="right">5.0</td></tr>
<tr><td class="left">Pr_3</td><td class="right">136.734</td><td class="right">182.312</td><td class="right">237.006</td><td class="right">11.0</td></tr>
<tr><td class="left">Pr</td><td class="right">204.706</td><td class="right">272.941</td><td class="right">354.823</td><td class="right">13.0</td></tr>
<tr><td class="left">Pt_new</td><td class="right">172.712</td><td class="right">230.283</td><td class="right">299.368</td><td class="right">10.0</td></tr>
<tr><td class="left">Pt</td><td class="right">172.712</td><td class="right">230.283</td><td class="right">299.368</td><td class="right">10.0</td></tr>
<tr><td class="left">Pt_pv</td><td class="right">220.955</td><td class="right">294.607</td><td class="right">382.989</td><td class="right">16.0</td></tr>
<tr><td class="left">Pt_pv_ZORA</td><td class="right">220.953</td><td class="right">294.604</td><td class="right">382.985</td><td class="right">16.0</td></tr>
<tr><td class="left">Pt_ZORA</td><td class="right">172.711</td><td class="right">230.281</td><td class="right">299.365</td><td class="right">10.0</td></tr>
<tr><td class="left">Pu_h</td><td class="right">333.587</td><td class="right">444.783</td><td class="right">578.218</td><td class="right">16.0</td></tr>
<tr><td class="left">Pu</td><td class="right">190.844</td><td class="right">254.458</td><td class="right">330.795</td><td class="right">16.0</td></tr>
<tr><td class="left">Pu_s</td><td class="right">158.508</td><td class="right">211.344</td><td class="right">274.747</td><td class="right">16.0</td></tr>
<tr><td class="left">Pa</td><td class="right">189.237</td><td class="right">252.316</td><td class="right">328.011</td><td class="right">13.0</td></tr>
<tr><td class="left">Pa_s</td><td class="right">145.182</td><td class="right">193.576</td><td class="right">251.649</td><td class="right">11.0</td></tr>
<tr><td class="left">Pb_d</td><td class="right">178.384</td><td class="right">237.846</td><td class="right">309.200</td><td class="right">14.0</td></tr>
<tr><td class="left">Pb_d_rel2</td><td class="right">178.357</td><td class="right">237.809</td><td class="right">309.152</td><td class="right">14.0</td></tr>
<tr><td class="left">Pb_d_rel</td><td class="right">178.357</td><td class="right">237.809</td><td class="right">309.152</td><td class="right">14.0</td></tr>
<tr><td class="left">Pb</td><td class="right">73.48</td><td class="right">97.973</td><td class="right">127.365</td><td class="right">4.0</td></tr>
<tr><td class="left">Pd_new</td><td class="right">188.194</td><td class="right">250.925</td><td class="right">326.203</td><td class="right">10.0</td></tr>
<tr><td class="left">Pd</td><td class="right">188.194</td><td class="right">250.925</td><td class="right">326.203</td><td class="right">10.0</td></tr>
<tr><td class="left">Pd_pv_new</td><td class="right">188.194</td><td class="right">250.925</td><td class="right">326.203</td><td class="right">16.0</td></tr>
<tr><td class="left">Pd_pv</td><td class="right">203.323</td><td class="right">271.098</td><td class="right">352.427</td><td class="right">16.0</td></tr>
<tr><td class="left">Pd_vnew</td><td class="right">188.194</td><td class="right">250.925</td><td class="right">326.203</td><td class="right">10.0</td></tr>
<tr><td class="left">Pm_3</td><td class="right">137.931</td><td class="right">183.908</td><td class="right">239.080</td><td class="right">11.0</td></tr>
<tr><td class="left">Pm</td><td class="right">193.97</td><td class="right">258.627</td><td class="right">336.215</td><td class="right">15.0</td></tr>
<tr><td class="left">Po_d</td><td class="right">198.424</td><td class="right">264.565</td><td class="right">343.935</td><td class="right">16.0</td></tr>
<tr><td class="left">Po</td><td class="right">119.78</td><td class="right">159.707</td><td class="right">207.619</td><td class="right">6.0</td></tr>
<tr><td class="left">Pr_3</td><td class="right">136.734</td><td class="right">182.312</td><td class="right">237.006</td><td class="right">11.0</td></tr>
<tr><td class="left">Pr</td><td class="right">204.706</td><td class="right">272.941</td><td class="right">354.823</td><td class="right">13.0</td></tr>
<tr><td class="left">Pt_new</td><td class="right">172.712</td><td class="right">230.283</td><td class="right">299.368</td><td class="right">10.0</td></tr>
<tr><td class="left">Pt</td><td class="right">172.712</td><td class="right">230.283</td><td class="right">299.368</td><td class="right">10.0</td></tr>
<tr><td class="left">Pt_pv</td><td class="right">220.955</td><td class="right">294.607</td><td class="right">382.989</td><td class="right">16.0</td></tr>
<tr><td class="left">Pt_pv_ZORA</td><td class="right">220.953</td><td class="right">294.604</td><td class="right">382.985</td><td class="right">16.0</td></tr>
<tr><td class="left">Pt_ZORA</td><td class="right">172.711</td><td class="right">230.281</td><td class="right">299.365</td><td class="right">10.0</td></tr>
<tr><td class="left">Pu_h</td><td class="right">333.587</td><td class="right">444.783</td><td class="right">578.218</td><td class="right">16.0</td></tr>
<tr><td class="left">Pu</td><td class="right">190.844</td><td class="right">254.458</td><td class="right">330.795</td><td class="right">16.0</td></tr>
<tr><td class="left">Pu_s</td><td class="right">158.508</td><td class="right">211.344</td><td class="right">274.747</td><td class="right">16.0</td></tr>
<tr><td class="left">Ra_sv</td><td class="right">178.025</td><td class="right">237.367</td><td class="right">308.577</td><td class="right">10.0</td></tr>
<tr><td class="left">Rb_pv</td><td class="right">91.439</td><td class="right">121.919</td><td class="right">158.495</td><td class="right">7.0</td></tr>
<tr><td class="left">Rb_sv</td><td class="right">165.017</td><td class="right">220.022</td><td class="right">286.029</td><td class="right">9.0</td></tr>
<tr><td class="left">Re</td><td class="right">169.662</td><td class="right">226.216</td><td class="right">294.081</td><td class="right">7.0</td></tr>
<tr><td class="left">Re_pv</td><td class="right">169.667</td><td class="right">226.223</td><td class="right">294.090</td><td class="right">13.0</td></tr>
<tr><td class="left">Rh_new</td><td class="right">171.747</td><td class="right">228.996</td><td class="right">297.695</td><td class="right">9.0</td></tr>
<tr><td class="left">Rh</td><td class="right">171.75</td><td class="right">229.0</td><td class="right">297.700</td><td class="right">9.0</td></tr>
<tr><td class="left">Rh_pv_new</td><td class="right">185.556</td><td class="right">247.408</td><td class="right">321.630</td><td class="right">15.0</td></tr>
<tr><td class="left">Rh_pv</td><td class="right">203.602</td><td class="right">271.47</td><td class="right">352.911</td><td class="right">15.0</td></tr>
<tr><td class="left">Rn</td><td class="right">114.091</td><td class="right">152.121</td><td class="right">197.757</td><td class="right">8.0</td></tr>
<tr><td class="left">Ru_new</td><td class="right">159.953</td><td class="right">213.271</td><td class="right">277.252</td><td class="right">8.0</td></tr>
<tr><td class="left">Ru</td><td class="right">159.957</td><td class="right">213.276</td><td class="right">277.259</td><td class="right">8.0</td></tr>
<tr><td class="left">Ru_pv_new</td><td class="right">180.037</td><td class="right">240.049</td><td class="right">312.064</td><td class="right">14.0</td></tr>
<tr><td class="left">Ru_pv</td><td class="right">172.822</td><td class="right">230.429</td><td class="right">299.558</td><td class="right">14.0</td></tr>
<tr><td class="left">Ru_sv</td><td class="right">239.141</td><td class="right">318.855</td><td class="right">414.512</td><td class="right">16.0</td></tr>
<tr><td class="left">Sb</td><td class="right">129.028</td><td class="right">172.037</td><td class="right">223.648</td><td class="right">5.0</td></tr>
<tr><td class="left">Sc</td><td class="right">116.072</td><td class="right">154.763</td><td class="right">201.192</td><td class="right">3.0</td></tr>
<tr><td class="left">Sc_sv_h</td><td class="right">285.522</td><td class="right">380.696</td><td class="right">494.905</td><td class="right">11.0</td></tr>
<tr><td class="left">Sc_sv</td><td class="right">166.998</td><td class="right">222.664</td><td class="right">289.463</td><td class="right">11.0</td></tr>
<tr><td class="left">Se_GW</td><td class="right">158.666</td><td class="right">211.555</td><td class="right">275.022</td><td class="right">6.0</td></tr>
<tr><td class="left">Se</td><td class="right">158.651</td><td class="right">211.534</td><td class="right">274.994</td><td class="right">6.0</td></tr>
<tr><td class="left">S_h</td><td class="right">301.827</td><td class="right">402.436</td><td class="right">523.167</td><td class="right">6.0</td></tr>
<tr><td class="left">Si_d_GW_nr</td><td class="right">184.004</td><td class="right">245.338</td><td class="right">318.939</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_d_GW</td><td class="right">184.009</td><td class="right">245.345</td><td class="right">318.949</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_h_old</td><td class="right">285.109</td><td class="right">380.146</td><td class="right">494.190</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_h</td><td class="right">285.109</td><td class="right">380.146</td><td class="right">494.190</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_nopc</td><td class="right">184.009</td><td class="right">245.345</td><td class="right">318.949</td><td class="right">4.0</td></tr>
<tr><td class="left">Si</td><td class="right">184.009</td><td class="right">245.345</td><td class="right">318.949</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_pv_GW</td><td class="right">356.322</td><td class="right">475.096</td><td class="right">617.625</td><td class="right">10.0</td></tr>
<tr><td class="left">Si_sv_GW_nr</td><td class="right">356.326</td><td class="right">475.101</td><td class="right">617.631</td><td class="right">12.0</td></tr>
<tr><td class="left">Si_sv_GW</td><td class="right">356.322</td><td class="right">475.096</td><td class="right">617.625</td><td class="right">12.0</td></tr>
<tr><td class="left">Sm_3</td><td class="right">132.815</td><td class="right">177.087</td><td class="right">230.213</td><td class="right">11.0</td></tr>
<tr><td class="left">Sm</td><td class="right">193.136</td><td class="right">257.515</td><td class="right">334.769</td><td class="right">16.0</td></tr>
<tr><td class="left">Sn_d</td><td class="right">180.817</td><td class="right">241.09</td><td class="right">313.417</td><td class="right">14.0</td></tr>
<tr><td class="left">Sn_GW</td><td class="right">77.427</td><td class="right">103.236</td><td class="right">134.207</td><td class="right">4.0</td></tr>
<tr><td class="left">Sn</td><td class="right">77.427</td><td class="right">103.236</td><td class="right">134.207</td><td class="right">4.0</td></tr>
<tr><td class="left">S</td><td class="right">194.016</td><td class="right">280.0</td><td class="right">364.000</td><td class="right">6.0</td></tr>
<tr><td class="left">Sr_sv</td><td class="right">171.961</td><td class="right">229.282</td><td class="right">298.067</td><td class="right">10.0</td></tr>
<tr><td class="left">Sr</td><td class="right">171.961</td><td class="right">229.282</td><td class="right">298.067</td><td class="right">10.0</td></tr>
<tr><td class="left">Sb</td><td class="right">129.028</td><td class="right">172.037</td><td class="right">223.648</td><td class="right">5.0</td></tr>
<tr><td class="left">Sc</td><td class="right">116.072</td><td class="right">154.763</td><td class="right">201.192</td><td class="right">3.0</td></tr>
<tr><td class="left">Sc_sv_h</td><td class="right">285.522</td><td class="right">380.696</td><td class="right">494.905</td><td class="right">11.0</td></tr>
<tr><td class="left">Sc_sv</td><td class="right">166.998</td><td class="right">222.664</td><td class="right">289.463</td><td class="right">11.0</td></tr>
<tr><td class="left">Se_GW</td><td class="right">158.666</td><td class="right">211.555</td><td class="right">275.022</td><td class="right">6.0</td></tr>
<tr><td class="left">Se</td><td class="right">158.651</td><td class="right">211.534</td><td class="right">274.994</td><td class="right">6.0</td></tr>
<tr><td class="left">Si_d_GW_nr</td><td class="right">184.004</td><td class="right">245.338</td><td class="right">318.939</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_d_GW</td><td class="right">184.009</td><td class="right">245.345</td><td class="right">318.949</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_h_old</td><td class="right">285.109</td><td class="right">380.146</td><td class="right">494.190</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_h</td><td class="right">285.109</td><td class="right">380.146</td><td class="right">494.190</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_nopc</td><td class="right">184.009</td><td class="right">245.345</td><td class="right">318.949</td><td class="right">4.0</td></tr>
<tr><td class="left">Si</td><td class="right">184.009</td><td class="right">245.345</td><td class="right">318.949</td><td class="right">4.0</td></tr>
<tr><td class="left">Si_pv_GW</td><td class="right">356.322</td><td class="right">475.096</td><td class="right">617.625</td><td class="right">10.0</td></tr>
<tr><td class="left">Si_sv_GW_nr</td><td class="right">356.326</td><td class="right">475.101</td><td class="right">617.631</td><td class="right">12.0</td></tr>
<tr><td class="left">Si_sv_GW</td><td class="right">356.322</td><td class="right">475.096</td><td class="right">617.625</td><td class="right">12.0</td></tr>
<tr><td class="left">Sm_3</td><td class="right">132.815</td><td class="right">177.087</td><td class="right">230.213</td><td class="right">11.0</td></tr>
<tr><td class="left">Sm</td><td class="right">193.136</td><td class="right">257.515</td><td class="right">334.769</td><td class="right">16.0</td></tr>
<tr><td class="left">Sn_d</td><td class="right">180.817</td><td class="right">241.09</td><td class="right">313.417</td><td class="right">14.0</td></tr>
<tr><td class="left">Sn_GW</td><td class="right">77.427</td><td class="right">103.236</td><td class="right">134.207</td><td class="right">4.0</td></tr>
<tr><td class="left">Sn</td><td class="right">77.427</td><td class="right">103.236</td><td class="right">134.207</td><td class="right">4.0</td></tr>
<tr><td class="left">Sr_sv</td><td class="right">171.961</td><td class="right">229.282</td><td class="right">298.067</td><td class="right">10.0</td></tr>
<tr><td class="left">Sr</td><td class="right">171.961</td><td class="right">229.282</td><td class="right">298.067</td><td class="right">10.0</td></tr>
<tr><td class="left">Ta</td><td class="right">167.75</td><td class="right">223.667</td><td class="right">290.767</td><td class="right">5.0</td></tr>
<tr><td class="left">Ta_pv</td><td class="right">167.756</td><td class="right">223.675</td><td class="right">290.778</td><td class="right">11.0</td></tr>
<tr><td class="left">Tb_3</td><td class="right">116.721</td><td class="right">155.628</td><td class="right">202.316</td><td class="right">9.0</td></tr>
<tr><td class="left">Tb</td><td class="right">198.618</td><td class="right">264.824</td><td class="right">344.271</td><td class="right">19.0</td></tr>
<tr><td class="left">Tc_new</td><td class="right">171.521</td><td class="right">228.694</td><td class="right">297.302</td><td class="right">7.0</td></tr>
<tr><td class="left">Tc</td><td class="right">171.521</td><td class="right">228.694</td><td class="right">297.302</td><td class="right">7.0</td></tr>
<tr><td class="left">Tc_pv_new</td><td class="right">197.642</td><td class="right">263.523</td><td class="right">342.580</td><td class="right">13.0</td></tr>
<tr><td class="left">Tc_pv</td><td class="right">171.524</td><td class="right">228.699</td><td class="right">297.309</td><td class="right">13.0</td></tr>
<tr><td class="left">Te</td><td class="right">131.236</td><td class="right">174.982</td><td class="right">227.477</td><td class="right">6.0</td></tr>
<tr><td class="left">Te_rel</td><td class="right">131.234</td><td class="right">174.979</td><td class="right">227.473</td><td class="right">6.0</td></tr>
<tr><td class="left">Th</td><td class="right">185.587</td><td class="right">247.449</td><td class="right">321.684</td><td class="right">12.0</td></tr>
<tr><td class="left">Th_s</td><td class="right">127.119</td><td class="right">169.492</td><td class="right">220.340</td><td class="right">10.0</td></tr>
<tr><td class="left">Ti</td><td class="right">133.747</td><td class="right">178.33</td><td class="right">231.829</td><td class="right">4.0</td></tr>
<tr><td class="left">Ti_pv</td><td class="right">166.753</td><td class="right">222.338</td><td class="right">289.039</td><td class="right">10.0</td></tr>
<tr><td class="left">Ti_sv_GW</td><td class="right">234.428</td><td class="right">312.571</td><td class="right">406.342</td><td class="right">12.0</td></tr>
<tr><td class="left">Ti_sv_h</td><td class="right">291.524</td><td class="right">388.698</td><td class="right">505.307</td><td class="right">12.0</td></tr>
<tr><td class="left">Ti_sv_new2</td><td class="right">205.957</td><td class="right">274.61</td><td class="right">356.993</td><td class="right">12.0</td></tr>
<tr><td class="left">Ti_sv_new</td><td class="right">205.957</td><td class="right">274.61</td><td class="right">356.993</td><td class="right">12.0</td></tr>
<tr><td class="left">Ti_sv</td><td class="right">205.93</td><td class="right">274.574</td><td class="right">356.946</td><td class="right">12.0</td></tr>
<tr><td class="left">Tl_d</td><td class="right">177.797</td><td class="right">237.063</td><td class="right">308.182</td><td class="right">13.0</td></tr>
<tr><td class="left">Tl</td><td class="right">67.605</td><td class="right">90.14</td><td class="right">117.182</td><td class="right">3.0</td></tr>
<tr><td class="left">Tm_3</td><td class="right">111.916</td><td class="right">149.221</td><td class="right">193.987</td><td class="right">9.0</td></tr>
<tr><td class="left">Tm</td><td class="right">193.065</td><td class="right">257.419</td><td class="right">334.645</td><td class="right">23.0</td></tr>
<tr><td class="left">U</td><td class="right">189.462</td><td class="right">252.616</td><td class="right">328.401</td><td class="right">14.0</td></tr>
<tr><td class="left">U_s</td><td class="right">156.802</td><td class="right">209.069</td><td class="right">271.790</td><td class="right">14.0</td></tr>
<tr><td class="left">V</td><td class="right">144.408</td><td class="right">192.543</td><td class="right">250.306</td><td class="right">5.0</td></tr>
<tr><td class="left">V_pv</td><td class="right">197.756</td><td class="right">263.675</td><td class="right">342.778</td><td class="right">11.0</td></tr>
<tr><td class="left">V_sv_h</td><td class="right">292.998</td><td class="right">390.664</td><td class="right">507.863</td><td class="right">13.0</td></tr>
<tr><td class="left">V_sv_new</td><td class="right">197.755</td><td class="right">263.673</td><td class="right">342.775</td><td class="right">13.0</td></tr>
<tr><td class="left">V_sv</td><td class="right">197.756</td><td class="right">263.675</td><td class="right">342.778</td><td class="right">13.0</td></tr>
<tr><td class="left">W</td><td class="right">167.293</td><td class="right">223.057</td><td class="right">289.974</td><td class="right">6.0</td></tr>
<tr><td class="left">W_pv_new</td><td class="right">167.293</td><td class="right">223.057</td><td class="right">289.974</td><td class="right">12.0</td></tr>
<tr><td class="left">W_pv</td><td class="right">167.299</td><td class="right">223.065</td><td class="right">289.985</td><td class="right">12.0</td></tr>
<tr><td class="left">Xe</td><td class="right">114.823</td><td class="right">153.098</td><td class="right">199.027</td><td class="right">8.0</td></tr>
<tr><td class="left">Xe</td><td class="right">114.823</td><td class="right">153.098</td><td class="right">199.027</td><td class="right">8.0</td></tr>
<tr><td class="left">Yb_2_n</td><td class="right">108.514</td><td class="right">144.685</td><td class="right">188.091</td><td class="right">10.0</td></tr>
<tr><td class="left">Yb_2</td><td class="right">84.407</td><td class="right">112.543</td><td class="right">146.306</td><td class="right">8.0</td></tr>
<tr><td class="left">Yb</td><td class="right">189.771</td><td class="right">253.028</td><td class="right">328.936</td><td class="right">24.0</td></tr>
<tr><td class="left">Y_sv</td><td class="right">158.731</td><td class="right">211.641</td><td class="right">275.133</td><td class="right">11.0</td></tr>
<tr><td class="left">Yb_2_n</td><td class="right">108.514</td><td class="right">144.685</td><td class="right">188.091</td><td class="right">10.0</td></tr>
<tr><td class="left">Yb_2</td><td class="right">84.407</td><td class="right">112.543</td><td class="right">146.306</td><td class="right">8.0</td></tr>
<tr><td class="left">Yb</td><td class="right">189.771</td><td class="right">253.028</td><td class="right">328.936</td><td class="right">24.0</td></tr>
<tr><td class="left">Zn</td><td class="right">207.545</td><td class="right">276.727</td><td class="right">359.745</td><td class="right">12.0</td></tr>
<tr><td class="left">Zn_pv</td><td class="right">282.455</td><td class="right">376.607</td><td class="right">489.589</td><td class="right">18.0</td></tr>
<tr><td class="left">Zr</td><td class="right">115.974</td><td class="right">154.632</td><td class="right">201.022</td><td class="right">4.0</td></tr>
<tr><td class="left">Zr_sv_GW</td><td class="right">230.877</td><td class="right">307.836</td><td class="right">400.187</td><td class="right">12.0</td></tr>
<tr><td class="left">Zr_sv_new</td><td class="right">172.424</td><td class="right">229.898</td><td class="right">298.867</td><td class="right">12.0</td></tr>
<tr><td class="left">Zr_sv</td><td class="right">172.379</td><td class="right">229.839</td><td class="right">298.791</td><td class="right">12.0</td></tr>
</tbody>
</table>



</div>
</div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Python</h2>
<div class="outline-text-2" id="text-10">


</div>

<div id="outline-container-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> easy_install as a user</h3>
<div class="outline-text-3" id="text-10-1">


<p>
<code>easy_install</code> is a python command-line utility that automatically installs python packages. Usually you need root access to install a python package, but you can also tell <code>easy_install</code> where to install a package. This usually works if the directory is on your PYTHONPATH
</p>
<p>
easy_install -d ~/lib/python2.6/site-packages/ pymatgen
</p></div>

</div>

<div id="outline-container-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> Integer division math gotchas</h3>
<div class="outline-text-3" id="text-10-2">

<p>It pays to be careful when dividing by integers because you can get unexpected results if you do not know the integer division rules. In python 2.6, if you divide two integers, you get an integer! This is usually not a problem if there is no emainder in the division, e.g. 6/3=2. But, if there is a remainder, and that remainder is important, you will lose it. Here is an example of calculating the mole fraction of a species from integer numbers of atoms in the unit cell. If you are not careful, you get the wrong answer! You can convert (also called casting) a number to a float using the float command.
</p>



<pre class="src src-python">nPd = 4
nCu = 5
x_Cu = nCu/(nPd + nCu)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'x_cu = {0} (integer division)'</span>.format(x_Cu)

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now cast as floats</span>
x_Cu = <span style="color: #cd0000; font-weight: bold;">float</span>(nCu)/<span style="color: #cd0000; font-weight: bold;">float</span>(nPd + nCu)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'x_cu = {0} (float division)'</span>.format(x_Cu)
</pre>


<pre class="example">
x_cu = 0 (integer division)
x_cu = 0.555555555556 (float division)
</pre>


<p>
Note that if one of the numbers is a float, python will automatically cast the integer as a float, and return a float.
</p>


<pre class="src src-python">nPd = 4
nCu = 5

<span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">now cast as floats</span>
x_Cu = <span style="color: #cd0000; font-weight: bold;">float</span>(nCu)/(nPd + nCu)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'x_cu = {0}'</span>.format(x_Cu)
</pre>


<pre class="example">
x_cu = 0.555555555556
</pre>


<p>
Finally, you can tell python a number is a float by adding a decimal to it. You do not need to put a 0 after the decimal, but you can.
</p>



<pre class="src src-python">nPd = 4.  <span style="color: #cd0000; font-weight: bold;"># </span><span style="color: #cd0000; font-weight: bold;">this is a float</span>
nCu = 5

x_Cu = nCu/(nPd + nCu)
<span style="color: #cd0000; font-weight: bold;">print</span> <span style="color: #00cd00;">'x_cu = {0}'</span>.format(x_Cu)
</pre>


<pre class="example">
x_cu = 0.555555555556
</pre>


</div>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> References</h2>
<div class="outline-text-2" id="text-11">

<p>\bibliographystyle{unsrtnat}
Bibliography
</p>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> GNU Free Documentation License</h2>
<div class="outline-text-2" id="text-12">




<pre class="example">                GNU Free Documentation License
                 Version 1.3, 3 November 2008


 Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     &lt;http://fsf.org/&gt;
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

0. PREAMBLE

The purpose of this License is to make a manual, textbook, or other
functional and useful document "free" in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.

This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.


1. APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The "Document", below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as "you".  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.

A "Modified Version" of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

A "Secondary Section" is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

The "Invariant Sections" are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.

The "Cover Texts" are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.

A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not "Transparent" is called "Opaque".

Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML
or XML using a publicly available DTD, and standard-conforming simple
HTML, PostScript or PDF designed for human modification.  Examples of
transparent image formats include PNG, XCF and JPG.  Opaque formats
include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the
machine-generated HTML, PostScript or PDF produced by some word
processors for output purposes only.

The "Title Page" means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, "Title Page" means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

The "publisher" means any person or entity that distributes copies of
the Document to the public.

A section "Entitled XYZ" means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as "Acknowledgements",
"Dedications", "Endorsements", or "History".)  To "Preserve the Title"
of such a section when you modify the Document means that it remains a
section "Entitled XYZ" according to this definition.

The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.

2. VERBATIM COPYING

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no
other conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and
you may publicly display copies.


3. COPYING IN QUANTITY

If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to
give them a chance to provide you with an updated version of the
Document.


4. MODIFICATIONS

You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

A. Use in the Title Page (and on the covers, if any) a title distinct
   from that of the Document, and from those of previous versions
   (which should, if there were any, be listed in the History section
   of the Document).  You may use the same title as a previous version
   if the original publisher of that version gives permission.
B. List on the Title Page, as authors, one or more persons or entities
   responsible for authorship of the modifications in the Modified
   Version, together with at least five of the principal authors of the
   Document (all of its principal authors, if it has fewer than five),
   unless they release you from this requirement.
C. State on the Title page the name of the publisher of the
   Modified Version, as the publisher.
D. Preserve all the copyright notices of the Document.
E. Add an appropriate copyright notice for your modifications
   adjacent to the other copyright notices.
F. Include, immediately after the copyright notices, a license notice
   giving the public permission to use the Modified Version under the
   terms of this License, in the form shown in the Addendum below.
G. Preserve in that license notice the full lists of Invariant Sections
   and required Cover Texts given in the Document's license notice.
H. Include an unaltered copy of this License.
I. Preserve the section Entitled "History", Preserve its Title, and add
   to it an item stating at least the title, year, new authors, and
   publisher of the Modified Version as given on the Title Page.  If
   there is no section Entitled "History" in the Document, create one
   stating the title, year, authors, and publisher of the Document as
   given on its Title Page, then add an item describing the Modified
   Version as stated in the previous sentence.
J. Preserve the network location, if any, given in the Document for
   public access to a Transparent copy of the Document, and likewise
   the network locations given in the Document for previous versions
   it was based on.  These may be placed in the "History" section.
   You may omit a network location for a work that was published at
   least four years before the Document itself, or if the original
   publisher of the version it refers to gives permission.
K. For any section Entitled "Acknowledgements" or "Dedications",
   Preserve the Title of the section, and preserve in the section all
   the substance and tone of each of the contributor acknowledgements
   and/or dedications given therein.
L. Preserve all the Invariant Sections of the Document,
   unaltered in their text and in their titles.  Section numbers
   or the equivalent are not considered part of the section titles.
M. Delete any section Entitled "Endorsements".  Such a section
   may not be included in the Modified Version.
N. Do not retitle any existing section to be Entitled "Endorsements"
   or to conflict in title with any Invariant Section.
O. Preserve any Warranty Disclaimers.

If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.

You may add a section Entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.


5. COMBINING DOCUMENTS

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.

The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled "History"
in the various original documents, forming one section Entitled
"History"; likewise combine any sections Entitled "Acknowledgements",
and any sections Entitled "Dedications".  You must delete all sections
Entitled "Endorsements".


6. COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other
documents released under this License, and replace the individual
copies of this License in the various documents with a single copy
that is included in the collection, provided that you follow the rules
of this License for verbatim copying of each of the documents in all
other respects.

You may extract a single document from such a collection, and
distribute it individually under this License, provided you insert a
copy of this License into the extracted document, and follow this
License in all other respects regarding verbatim copying of that
document.


7. AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an "aggregate" if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.


8. TRANSLATION

Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.

If a section in the Document is Entitled "Acknowledgements",
"Dedications", or "History", the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.


9. TERMINATION

You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.

However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.


10. FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions of the
GNU Free Documentation License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in
detail to address new problems or concerns.  See
http://www.gnu.org/copyleft/.

Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy's public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.

11. RELICENSING

"Massive Multiauthor Collaboration Site" (or "MMC Site") means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
"Massive Multiauthor Collaboration" (or "MMC") contained in the site
means any set of copyrightable works thus published on the MMC site.

"CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.

"Incorporate" means to publish or republish a Document, in whole or in
part, as part of another Document.

An MMC is "eligible for relicensing" if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole or
in part into the MMC, (1) had no cover texts or invariant sections, and
(2) were thus incorporated prior to November 1, 2008.

The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.
</pre>


</div>

</div>

<div id="outline-container-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> Index</h2>
<div class="outline-text-2" id="text-13">


</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-07-11 Wed</p>
<p class="author">Author: John Kitchin</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3a with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
